Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    END
    ASC
    PRINT
    DO
    FOR
    NUM
    ABS
    DOWN
    READ
    BY
    EXIT
    PROC
    WHILE
    TO
    RETURNS
    OD
    RESULT
    LOC
    RETURN
    LOWER
    LENGTH
    UPPER

Grammar

Rule 0     S' -> program
Rule 1     program -> statement_list
Rule 2     statement_list -> statement statement_nullable
Rule 3     statement_nullable -> statement statement_nullable
Rule 4     statement_nullable -> empty
Rule 5     statement -> declaration_statement
Rule 6     statement -> synonym_statement
Rule 7     statement -> newmode_statement
Rule 8     synonym_statement -> SYN synonym_list SEMI
Rule 9     synonym_list -> synonym_definition
Rule 10    synonym_list -> synonym_definition COMMA synonym_list
Rule 11    synonym_definition -> identifier_list mode ASSIGN expression
Rule 12    synonym_definition -> identifier_list ASSIGN expression
Rule 13    declaration_statement -> DCL declaration_list SEMI
Rule 14    declaration_list -> declaration
Rule 15    declaration_list -> declaration COMMA declaration_list
Rule 16    declaration -> identifier_list mode initialization
Rule 17    declaration -> identifier_list mode
Rule 18    initialization -> ASSIGN expression
Rule 19    identifier_list -> identifier
Rule 20    identifier_list -> identifier COMMA identifier_list
Rule 21    identifier -> ID
Rule 22    newmode_statement -> TYPE newmode_list SEMI
Rule 23    newmode_list -> mode_definition
Rule 24    newmode_list -> mode_definition COMMA newmode_list
Rule 25    mode_definition -> identifier_list ASSIGN mode
Rule 26    mode -> mode_name
Rule 27    mode -> discrete_mode
Rule 28    mode -> reference_mode
Rule 29    mode -> composite_mode
Rule 30    mode_name -> identifier
Rule 31    discrete_mode -> integer_mode
Rule 32    discrete_mode -> boolean_mode
Rule 33    discrete_mode -> character_mode
Rule 34    discrete_mode -> discrete_range_mode
Rule 35    discrete_mode_name -> identifier
Rule 36    integer_mode -> INT
Rule 37    boolean_mode -> BOOL
Rule 38    character_mode -> CHAR
Rule 39    discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN
Rule 40    discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN
Rule 41    literal_range -> lower_bound COLON upper_bound
Rule 42    lower_bound -> expression
Rule 43    upper_bound -> expression
Rule 44    reference_mode -> REF mode
Rule 45    composite_mode -> string_mode
Rule 46    composite_mode -> array_mode
Rule 47    string_mode -> CHARS LBRACKET string_length RBRACKET
Rule 48    string_length -> integer_literal
Rule 49    array_mode -> ARRAY LBRACKET index_mode_list RBRACKET element_mode
Rule 50    index_mode_list -> index_mode
Rule 51    index_mode_list -> index_mode COMMA index_mode_list
Rule 52    index_mode -> discrete_mode
Rule 53    index_mode -> literal_range
Rule 54    element_mode -> mode
Rule 55    location -> identifier
Rule 56    location -> dereferenced_reference
Rule 57    location -> string_element
Rule 58    location -> string_slice
Rule 59    location -> array_element
Rule 60    location -> array_slice
Rule 61    dereferenced_reference -> array_location ARROW
Rule 62    string_element -> identifier LBRACKET start_element LBRACKET
Rule 63    start_element -> expression
Rule 64    string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET
Rule 65    left_element -> expression
Rule 66    right_element -> expression
Rule 67    array_element -> array_location LBRACKET expression_list RBRACKET
Rule 68    expression_list -> expression
Rule 69    expression_list -> expression COMMA expression_list
Rule 70    array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET
Rule 71    array_location -> location
Rule 72    expression -> operand0
Rule 73    expression -> conditional_expression
Rule 74    conditional_expression -> IF expression then_expression else_expression FI
Rule 75    conditional_expression -> IF expression then_expression elsif_expression else_expression FI
Rule 76    then_expression -> THEN expression
Rule 77    else_expression -> ELSE expression
Rule 78    elsif_expression -> ELSIF expression then_expression
Rule 79    elsif_expression -> elsif_expression ELSIF expression then_expression
Rule 80    operand0 -> operand1
Rule 81    operand0 -> operand0 operator1 operand1
Rule 82    operand1 -> operand2
Rule 83    operand1 -> operand1 operator2 operand2
Rule 84    operand2 -> operand3
Rule 85    operand2 -> operand2 arithmetic_multiplicative_operator operand3
Rule 86    operand3 -> monadic_operator operand4
Rule 87    operand3 -> operand4
Rule 88    operand4 -> array_location
Rule 89    operand4 -> referenced_location
Rule 90    operand4 -> primitive_value
Rule 91    arithmetic_multiplicative_operator -> TIMES
Rule 92    arithmetic_multiplicative_operator -> DIVIDE
Rule 93    arithmetic_multiplicative_operator -> MODULO
Rule 94    monadic_operator -> MINUS
Rule 95    monadic_operator -> NOT
Rule 96    referenced_location -> ARROW array_location
Rule 97    operator1 -> relational_operator
Rule 98    operator1 -> membership_operator
Rule 99    operator2 -> arithmetic_additive_operator
Rule 100   operator2 -> string_concatenation_operator
Rule 101   arithmetic_additive_operator -> PLUS
Rule 102   arithmetic_additive_operator -> MINUS
Rule 103   string_concatenation_operator -> CONCAT
Rule 104   relational_operator -> AND
Rule 105   relational_operator -> OR
Rule 106   relational_operator -> EQUAL
Rule 107   relational_operator -> NOTEQ
Rule 108   relational_operator -> GREATER
Rule 109   relational_operator -> GTEQUAL
Rule 110   relational_operator -> LESS
Rule 111   relational_operator -> LTEQUAL
Rule 112   membership_operator -> IN
Rule 113   primitive_value -> literal
Rule 114   literal -> integer_literal
Rule 115   literal -> boolean_literal
Rule 116   literal -> character_literal
Rule 117   literal -> empty_literal
Rule 118   literal -> character_string_literal
Rule 119   integer_literal -> ICONST
Rule 120   boolean_literal -> TRUE
Rule 121   boolean_literal -> FALSE
Rule 122   character_literal -> CCONST
Rule 123   empty_literal -> NULL
Rule 124   character_string_literal -> SCONST
Rule 125   empty -> <empty>

Terminals, with rules where they appear

ABS                  : 
AND                  : 104
ARRAY                : 49
ARROW                : 61 96
ASC                  : 
ASSIGN               : 11 12 18 25
BOOL                 : 37
BY                   : 
CCONST               : 122
CHAR                 : 38
CHARS                : 47
COLON                : 41 64 70
COMMA                : 10 15 20 24 51 69
CONCAT               : 103
DCL                  : 13
DIVIDE               : 92
DO                   : 
DOWN                 : 
ELSE                 : 77
ELSIF                : 78 79
END                  : 
EQUAL                : 106
EXIT                 : 
FALSE                : 121
FI                   : 74 75
FOR                  : 
GREATER              : 108
GTEQUAL              : 109
ICONST               : 119
ID                   : 21
IF                   : 74 75
IN                   : 112
INT                  : 36
LBRACKET             : 47 49 62 62 64 67 70
LENGTH               : 
LESS                 : 110
LOC                  : 
LOWER                : 
LPAREN               : 39 40
LTEQUAL              : 111
MINUS                : 94 102
MODULO               : 93
NOT                  : 95
NOTEQ                : 107
NULL                 : 123
NUM                  : 
OD                   : 
OR                   : 105
PLUS                 : 101
PRINT                : 
PROC                 : 
RBRACKET             : 47 49 64 67 70
READ                 : 
REF                  : 44
RESULT               : 
RETURN               : 
RETURNS              : 
RPAREN               : 39 40
SCONST               : 124
SEMI                 : 8 13 22
SYN                  : 8
THEN                 : 76
TIMES                : 91
TO                   : 
TRUE                 : 120
TYPE                 : 22
UPPER                : 
WHILE                : 
error                : 

Nonterminals, with rules where they appear

arithmetic_additive_operator : 99
arithmetic_multiplicative_operator : 85
array_element        : 59
array_location       : 61 67 70 88 96
array_mode           : 46
array_slice          : 60
boolean_literal      : 115
boolean_mode         : 32
character_literal    : 116
character_mode       : 33
character_string_literal : 118
composite_mode       : 29
conditional_expression : 73
declaration          : 14 15
declaration_list     : 13 15
declaration_statement : 5
dereferenced_reference : 56
discrete_mode        : 27 40 52
discrete_mode_name   : 39
discrete_range_mode  : 34
element_mode         : 49
else_expression      : 74 75
elsif_expression     : 75 79
empty                : 4
empty_literal        : 117
expression           : 11 12 18 42 43 63 65 66 68 69 74 75 76 77 78 79
expression_list      : 67 69
identifier           : 19 20 30 35 55 62 64
identifier_list      : 11 12 16 17 20 25
index_mode           : 50 51
index_mode_list      : 49 51
initialization       : 16
integer_literal      : 48 114
integer_mode         : 31
left_element         : 64
literal              : 113
literal_range        : 39 40 53
location             : 71
lower_bound          : 41 70
membership_operator  : 98
mode                 : 11 16 17 25 44 54
mode_definition      : 23 24
mode_name            : 26
monadic_operator     : 86
newmode_list         : 22 24
newmode_statement    : 7
operand0             : 72 81
operand1             : 80 81 83
operand2             : 82 83 85
operand3             : 84 85
operand4             : 86 87
operator1            : 81
operator2            : 83
primitive_value      : 90
program              : 0
reference_mode       : 28
referenced_location  : 89
relational_operator  : 97
right_element        : 64
start_element        : 62
statement            : 2 3
statement_list       : 1
statement_nullable   : 2 3
string_concatenation_operator : 100
string_element       : 57
string_length        : 47
string_mode          : 45
string_slice         : 58
synonym_definition   : 9 10
synonym_list         : 8 10
synonym_statement    : 6
then_expression      : 74 75 78 79
upper_bound          : 41 70

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statement_list
    (2) statement_list -> . statement statement_nullable
    (5) statement -> . declaration_statement
    (6) statement -> . synonym_statement
    (7) statement -> . newmode_statement
    (13) declaration_statement -> . DCL declaration_list SEMI
    (8) synonym_statement -> . SYN synonym_list SEMI
    (22) newmode_statement -> . TYPE newmode_list SEMI

    DCL             shift and go to state 2
    SYN             shift and go to state 4
    TYPE            shift and go to state 1

    statement                      shift and go to state 6
    newmode_statement              shift and go to state 3
    synonym_statement              shift and go to state 7
    statement_list                 shift and go to state 8
    declaration_statement          shift and go to state 9
    program                        shift and go to state 5

state 1

    (22) newmode_statement -> TYPE . newmode_list SEMI
    (23) newmode_list -> . mode_definition
    (24) newmode_list -> . mode_definition COMMA newmode_list
    (25) mode_definition -> . identifier_list ASSIGN mode
    (19) identifier_list -> . identifier
    (20) identifier_list -> . identifier COMMA identifier_list
    (21) identifier -> . ID

    ID              shift and go to state 11

    identifier                     shift and go to state 12
    mode_definition                shift and go to state 13
    identifier_list                shift and go to state 10
    newmode_list                   shift and go to state 14

state 2

    (13) declaration_statement -> DCL . declaration_list SEMI
    (14) declaration_list -> . declaration
    (15) declaration_list -> . declaration COMMA declaration_list
    (16) declaration -> . identifier_list mode initialization
    (17) declaration -> . identifier_list mode
    (19) identifier_list -> . identifier
    (20) identifier_list -> . identifier COMMA identifier_list
    (21) identifier -> . ID

    ID              shift and go to state 11

    declaration_list               shift and go to state 15
    identifier_list                shift and go to state 16
    identifier                     shift and go to state 12
    declaration                    shift and go to state 17

state 3

    (7) statement -> newmode_statement .

    DCL             reduce using rule 7 (statement -> newmode_statement .)
    SYN             reduce using rule 7 (statement -> newmode_statement .)
    TYPE            reduce using rule 7 (statement -> newmode_statement .)
    $end            reduce using rule 7 (statement -> newmode_statement .)


state 4

    (8) synonym_statement -> SYN . synonym_list SEMI
    (9) synonym_list -> . synonym_definition
    (10) synonym_list -> . synonym_definition COMMA synonym_list
    (11) synonym_definition -> . identifier_list mode ASSIGN expression
    (12) synonym_definition -> . identifier_list ASSIGN expression
    (19) identifier_list -> . identifier
    (20) identifier_list -> . identifier COMMA identifier_list
    (21) identifier -> . ID

    ID              shift and go to state 11

    identifier_list                shift and go to state 18
    synonym_list                   shift and go to state 19
    identifier                     shift and go to state 12
    synonym_definition             shift and go to state 20

state 5

    (0) S' -> program .



state 6

    (2) statement_list -> statement . statement_nullable
    (3) statement_nullable -> . statement statement_nullable
    (4) statement_nullable -> . empty
    (5) statement -> . declaration_statement
    (6) statement -> . synonym_statement
    (7) statement -> . newmode_statement
    (125) empty -> .
    (13) declaration_statement -> . DCL declaration_list SEMI
    (8) synonym_statement -> . SYN synonym_list SEMI
    (22) newmode_statement -> . TYPE newmode_list SEMI

    $end            reduce using rule 125 (empty -> .)
    DCL             shift and go to state 2
    SYN             shift and go to state 4
    TYPE            shift and go to state 1

    empty                          shift and go to state 21
    statement                      shift and go to state 22
    newmode_statement              shift and go to state 3
    synonym_statement              shift and go to state 7
    statement_nullable             shift and go to state 23
    declaration_statement          shift and go to state 9

state 7

    (6) statement -> synonym_statement .

    DCL             reduce using rule 6 (statement -> synonym_statement .)
    SYN             reduce using rule 6 (statement -> synonym_statement .)
    TYPE            reduce using rule 6 (statement -> synonym_statement .)
    $end            reduce using rule 6 (statement -> synonym_statement .)


state 8

    (1) program -> statement_list .

    $end            reduce using rule 1 (program -> statement_list .)


state 9

    (5) statement -> declaration_statement .

    DCL             reduce using rule 5 (statement -> declaration_statement .)
    SYN             reduce using rule 5 (statement -> declaration_statement .)
    TYPE            reduce using rule 5 (statement -> declaration_statement .)
    $end            reduce using rule 5 (statement -> declaration_statement .)


state 10

    (25) mode_definition -> identifier_list . ASSIGN mode

    ASSIGN          shift and go to state 24


state 11

    (21) identifier -> ID .

    ASSIGN          reduce using rule 21 (identifier -> ID .)
    LPAREN          reduce using rule 21 (identifier -> ID .)
    COMMA           reduce using rule 21 (identifier -> ID .)
    SEMI            reduce using rule 21 (identifier -> ID .)
    LBRACKET        reduce using rule 21 (identifier -> ID .)
    ARROW           reduce using rule 21 (identifier -> ID .)
    TIMES           reduce using rule 21 (identifier -> ID .)
    DIVIDE          reduce using rule 21 (identifier -> ID .)
    MODULO          reduce using rule 21 (identifier -> ID .)
    PLUS            reduce using rule 21 (identifier -> ID .)
    MINUS           reduce using rule 21 (identifier -> ID .)
    CONCAT          reduce using rule 21 (identifier -> ID .)
    AND             reduce using rule 21 (identifier -> ID .)
    OR              reduce using rule 21 (identifier -> ID .)
    EQUAL           reduce using rule 21 (identifier -> ID .)
    NOTEQ           reduce using rule 21 (identifier -> ID .)
    GREATER         reduce using rule 21 (identifier -> ID .)
    GTEQUAL         reduce using rule 21 (identifier -> ID .)
    LESS            reduce using rule 21 (identifier -> ID .)
    LTEQUAL         reduce using rule 21 (identifier -> ID .)
    IN              reduce using rule 21 (identifier -> ID .)
    COLON           reduce using rule 21 (identifier -> ID .)
    REF             reduce using rule 21 (identifier -> ID .)
    ID              reduce using rule 21 (identifier -> ID .)
    INT             reduce using rule 21 (identifier -> ID .)
    BOOL            reduce using rule 21 (identifier -> ID .)
    CHAR            reduce using rule 21 (identifier -> ID .)
    CHARS           reduce using rule 21 (identifier -> ID .)
    ARRAY           reduce using rule 21 (identifier -> ID .)
    THEN            reduce using rule 21 (identifier -> ID .)
    RBRACKET        reduce using rule 21 (identifier -> ID .)
    RPAREN          reduce using rule 21 (identifier -> ID .)
    ELSE            reduce using rule 21 (identifier -> ID .)
    ELSIF           reduce using rule 21 (identifier -> ID .)
    FI              reduce using rule 21 (identifier -> ID .)


state 12

    (19) identifier_list -> identifier .
    (20) identifier_list -> identifier . COMMA identifier_list

    ASSIGN          reduce using rule 19 (identifier_list -> identifier .)
    REF             reduce using rule 19 (identifier_list -> identifier .)
    ID              reduce using rule 19 (identifier_list -> identifier .)
    INT             reduce using rule 19 (identifier_list -> identifier .)
    BOOL            reduce using rule 19 (identifier_list -> identifier .)
    CHAR            reduce using rule 19 (identifier_list -> identifier .)
    CHARS           reduce using rule 19 (identifier_list -> identifier .)
    ARRAY           reduce using rule 19 (identifier_list -> identifier .)
    COMMA           shift and go to state 25


state 13

    (23) newmode_list -> mode_definition .
    (24) newmode_list -> mode_definition . COMMA newmode_list

    SEMI            reduce using rule 23 (newmode_list -> mode_definition .)
    COMMA           shift and go to state 26


state 14

    (22) newmode_statement -> TYPE newmode_list . SEMI

    SEMI            shift and go to state 27


state 15

    (13) declaration_statement -> DCL declaration_list . SEMI

    SEMI            shift and go to state 28


state 16

    (16) declaration -> identifier_list . mode initialization
    (17) declaration -> identifier_list . mode
    (26) mode -> . mode_name
    (27) mode -> . discrete_mode
    (28) mode -> . reference_mode
    (29) mode -> . composite_mode
    (30) mode_name -> . identifier
    (31) discrete_mode -> . integer_mode
    (32) discrete_mode -> . boolean_mode
    (33) discrete_mode -> . character_mode
    (34) discrete_mode -> . discrete_range_mode
    (44) reference_mode -> . REF mode
    (45) composite_mode -> . string_mode
    (46) composite_mode -> . array_mode
    (21) identifier -> . ID
    (36) integer_mode -> . INT
    (37) boolean_mode -> . BOOL
    (38) character_mode -> . CHAR
    (39) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (40) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (47) string_mode -> . CHARS LBRACKET string_length RBRACKET
    (49) array_mode -> . ARRAY LBRACKET index_mode_list RBRACKET element_mode
    (35) discrete_mode_name -> . identifier

    REF             shift and go to state 38
    ID              shift and go to state 11
    INT             shift and go to state 36
    BOOL            shift and go to state 33
    CHAR            shift and go to state 42
    CHARS           shift and go to state 35
    ARRAY           shift and go to state 39

    composite_mode                 shift and go to state 41
    mode_name                      shift and go to state 43
    reference_mode                 shift and go to state 29
    identifier                     shift and go to state 30
    discrete_range_mode            shift and go to state 31
    boolean_mode                   shift and go to state 44
    mode                           shift and go to state 32
    string_mode                    shift and go to state 45
    discrete_mode_name             shift and go to state 46
    discrete_mode                  shift and go to state 34
    character_mode                 shift and go to state 37
    array_mode                     shift and go to state 47
    integer_mode                   shift and go to state 40

state 17

    (14) declaration_list -> declaration .
    (15) declaration_list -> declaration . COMMA declaration_list

    SEMI            reduce using rule 14 (declaration_list -> declaration .)
    COMMA           shift and go to state 48


state 18

    (11) synonym_definition -> identifier_list . mode ASSIGN expression
    (12) synonym_definition -> identifier_list . ASSIGN expression
    (26) mode -> . mode_name
    (27) mode -> . discrete_mode
    (28) mode -> . reference_mode
    (29) mode -> . composite_mode
    (30) mode_name -> . identifier
    (31) discrete_mode -> . integer_mode
    (32) discrete_mode -> . boolean_mode
    (33) discrete_mode -> . character_mode
    (34) discrete_mode -> . discrete_range_mode
    (44) reference_mode -> . REF mode
    (45) composite_mode -> . string_mode
    (46) composite_mode -> . array_mode
    (21) identifier -> . ID
    (36) integer_mode -> . INT
    (37) boolean_mode -> . BOOL
    (38) character_mode -> . CHAR
    (39) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (40) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (47) string_mode -> . CHARS LBRACKET string_length RBRACKET
    (49) array_mode -> . ARRAY LBRACKET index_mode_list RBRACKET element_mode
    (35) discrete_mode_name -> . identifier

    ASSIGN          shift and go to state 50
    REF             shift and go to state 38
    ID              shift and go to state 11
    INT             shift and go to state 36
    BOOL            shift and go to state 33
    CHAR            shift and go to state 42
    CHARS           shift and go to state 35
    ARRAY           shift and go to state 39

    composite_mode                 shift and go to state 41
    mode_name                      shift and go to state 43
    reference_mode                 shift and go to state 29
    identifier                     shift and go to state 30
    discrete_range_mode            shift and go to state 31
    boolean_mode                   shift and go to state 44
    mode                           shift and go to state 49
    string_mode                    shift and go to state 45
    discrete_mode_name             shift and go to state 46
    discrete_mode                  shift and go to state 34
    character_mode                 shift and go to state 37
    array_mode                     shift and go to state 47
    integer_mode                   shift and go to state 40

state 19

    (8) synonym_statement -> SYN synonym_list . SEMI

    SEMI            shift and go to state 51


state 20

    (9) synonym_list -> synonym_definition .
    (10) synonym_list -> synonym_definition . COMMA synonym_list

    SEMI            reduce using rule 9 (synonym_list -> synonym_definition .)
    COMMA           shift and go to state 52


state 21

    (4) statement_nullable -> empty .

    $end            reduce using rule 4 (statement_nullable -> empty .)


state 22

    (3) statement_nullable -> statement . statement_nullable
    (3) statement_nullable -> . statement statement_nullable
    (4) statement_nullable -> . empty
    (5) statement -> . declaration_statement
    (6) statement -> . synonym_statement
    (7) statement -> . newmode_statement
    (125) empty -> .
    (13) declaration_statement -> . DCL declaration_list SEMI
    (8) synonym_statement -> . SYN synonym_list SEMI
    (22) newmode_statement -> . TYPE newmode_list SEMI

    $end            reduce using rule 125 (empty -> .)
    DCL             shift and go to state 2
    SYN             shift and go to state 4
    TYPE            shift and go to state 1

    empty                          shift and go to state 21
    statement                      shift and go to state 22
    newmode_statement              shift and go to state 3
    synonym_statement              shift and go to state 7
    statement_nullable             shift and go to state 53
    declaration_statement          shift and go to state 9

state 23

    (2) statement_list -> statement statement_nullable .

    $end            reduce using rule 2 (statement_list -> statement statement_nullable .)


state 24

    (25) mode_definition -> identifier_list ASSIGN . mode
    (26) mode -> . mode_name
    (27) mode -> . discrete_mode
    (28) mode -> . reference_mode
    (29) mode -> . composite_mode
    (30) mode_name -> . identifier
    (31) discrete_mode -> . integer_mode
    (32) discrete_mode -> . boolean_mode
    (33) discrete_mode -> . character_mode
    (34) discrete_mode -> . discrete_range_mode
    (44) reference_mode -> . REF mode
    (45) composite_mode -> . string_mode
    (46) composite_mode -> . array_mode
    (21) identifier -> . ID
    (36) integer_mode -> . INT
    (37) boolean_mode -> . BOOL
    (38) character_mode -> . CHAR
    (39) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (40) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (47) string_mode -> . CHARS LBRACKET string_length RBRACKET
    (49) array_mode -> . ARRAY LBRACKET index_mode_list RBRACKET element_mode
    (35) discrete_mode_name -> . identifier

    REF             shift and go to state 38
    ID              shift and go to state 11
    INT             shift and go to state 36
    BOOL            shift and go to state 33
    CHAR            shift and go to state 42
    CHARS           shift and go to state 35
    ARRAY           shift and go to state 39

    composite_mode                 shift and go to state 41
    mode_name                      shift and go to state 43
    reference_mode                 shift and go to state 29
    identifier                     shift and go to state 30
    discrete_range_mode            shift and go to state 31
    boolean_mode                   shift and go to state 44
    mode                           shift and go to state 54
    string_mode                    shift and go to state 45
    discrete_mode_name             shift and go to state 46
    discrete_mode                  shift and go to state 34
    character_mode                 shift and go to state 37
    array_mode                     shift and go to state 47
    integer_mode                   shift and go to state 40

state 25

    (20) identifier_list -> identifier COMMA . identifier_list
    (19) identifier_list -> . identifier
    (20) identifier_list -> . identifier COMMA identifier_list
    (21) identifier -> . ID

    ID              shift and go to state 11

    identifier                     shift and go to state 12
    identifier_list                shift and go to state 55

state 26

    (24) newmode_list -> mode_definition COMMA . newmode_list
    (23) newmode_list -> . mode_definition
    (24) newmode_list -> . mode_definition COMMA newmode_list
    (25) mode_definition -> . identifier_list ASSIGN mode
    (19) identifier_list -> . identifier
    (20) identifier_list -> . identifier COMMA identifier_list
    (21) identifier -> . ID

    ID              shift and go to state 11

    identifier                     shift and go to state 12
    mode_definition                shift and go to state 13
    identifier_list                shift and go to state 10
    newmode_list                   shift and go to state 56

state 27

    (22) newmode_statement -> TYPE newmode_list SEMI .

    DCL             reduce using rule 22 (newmode_statement -> TYPE newmode_list SEMI .)
    SYN             reduce using rule 22 (newmode_statement -> TYPE newmode_list SEMI .)
    TYPE            reduce using rule 22 (newmode_statement -> TYPE newmode_list SEMI .)
    $end            reduce using rule 22 (newmode_statement -> TYPE newmode_list SEMI .)


state 28

    (13) declaration_statement -> DCL declaration_list SEMI .

    DCL             reduce using rule 13 (declaration_statement -> DCL declaration_list SEMI .)
    SYN             reduce using rule 13 (declaration_statement -> DCL declaration_list SEMI .)
    TYPE            reduce using rule 13 (declaration_statement -> DCL declaration_list SEMI .)
    $end            reduce using rule 13 (declaration_statement -> DCL declaration_list SEMI .)


state 29

    (28) mode -> reference_mode .

    ASSIGN          reduce using rule 28 (mode -> reference_mode .)
    COMMA           reduce using rule 28 (mode -> reference_mode .)
    SEMI            reduce using rule 28 (mode -> reference_mode .)


state 30

    (30) mode_name -> identifier .
    (35) discrete_mode_name -> identifier .

    ASSIGN          reduce using rule 30 (mode_name -> identifier .)
    COMMA           reduce using rule 30 (mode_name -> identifier .)
    SEMI            reduce using rule 30 (mode_name -> identifier .)
    LPAREN          reduce using rule 35 (discrete_mode_name -> identifier .)


state 31

    (34) discrete_mode -> discrete_range_mode .

    LPAREN          reduce using rule 34 (discrete_mode -> discrete_range_mode .)
    COMMA           reduce using rule 34 (discrete_mode -> discrete_range_mode .)
    RBRACKET        reduce using rule 34 (discrete_mode -> discrete_range_mode .)
    ASSIGN          reduce using rule 34 (discrete_mode -> discrete_range_mode .)
    SEMI            reduce using rule 34 (discrete_mode -> discrete_range_mode .)


state 32

    (16) declaration -> identifier_list mode . initialization
    (17) declaration -> identifier_list mode .
    (18) initialization -> . ASSIGN expression

    COMMA           reduce using rule 17 (declaration -> identifier_list mode .)
    SEMI            reduce using rule 17 (declaration -> identifier_list mode .)
    ASSIGN          shift and go to state 57

    initialization                 shift and go to state 58

state 33

    (37) boolean_mode -> BOOL .

    LPAREN          reduce using rule 37 (boolean_mode -> BOOL .)
    ASSIGN          reduce using rule 37 (boolean_mode -> BOOL .)
    COMMA           reduce using rule 37 (boolean_mode -> BOOL .)
    SEMI            reduce using rule 37 (boolean_mode -> BOOL .)
    RBRACKET        reduce using rule 37 (boolean_mode -> BOOL .)


state 34

    (27) mode -> discrete_mode .
    (40) discrete_range_mode -> discrete_mode . LPAREN literal_range RPAREN

    ASSIGN          reduce using rule 27 (mode -> discrete_mode .)
    COMMA           reduce using rule 27 (mode -> discrete_mode .)
    SEMI            reduce using rule 27 (mode -> discrete_mode .)
    LPAREN          shift and go to state 59


state 35

    (47) string_mode -> CHARS . LBRACKET string_length RBRACKET

    LBRACKET        shift and go to state 60


state 36

    (36) integer_mode -> INT .

    LPAREN          reduce using rule 36 (integer_mode -> INT .)
    ASSIGN          reduce using rule 36 (integer_mode -> INT .)
    COMMA           reduce using rule 36 (integer_mode -> INT .)
    SEMI            reduce using rule 36 (integer_mode -> INT .)
    RBRACKET        reduce using rule 36 (integer_mode -> INT .)


state 37

    (33) discrete_mode -> character_mode .

    LPAREN          reduce using rule 33 (discrete_mode -> character_mode .)
    COMMA           reduce using rule 33 (discrete_mode -> character_mode .)
    RBRACKET        reduce using rule 33 (discrete_mode -> character_mode .)
    ASSIGN          reduce using rule 33 (discrete_mode -> character_mode .)
    SEMI            reduce using rule 33 (discrete_mode -> character_mode .)


state 38

    (44) reference_mode -> REF . mode
    (26) mode -> . mode_name
    (27) mode -> . discrete_mode
    (28) mode -> . reference_mode
    (29) mode -> . composite_mode
    (30) mode_name -> . identifier
    (31) discrete_mode -> . integer_mode
    (32) discrete_mode -> . boolean_mode
    (33) discrete_mode -> . character_mode
    (34) discrete_mode -> . discrete_range_mode
    (44) reference_mode -> . REF mode
    (45) composite_mode -> . string_mode
    (46) composite_mode -> . array_mode
    (21) identifier -> . ID
    (36) integer_mode -> . INT
    (37) boolean_mode -> . BOOL
    (38) character_mode -> . CHAR
    (39) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (40) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (47) string_mode -> . CHARS LBRACKET string_length RBRACKET
    (49) array_mode -> . ARRAY LBRACKET index_mode_list RBRACKET element_mode
    (35) discrete_mode_name -> . identifier

    REF             shift and go to state 38
    ID              shift and go to state 11
    INT             shift and go to state 36
    BOOL            shift and go to state 33
    CHAR            shift and go to state 42
    CHARS           shift and go to state 35
    ARRAY           shift and go to state 39

    composite_mode                 shift and go to state 41
    mode_name                      shift and go to state 43
    reference_mode                 shift and go to state 29
    identifier                     shift and go to state 30
    discrete_range_mode            shift and go to state 31
    boolean_mode                   shift and go to state 44
    mode                           shift and go to state 61
    string_mode                    shift and go to state 45
    discrete_mode_name             shift and go to state 46
    discrete_mode                  shift and go to state 34
    character_mode                 shift and go to state 37
    array_mode                     shift and go to state 47
    integer_mode                   shift and go to state 40

state 39

    (49) array_mode -> ARRAY . LBRACKET index_mode_list RBRACKET element_mode

    LBRACKET        shift and go to state 62


state 40

    (31) discrete_mode -> integer_mode .

    LPAREN          reduce using rule 31 (discrete_mode -> integer_mode .)
    COMMA           reduce using rule 31 (discrete_mode -> integer_mode .)
    RBRACKET        reduce using rule 31 (discrete_mode -> integer_mode .)
    ASSIGN          reduce using rule 31 (discrete_mode -> integer_mode .)
    SEMI            reduce using rule 31 (discrete_mode -> integer_mode .)


state 41

    (29) mode -> composite_mode .

    ASSIGN          reduce using rule 29 (mode -> composite_mode .)
    COMMA           reduce using rule 29 (mode -> composite_mode .)
    SEMI            reduce using rule 29 (mode -> composite_mode .)


state 42

    (38) character_mode -> CHAR .

    LPAREN          reduce using rule 38 (character_mode -> CHAR .)
    COMMA           reduce using rule 38 (character_mode -> CHAR .)
    RBRACKET        reduce using rule 38 (character_mode -> CHAR .)
    ASSIGN          reduce using rule 38 (character_mode -> CHAR .)
    SEMI            reduce using rule 38 (character_mode -> CHAR .)


state 43

    (26) mode -> mode_name .

    ASSIGN          reduce using rule 26 (mode -> mode_name .)
    COMMA           reduce using rule 26 (mode -> mode_name .)
    SEMI            reduce using rule 26 (mode -> mode_name .)


state 44

    (32) discrete_mode -> boolean_mode .

    LPAREN          reduce using rule 32 (discrete_mode -> boolean_mode .)
    COMMA           reduce using rule 32 (discrete_mode -> boolean_mode .)
    RBRACKET        reduce using rule 32 (discrete_mode -> boolean_mode .)
    ASSIGN          reduce using rule 32 (discrete_mode -> boolean_mode .)
    SEMI            reduce using rule 32 (discrete_mode -> boolean_mode .)


state 45

    (45) composite_mode -> string_mode .

    ASSIGN          reduce using rule 45 (composite_mode -> string_mode .)
    COMMA           reduce using rule 45 (composite_mode -> string_mode .)
    SEMI            reduce using rule 45 (composite_mode -> string_mode .)


state 46

    (39) discrete_range_mode -> discrete_mode_name . LPAREN literal_range RPAREN

    LPAREN          shift and go to state 63


state 47

    (46) composite_mode -> array_mode .

    ASSIGN          reduce using rule 46 (composite_mode -> array_mode .)
    COMMA           reduce using rule 46 (composite_mode -> array_mode .)
    SEMI            reduce using rule 46 (composite_mode -> array_mode .)


state 48

    (15) declaration_list -> declaration COMMA . declaration_list
    (14) declaration_list -> . declaration
    (15) declaration_list -> . declaration COMMA declaration_list
    (16) declaration -> . identifier_list mode initialization
    (17) declaration -> . identifier_list mode
    (19) identifier_list -> . identifier
    (20) identifier_list -> . identifier COMMA identifier_list
    (21) identifier -> . ID

    ID              shift and go to state 11

    declaration_list               shift and go to state 64
    identifier_list                shift and go to state 16
    identifier                     shift and go to state 12
    declaration                    shift and go to state 17

state 49

    (11) synonym_definition -> identifier_list mode . ASSIGN expression

    ASSIGN          shift and go to state 65


state 50

    (12) synonym_definition -> identifier_list ASSIGN . expression
    (72) expression -> . operand0
    (73) expression -> . conditional_expression
    (80) operand0 -> . operand1
    (81) operand0 -> . operand0 operator1 operand1
    (74) conditional_expression -> . IF expression then_expression else_expression FI
    (75) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (82) operand1 -> . operand2
    (83) operand1 -> . operand1 operator2 operand2
    (84) operand2 -> . operand3
    (85) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (86) operand3 -> . monadic_operator operand4
    (87) operand3 -> . operand4
    (94) monadic_operator -> . MINUS
    (95) monadic_operator -> . NOT
    (88) operand4 -> . array_location
    (89) operand4 -> . referenced_location
    (90) operand4 -> . primitive_value
    (71) array_location -> . location
    (96) referenced_location -> . ARROW array_location
    (113) primitive_value -> . literal
    (55) location -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (114) literal -> . integer_literal
    (115) literal -> . boolean_literal
    (116) literal -> . character_literal
    (117) literal -> . empty_literal
    (118) literal -> . character_string_literal
    (21) identifier -> . ID
    (61) dereferenced_reference -> . array_location ARROW
    (62) string_element -> . identifier LBRACKET start_element LBRACKET
    (64) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (67) array_element -> . array_location LBRACKET expression_list RBRACKET
    (70) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (119) integer_literal -> . ICONST
    (120) boolean_literal -> . TRUE
    (121) boolean_literal -> . FALSE
    (122) character_literal -> . CCONST
    (123) empty_literal -> . NULL
    (124) character_string_literal -> . SCONST

    IF              shift and go to state 96
    MINUS           shift and go to state 91
    NOT             shift and go to state 89
    ARROW           shift and go to state 82
    ID              shift and go to state 11
    ICONST          shift and go to state 93
    TRUE            shift and go to state 77
    FALSE           shift and go to state 66
    CCONST          shift and go to state 76
    NULL            shift and go to state 84
    SCONST          shift and go to state 74

    operand3                       shift and go to state 83
    string_element                 shift and go to state 67
    expression                     shift and go to state 68
    identifier                     shift and go to state 85
    primitive_value                shift and go to state 86
    operand1                       shift and go to state 69
    operand2                       shift and go to state 87
    conditional_expression         shift and go to state 88
    literal                        shift and go to state 70
    location                       shift and go to state 90
    referenced_location            shift and go to state 71
    character_string_literal       shift and go to state 72
    empty_literal                  shift and go to state 75
    array_slice                    shift and go to state 95
    character_literal              shift and go to state 94
    boolean_literal                shift and go to state 97
    monadic_operator               shift and go to state 73
    array_location                 shift and go to state 78
    operand0                       shift and go to state 98
    operand4                       shift and go to state 79
    integer_literal                shift and go to state 80
    dereferenced_reference         shift and go to state 92
    array_element                  shift and go to state 99
    string_slice                   shift and go to state 81

state 51

    (8) synonym_statement -> SYN synonym_list SEMI .

    DCL             reduce using rule 8 (synonym_statement -> SYN synonym_list SEMI .)
    SYN             reduce using rule 8 (synonym_statement -> SYN synonym_list SEMI .)
    TYPE            reduce using rule 8 (synonym_statement -> SYN synonym_list SEMI .)
    $end            reduce using rule 8 (synonym_statement -> SYN synonym_list SEMI .)


state 52

    (10) synonym_list -> synonym_definition COMMA . synonym_list
    (9) synonym_list -> . synonym_definition
    (10) synonym_list -> . synonym_definition COMMA synonym_list
    (11) synonym_definition -> . identifier_list mode ASSIGN expression
    (12) synonym_definition -> . identifier_list ASSIGN expression
    (19) identifier_list -> . identifier
    (20) identifier_list -> . identifier COMMA identifier_list
    (21) identifier -> . ID

    ID              shift and go to state 11

    identifier_list                shift and go to state 18
    synonym_list                   shift and go to state 100
    identifier                     shift and go to state 12
    synonym_definition             shift and go to state 20

state 53

    (3) statement_nullable -> statement statement_nullable .

    $end            reduce using rule 3 (statement_nullable -> statement statement_nullable .)


state 54

    (25) mode_definition -> identifier_list ASSIGN mode .

    COMMA           reduce using rule 25 (mode_definition -> identifier_list ASSIGN mode .)
    SEMI            reduce using rule 25 (mode_definition -> identifier_list ASSIGN mode .)


state 55

    (20) identifier_list -> identifier COMMA identifier_list .

    ASSIGN          reduce using rule 20 (identifier_list -> identifier COMMA identifier_list .)
    REF             reduce using rule 20 (identifier_list -> identifier COMMA identifier_list .)
    ID              reduce using rule 20 (identifier_list -> identifier COMMA identifier_list .)
    INT             reduce using rule 20 (identifier_list -> identifier COMMA identifier_list .)
    BOOL            reduce using rule 20 (identifier_list -> identifier COMMA identifier_list .)
    CHAR            reduce using rule 20 (identifier_list -> identifier COMMA identifier_list .)
    CHARS           reduce using rule 20 (identifier_list -> identifier COMMA identifier_list .)
    ARRAY           reduce using rule 20 (identifier_list -> identifier COMMA identifier_list .)


state 56

    (24) newmode_list -> mode_definition COMMA newmode_list .

    SEMI            reduce using rule 24 (newmode_list -> mode_definition COMMA newmode_list .)


state 57

    (18) initialization -> ASSIGN . expression
    (72) expression -> . operand0
    (73) expression -> . conditional_expression
    (80) operand0 -> . operand1
    (81) operand0 -> . operand0 operator1 operand1
    (74) conditional_expression -> . IF expression then_expression else_expression FI
    (75) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (82) operand1 -> . operand2
    (83) operand1 -> . operand1 operator2 operand2
    (84) operand2 -> . operand3
    (85) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (86) operand3 -> . monadic_operator operand4
    (87) operand3 -> . operand4
    (94) monadic_operator -> . MINUS
    (95) monadic_operator -> . NOT
    (88) operand4 -> . array_location
    (89) operand4 -> . referenced_location
    (90) operand4 -> . primitive_value
    (71) array_location -> . location
    (96) referenced_location -> . ARROW array_location
    (113) primitive_value -> . literal
    (55) location -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (114) literal -> . integer_literal
    (115) literal -> . boolean_literal
    (116) literal -> . character_literal
    (117) literal -> . empty_literal
    (118) literal -> . character_string_literal
    (21) identifier -> . ID
    (61) dereferenced_reference -> . array_location ARROW
    (62) string_element -> . identifier LBRACKET start_element LBRACKET
    (64) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (67) array_element -> . array_location LBRACKET expression_list RBRACKET
    (70) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (119) integer_literal -> . ICONST
    (120) boolean_literal -> . TRUE
    (121) boolean_literal -> . FALSE
    (122) character_literal -> . CCONST
    (123) empty_literal -> . NULL
    (124) character_string_literal -> . SCONST

    IF              shift and go to state 96
    MINUS           shift and go to state 91
    NOT             shift and go to state 89
    ARROW           shift and go to state 82
    ID              shift and go to state 11
    ICONST          shift and go to state 93
    TRUE            shift and go to state 77
    FALSE           shift and go to state 66
    CCONST          shift and go to state 76
    NULL            shift and go to state 84
    SCONST          shift and go to state 74

    operand3                       shift and go to state 83
    string_element                 shift and go to state 67
    expression                     shift and go to state 101
    identifier                     shift and go to state 85
    primitive_value                shift and go to state 86
    operand1                       shift and go to state 69
    operand2                       shift and go to state 87
    conditional_expression         shift and go to state 88
    literal                        shift and go to state 70
    location                       shift and go to state 90
    referenced_location            shift and go to state 71
    character_string_literal       shift and go to state 72
    dereferenced_reference         shift and go to state 92
    empty_literal                  shift and go to state 75
    array_slice                    shift and go to state 95
    character_literal              shift and go to state 94
    boolean_literal                shift and go to state 97
    monadic_operator               shift and go to state 73
    array_location                 shift and go to state 78
    operand0                       shift and go to state 98
    operand4                       shift and go to state 79
    integer_literal                shift and go to state 80
    array_element                  shift and go to state 99
    string_slice                   shift and go to state 81

state 58

    (16) declaration -> identifier_list mode initialization .

    COMMA           reduce using rule 16 (declaration -> identifier_list mode initialization .)
    SEMI            reduce using rule 16 (declaration -> identifier_list mode initialization .)


state 59

    (40) discrete_range_mode -> discrete_mode LPAREN . literal_range RPAREN
    (41) literal_range -> . lower_bound COLON upper_bound
    (42) lower_bound -> . expression
    (72) expression -> . operand0
    (73) expression -> . conditional_expression
    (80) operand0 -> . operand1
    (81) operand0 -> . operand0 operator1 operand1
    (74) conditional_expression -> . IF expression then_expression else_expression FI
    (75) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (82) operand1 -> . operand2
    (83) operand1 -> . operand1 operator2 operand2
    (84) operand2 -> . operand3
    (85) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (86) operand3 -> . monadic_operator operand4
    (87) operand3 -> . operand4
    (94) monadic_operator -> . MINUS
    (95) monadic_operator -> . NOT
    (88) operand4 -> . array_location
    (89) operand4 -> . referenced_location
    (90) operand4 -> . primitive_value
    (71) array_location -> . location
    (96) referenced_location -> . ARROW array_location
    (113) primitive_value -> . literal
    (55) location -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (114) literal -> . integer_literal
    (115) literal -> . boolean_literal
    (116) literal -> . character_literal
    (117) literal -> . empty_literal
    (118) literal -> . character_string_literal
    (21) identifier -> . ID
    (61) dereferenced_reference -> . array_location ARROW
    (62) string_element -> . identifier LBRACKET start_element LBRACKET
    (64) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (67) array_element -> . array_location LBRACKET expression_list RBRACKET
    (70) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (119) integer_literal -> . ICONST
    (120) boolean_literal -> . TRUE
    (121) boolean_literal -> . FALSE
    (122) character_literal -> . CCONST
    (123) empty_literal -> . NULL
    (124) character_string_literal -> . SCONST

    IF              shift and go to state 96
    MINUS           shift and go to state 91
    NOT             shift and go to state 89
    ARROW           shift and go to state 82
    ID              shift and go to state 11
    ICONST          shift and go to state 93
    TRUE            shift and go to state 77
    FALSE           shift and go to state 66
    CCONST          shift and go to state 76
    NULL            shift and go to state 84
    SCONST          shift and go to state 74

    operand3                       shift and go to state 83
    string_element                 shift and go to state 67
    expression                     shift and go to state 102
    identifier                     shift and go to state 85
    primitive_value                shift and go to state 86
    lower_bound                    shift and go to state 104
    operand1                       shift and go to state 69
    operand2                       shift and go to state 87
    conditional_expression         shift and go to state 88
    literal                        shift and go to state 70
    location                       shift and go to state 90
    referenced_location            shift and go to state 71
    character_string_literal       shift and go to state 72
    empty_literal                  shift and go to state 75
    array_slice                    shift and go to state 95
    character_literal              shift and go to state 94
    boolean_literal                shift and go to state 97
    monadic_operator               shift and go to state 73
    literal_range                  shift and go to state 103
    array_location                 shift and go to state 78
    operand0                       shift and go to state 98
    operand4                       shift and go to state 79
    integer_literal                shift and go to state 80
    dereferenced_reference         shift and go to state 92
    array_element                  shift and go to state 99
    string_slice                   shift and go to state 81

state 60

    (47) string_mode -> CHARS LBRACKET . string_length RBRACKET
    (48) string_length -> . integer_literal
    (119) integer_literal -> . ICONST

    ICONST          shift and go to state 93

    string_length                  shift and go to state 105
    integer_literal                shift and go to state 106

state 61

    (44) reference_mode -> REF mode .

    ASSIGN          reduce using rule 44 (reference_mode -> REF mode .)
    COMMA           reduce using rule 44 (reference_mode -> REF mode .)
    SEMI            reduce using rule 44 (reference_mode -> REF mode .)


state 62

    (49) array_mode -> ARRAY LBRACKET . index_mode_list RBRACKET element_mode
    (50) index_mode_list -> . index_mode
    (51) index_mode_list -> . index_mode COMMA index_mode_list
    (52) index_mode -> . discrete_mode
    (53) index_mode -> . literal_range
    (31) discrete_mode -> . integer_mode
    (32) discrete_mode -> . boolean_mode
    (33) discrete_mode -> . character_mode
    (34) discrete_mode -> . discrete_range_mode
    (41) literal_range -> . lower_bound COLON upper_bound
    (36) integer_mode -> . INT
    (37) boolean_mode -> . BOOL
    (38) character_mode -> . CHAR
    (39) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (40) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (42) lower_bound -> . expression
    (35) discrete_mode_name -> . identifier
    (72) expression -> . operand0
    (73) expression -> . conditional_expression
    (21) identifier -> . ID
    (80) operand0 -> . operand1
    (81) operand0 -> . operand0 operator1 operand1
    (74) conditional_expression -> . IF expression then_expression else_expression FI
    (75) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (82) operand1 -> . operand2
    (83) operand1 -> . operand1 operator2 operand2
    (84) operand2 -> . operand3
    (85) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (86) operand3 -> . monadic_operator operand4
    (87) operand3 -> . operand4
    (94) monadic_operator -> . MINUS
    (95) monadic_operator -> . NOT
    (88) operand4 -> . array_location
    (89) operand4 -> . referenced_location
    (90) operand4 -> . primitive_value
    (71) array_location -> . location
    (96) referenced_location -> . ARROW array_location
    (113) primitive_value -> . literal
    (55) location -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (114) literal -> . integer_literal
    (115) literal -> . boolean_literal
    (116) literal -> . character_literal
    (117) literal -> . empty_literal
    (118) literal -> . character_string_literal
    (61) dereferenced_reference -> . array_location ARROW
    (62) string_element -> . identifier LBRACKET start_element LBRACKET
    (64) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (67) array_element -> . array_location LBRACKET expression_list RBRACKET
    (70) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (119) integer_literal -> . ICONST
    (120) boolean_literal -> . TRUE
    (121) boolean_literal -> . FALSE
    (122) character_literal -> . CCONST
    (123) empty_literal -> . NULL
    (124) character_string_literal -> . SCONST

    INT             shift and go to state 36
    BOOL            shift and go to state 33
    CHAR            shift and go to state 42
    ID              shift and go to state 11
    IF              shift and go to state 96
    MINUS           shift and go to state 91
    NOT             shift and go to state 89
    ARROW           shift and go to state 82
    ICONST          shift and go to state 93
    TRUE            shift and go to state 77
    FALSE           shift and go to state 66
    CCONST          shift and go to state 76
    NULL            shift and go to state 84
    SCONST          shift and go to state 74

    string_element                 shift and go to state 67
    discrete_range_mode            shift and go to state 31
    index_mode_list                shift and go to state 107
    operand1                       shift and go to state 69
    literal                        shift and go to state 70
    discrete_mode                  shift and go to state 108
    referenced_location            shift and go to state 71
    character_string_literal       shift and go to state 72
    expression                     shift and go to state 102
    monadic_operator               shift and go to state 73
    empty_literal                  shift and go to state 75
    discrete_mode_name             shift and go to state 46
    index_mode                     shift and go to state 109
    literal_range                  shift and go to state 110
    integer_mode                   shift and go to state 40
    array_location                 shift and go to state 78
    operand4                       shift and go to state 79
    integer_literal                shift and go to state 80
    string_slice                   shift and go to state 81
    operand3                       shift and go to state 83
    identifier                     shift and go to state 111
    primitive_value                shift and go to state 86
    lower_bound                    shift and go to state 104
    operand2                       shift and go to state 87
    conditional_expression         shift and go to state 88
    location                       shift and go to state 90
    character_mode                 shift and go to state 37
    character_literal              shift and go to state 94
    dereferenced_reference         shift and go to state 92
    boolean_mode                   shift and go to state 44
    array_slice                    shift and go to state 95
    boolean_literal                shift and go to state 97
    operand0                       shift and go to state 98
    array_element                  shift and go to state 99

state 63

    (39) discrete_range_mode -> discrete_mode_name LPAREN . literal_range RPAREN
    (41) literal_range -> . lower_bound COLON upper_bound
    (42) lower_bound -> . expression
    (72) expression -> . operand0
    (73) expression -> . conditional_expression
    (80) operand0 -> . operand1
    (81) operand0 -> . operand0 operator1 operand1
    (74) conditional_expression -> . IF expression then_expression else_expression FI
    (75) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (82) operand1 -> . operand2
    (83) operand1 -> . operand1 operator2 operand2
    (84) operand2 -> . operand3
    (85) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (86) operand3 -> . monadic_operator operand4
    (87) operand3 -> . operand4
    (94) monadic_operator -> . MINUS
    (95) monadic_operator -> . NOT
    (88) operand4 -> . array_location
    (89) operand4 -> . referenced_location
    (90) operand4 -> . primitive_value
    (71) array_location -> . location
    (96) referenced_location -> . ARROW array_location
    (113) primitive_value -> . literal
    (55) location -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (114) literal -> . integer_literal
    (115) literal -> . boolean_literal
    (116) literal -> . character_literal
    (117) literal -> . empty_literal
    (118) literal -> . character_string_literal
    (21) identifier -> . ID
    (61) dereferenced_reference -> . array_location ARROW
    (62) string_element -> . identifier LBRACKET start_element LBRACKET
    (64) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (67) array_element -> . array_location LBRACKET expression_list RBRACKET
    (70) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (119) integer_literal -> . ICONST
    (120) boolean_literal -> . TRUE
    (121) boolean_literal -> . FALSE
    (122) character_literal -> . CCONST
    (123) empty_literal -> . NULL
    (124) character_string_literal -> . SCONST

    IF              shift and go to state 96
    MINUS           shift and go to state 91
    NOT             shift and go to state 89
    ARROW           shift and go to state 82
    ID              shift and go to state 11
    ICONST          shift and go to state 93
    TRUE            shift and go to state 77
    FALSE           shift and go to state 66
    CCONST          shift and go to state 76
    NULL            shift and go to state 84
    SCONST          shift and go to state 74

    operand3                       shift and go to state 83
    string_element                 shift and go to state 67
    expression                     shift and go to state 102
    identifier                     shift and go to state 85
    primitive_value                shift and go to state 86
    lower_bound                    shift and go to state 104
    operand1                       shift and go to state 69
    operand2                       shift and go to state 87
    conditional_expression         shift and go to state 88
    literal                        shift and go to state 70
    location                       shift and go to state 90
    referenced_location            shift and go to state 71
    character_string_literal       shift and go to state 72
    empty_literal                  shift and go to state 75
    array_slice                    shift and go to state 95
    character_literal              shift and go to state 94
    boolean_literal                shift and go to state 97
    monadic_operator               shift and go to state 73
    literal_range                  shift and go to state 112
    array_location                 shift and go to state 78
    operand0                       shift and go to state 98
    operand4                       shift and go to state 79
    integer_literal                shift and go to state 80
    dereferenced_reference         shift and go to state 92
    array_element                  shift and go to state 99
    string_slice                   shift and go to state 81

state 64

    (15) declaration_list -> declaration COMMA declaration_list .

    SEMI            reduce using rule 15 (declaration_list -> declaration COMMA declaration_list .)


state 65

    (11) synonym_definition -> identifier_list mode ASSIGN . expression
    (72) expression -> . operand0
    (73) expression -> . conditional_expression
    (80) operand0 -> . operand1
    (81) operand0 -> . operand0 operator1 operand1
    (74) conditional_expression -> . IF expression then_expression else_expression FI
    (75) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (82) operand1 -> . operand2
    (83) operand1 -> . operand1 operator2 operand2
    (84) operand2 -> . operand3
    (85) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (86) operand3 -> . monadic_operator operand4
    (87) operand3 -> . operand4
    (94) monadic_operator -> . MINUS
    (95) monadic_operator -> . NOT
    (88) operand4 -> . array_location
    (89) operand4 -> . referenced_location
    (90) operand4 -> . primitive_value
    (71) array_location -> . location
    (96) referenced_location -> . ARROW array_location
    (113) primitive_value -> . literal
    (55) location -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (114) literal -> . integer_literal
    (115) literal -> . boolean_literal
    (116) literal -> . character_literal
    (117) literal -> . empty_literal
    (118) literal -> . character_string_literal
    (21) identifier -> . ID
    (61) dereferenced_reference -> . array_location ARROW
    (62) string_element -> . identifier LBRACKET start_element LBRACKET
    (64) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (67) array_element -> . array_location LBRACKET expression_list RBRACKET
    (70) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (119) integer_literal -> . ICONST
    (120) boolean_literal -> . TRUE
    (121) boolean_literal -> . FALSE
    (122) character_literal -> . CCONST
    (123) empty_literal -> . NULL
    (124) character_string_literal -> . SCONST

    IF              shift and go to state 96
    MINUS           shift and go to state 91
    NOT             shift and go to state 89
    ARROW           shift and go to state 82
    ID              shift and go to state 11
    ICONST          shift and go to state 93
    TRUE            shift and go to state 77
    FALSE           shift and go to state 66
    CCONST          shift and go to state 76
    NULL            shift and go to state 84
    SCONST          shift and go to state 74

    operand3                       shift and go to state 83
    string_element                 shift and go to state 67
    expression                     shift and go to state 113
    identifier                     shift and go to state 85
    primitive_value                shift and go to state 86
    operand1                       shift and go to state 69
    operand2                       shift and go to state 87
    conditional_expression         shift and go to state 88
    literal                        shift and go to state 70
    location                       shift and go to state 90
    referenced_location            shift and go to state 71
    character_string_literal       shift and go to state 72
    empty_literal                  shift and go to state 75
    array_slice                    shift and go to state 95
    character_literal              shift and go to state 94
    boolean_literal                shift and go to state 97
    monadic_operator               shift and go to state 73
    array_location                 shift and go to state 78
    operand0                       shift and go to state 98
    operand4                       shift and go to state 79
    integer_literal                shift and go to state 80
    dereferenced_reference         shift and go to state 92
    array_element                  shift and go to state 99
    string_slice                   shift and go to state 81

state 66

    (121) boolean_literal -> FALSE .

    TIMES           reduce using rule 121 (boolean_literal -> FALSE .)
    DIVIDE          reduce using rule 121 (boolean_literal -> FALSE .)
    MODULO          reduce using rule 121 (boolean_literal -> FALSE .)
    PLUS            reduce using rule 121 (boolean_literal -> FALSE .)
    MINUS           reduce using rule 121 (boolean_literal -> FALSE .)
    CONCAT          reduce using rule 121 (boolean_literal -> FALSE .)
    AND             reduce using rule 121 (boolean_literal -> FALSE .)
    OR              reduce using rule 121 (boolean_literal -> FALSE .)
    EQUAL           reduce using rule 121 (boolean_literal -> FALSE .)
    NOTEQ           reduce using rule 121 (boolean_literal -> FALSE .)
    GREATER         reduce using rule 121 (boolean_literal -> FALSE .)
    GTEQUAL         reduce using rule 121 (boolean_literal -> FALSE .)
    LESS            reduce using rule 121 (boolean_literal -> FALSE .)
    LTEQUAL         reduce using rule 121 (boolean_literal -> FALSE .)
    IN              reduce using rule 121 (boolean_literal -> FALSE .)
    COLON           reduce using rule 121 (boolean_literal -> FALSE .)
    RBRACKET        reduce using rule 121 (boolean_literal -> FALSE .)
    ELSE            reduce using rule 121 (boolean_literal -> FALSE .)
    ELSIF           reduce using rule 121 (boolean_literal -> FALSE .)
    COMMA           reduce using rule 121 (boolean_literal -> FALSE .)
    SEMI            reduce using rule 121 (boolean_literal -> FALSE .)
    THEN            reduce using rule 121 (boolean_literal -> FALSE .)
    LBRACKET        reduce using rule 121 (boolean_literal -> FALSE .)
    FI              reduce using rule 121 (boolean_literal -> FALSE .)
    RPAREN          reduce using rule 121 (boolean_literal -> FALSE .)


state 67

    (57) location -> string_element .

    ARROW           reduce using rule 57 (location -> string_element .)
    LBRACKET        reduce using rule 57 (location -> string_element .)
    TIMES           reduce using rule 57 (location -> string_element .)
    DIVIDE          reduce using rule 57 (location -> string_element .)
    MODULO          reduce using rule 57 (location -> string_element .)
    PLUS            reduce using rule 57 (location -> string_element .)
    MINUS           reduce using rule 57 (location -> string_element .)
    CONCAT          reduce using rule 57 (location -> string_element .)
    AND             reduce using rule 57 (location -> string_element .)
    OR              reduce using rule 57 (location -> string_element .)
    EQUAL           reduce using rule 57 (location -> string_element .)
    NOTEQ           reduce using rule 57 (location -> string_element .)
    GREATER         reduce using rule 57 (location -> string_element .)
    GTEQUAL         reduce using rule 57 (location -> string_element .)
    LESS            reduce using rule 57 (location -> string_element .)
    LTEQUAL         reduce using rule 57 (location -> string_element .)
    IN              reduce using rule 57 (location -> string_element .)
    RBRACKET        reduce using rule 57 (location -> string_element .)
    COLON           reduce using rule 57 (location -> string_element .)
    COMMA           reduce using rule 57 (location -> string_element .)
    SEMI            reduce using rule 57 (location -> string_element .)
    THEN            reduce using rule 57 (location -> string_element .)
    RPAREN          reduce using rule 57 (location -> string_element .)
    ELSE            reduce using rule 57 (location -> string_element .)
    ELSIF           reduce using rule 57 (location -> string_element .)
    FI              reduce using rule 57 (location -> string_element .)


state 68

    (12) synonym_definition -> identifier_list ASSIGN expression .

    COMMA           reduce using rule 12 (synonym_definition -> identifier_list ASSIGN expression .)
    SEMI            reduce using rule 12 (synonym_definition -> identifier_list ASSIGN expression .)


state 69

    (80) operand0 -> operand1 .
    (83) operand1 -> operand1 . operator2 operand2
    (99) operator2 -> . arithmetic_additive_operator
    (100) operator2 -> . string_concatenation_operator
    (101) arithmetic_additive_operator -> . PLUS
    (102) arithmetic_additive_operator -> . MINUS
    (103) string_concatenation_operator -> . CONCAT

    AND             reduce using rule 80 (operand0 -> operand1 .)
    OR              reduce using rule 80 (operand0 -> operand1 .)
    EQUAL           reduce using rule 80 (operand0 -> operand1 .)
    NOTEQ           reduce using rule 80 (operand0 -> operand1 .)
    GREATER         reduce using rule 80 (operand0 -> operand1 .)
    GTEQUAL         reduce using rule 80 (operand0 -> operand1 .)
    LESS            reduce using rule 80 (operand0 -> operand1 .)
    LTEQUAL         reduce using rule 80 (operand0 -> operand1 .)
    IN              reduce using rule 80 (operand0 -> operand1 .)
    RBRACKET        reduce using rule 80 (operand0 -> operand1 .)
    COLON           reduce using rule 80 (operand0 -> operand1 .)
    COMMA           reduce using rule 80 (operand0 -> operand1 .)
    SEMI            reduce using rule 80 (operand0 -> operand1 .)
    FI              reduce using rule 80 (operand0 -> operand1 .)
    RPAREN          reduce using rule 80 (operand0 -> operand1 .)
    THEN            reduce using rule 80 (operand0 -> operand1 .)
    ELSE            reduce using rule 80 (operand0 -> operand1 .)
    ELSIF           reduce using rule 80 (operand0 -> operand1 .)
    LBRACKET        reduce using rule 80 (operand0 -> operand1 .)
    PLUS            shift and go to state 114
    MINUS           shift and go to state 116
    CONCAT          shift and go to state 117

    operator2                      shift and go to state 118
    string_concatenation_operator  shift and go to state 115
    arithmetic_additive_operator   shift and go to state 119

state 70

    (113) primitive_value -> literal .

    TIMES           reduce using rule 113 (primitive_value -> literal .)
    DIVIDE          reduce using rule 113 (primitive_value -> literal .)
    MODULO          reduce using rule 113 (primitive_value -> literal .)
    PLUS            reduce using rule 113 (primitive_value -> literal .)
    MINUS           reduce using rule 113 (primitive_value -> literal .)
    CONCAT          reduce using rule 113 (primitive_value -> literal .)
    AND             reduce using rule 113 (primitive_value -> literal .)
    OR              reduce using rule 113 (primitive_value -> literal .)
    EQUAL           reduce using rule 113 (primitive_value -> literal .)
    NOTEQ           reduce using rule 113 (primitive_value -> literal .)
    GREATER         reduce using rule 113 (primitive_value -> literal .)
    GTEQUAL         reduce using rule 113 (primitive_value -> literal .)
    LESS            reduce using rule 113 (primitive_value -> literal .)
    LTEQUAL         reduce using rule 113 (primitive_value -> literal .)
    IN              reduce using rule 113 (primitive_value -> literal .)
    THEN            reduce using rule 113 (primitive_value -> literal .)
    COMMA           reduce using rule 113 (primitive_value -> literal .)
    SEMI            reduce using rule 113 (primitive_value -> literal .)
    COLON           reduce using rule 113 (primitive_value -> literal .)
    RBRACKET        reduce using rule 113 (primitive_value -> literal .)
    LBRACKET        reduce using rule 113 (primitive_value -> literal .)
    RPAREN          reduce using rule 113 (primitive_value -> literal .)
    ELSE            reduce using rule 113 (primitive_value -> literal .)
    ELSIF           reduce using rule 113 (primitive_value -> literal .)
    FI              reduce using rule 113 (primitive_value -> literal .)


state 71

    (89) operand4 -> referenced_location .

    TIMES           reduce using rule 89 (operand4 -> referenced_location .)
    DIVIDE          reduce using rule 89 (operand4 -> referenced_location .)
    MODULO          reduce using rule 89 (operand4 -> referenced_location .)
    PLUS            reduce using rule 89 (operand4 -> referenced_location .)
    MINUS           reduce using rule 89 (operand4 -> referenced_location .)
    CONCAT          reduce using rule 89 (operand4 -> referenced_location .)
    AND             reduce using rule 89 (operand4 -> referenced_location .)
    OR              reduce using rule 89 (operand4 -> referenced_location .)
    EQUAL           reduce using rule 89 (operand4 -> referenced_location .)
    NOTEQ           reduce using rule 89 (operand4 -> referenced_location .)
    GREATER         reduce using rule 89 (operand4 -> referenced_location .)
    GTEQUAL         reduce using rule 89 (operand4 -> referenced_location .)
    LESS            reduce using rule 89 (operand4 -> referenced_location .)
    LTEQUAL         reduce using rule 89 (operand4 -> referenced_location .)
    IN              reduce using rule 89 (operand4 -> referenced_location .)
    COLON           reduce using rule 89 (operand4 -> referenced_location .)
    COMMA           reduce using rule 89 (operand4 -> referenced_location .)
    SEMI            reduce using rule 89 (operand4 -> referenced_location .)
    THEN            reduce using rule 89 (operand4 -> referenced_location .)
    RBRACKET        reduce using rule 89 (operand4 -> referenced_location .)
    LBRACKET        reduce using rule 89 (operand4 -> referenced_location .)
    RPAREN          reduce using rule 89 (operand4 -> referenced_location .)
    ELSE            reduce using rule 89 (operand4 -> referenced_location .)
    ELSIF           reduce using rule 89 (operand4 -> referenced_location .)
    FI              reduce using rule 89 (operand4 -> referenced_location .)


state 72

    (118) literal -> character_string_literal .

    TIMES           reduce using rule 118 (literal -> character_string_literal .)
    DIVIDE          reduce using rule 118 (literal -> character_string_literal .)
    MODULO          reduce using rule 118 (literal -> character_string_literal .)
    PLUS            reduce using rule 118 (literal -> character_string_literal .)
    MINUS           reduce using rule 118 (literal -> character_string_literal .)
    CONCAT          reduce using rule 118 (literal -> character_string_literal .)
    AND             reduce using rule 118 (literal -> character_string_literal .)
    OR              reduce using rule 118 (literal -> character_string_literal .)
    EQUAL           reduce using rule 118 (literal -> character_string_literal .)
    NOTEQ           reduce using rule 118 (literal -> character_string_literal .)
    GREATER         reduce using rule 118 (literal -> character_string_literal .)
    GTEQUAL         reduce using rule 118 (literal -> character_string_literal .)
    LESS            reduce using rule 118 (literal -> character_string_literal .)
    LTEQUAL         reduce using rule 118 (literal -> character_string_literal .)
    IN              reduce using rule 118 (literal -> character_string_literal .)
    THEN            reduce using rule 118 (literal -> character_string_literal .)
    COLON           reduce using rule 118 (literal -> character_string_literal .)
    COMMA           reduce using rule 118 (literal -> character_string_literal .)
    SEMI            reduce using rule 118 (literal -> character_string_literal .)
    RBRACKET        reduce using rule 118 (literal -> character_string_literal .)
    LBRACKET        reduce using rule 118 (literal -> character_string_literal .)
    RPAREN          reduce using rule 118 (literal -> character_string_literal .)
    ELSE            reduce using rule 118 (literal -> character_string_literal .)
    ELSIF           reduce using rule 118 (literal -> character_string_literal .)
    FI              reduce using rule 118 (literal -> character_string_literal .)


state 73

    (86) operand3 -> monadic_operator . operand4
    (88) operand4 -> . array_location
    (89) operand4 -> . referenced_location
    (90) operand4 -> . primitive_value
    (71) array_location -> . location
    (96) referenced_location -> . ARROW array_location
    (113) primitive_value -> . literal
    (55) location -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (114) literal -> . integer_literal
    (115) literal -> . boolean_literal
    (116) literal -> . character_literal
    (117) literal -> . empty_literal
    (118) literal -> . character_string_literal
    (21) identifier -> . ID
    (61) dereferenced_reference -> . array_location ARROW
    (62) string_element -> . identifier LBRACKET start_element LBRACKET
    (64) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (67) array_element -> . array_location LBRACKET expression_list RBRACKET
    (70) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (119) integer_literal -> . ICONST
    (120) boolean_literal -> . TRUE
    (121) boolean_literal -> . FALSE
    (122) character_literal -> . CCONST
    (123) empty_literal -> . NULL
    (124) character_string_literal -> . SCONST

    ARROW           shift and go to state 82
    ID              shift and go to state 11
    ICONST          shift and go to state 93
    TRUE            shift and go to state 77
    FALSE           shift and go to state 66
    CCONST          shift and go to state 76
    NULL            shift and go to state 84
    SCONST          shift and go to state 74

    string_element                 shift and go to state 67
    identifier                     shift and go to state 85
    primitive_value                shift and go to state 86
    literal                        shift and go to state 70
    location                       shift and go to state 90
    referenced_location            shift and go to state 71
    character_string_literal       shift and go to state 72
    dereferenced_reference         shift and go to state 92
    character_literal              shift and go to state 94
    array_slice                    shift and go to state 95
    empty_literal                  shift and go to state 75
    boolean_literal                shift and go to state 97
    array_location                 shift and go to state 78
    operand4                       shift and go to state 120
    integer_literal                shift and go to state 80
    array_element                  shift and go to state 99
    string_slice                   shift and go to state 81

state 74

    (124) character_string_literal -> SCONST .

    TIMES           reduce using rule 124 (character_string_literal -> SCONST .)
    DIVIDE          reduce using rule 124 (character_string_literal -> SCONST .)
    MODULO          reduce using rule 124 (character_string_literal -> SCONST .)
    PLUS            reduce using rule 124 (character_string_literal -> SCONST .)
    MINUS           reduce using rule 124 (character_string_literal -> SCONST .)
    CONCAT          reduce using rule 124 (character_string_literal -> SCONST .)
    AND             reduce using rule 124 (character_string_literal -> SCONST .)
    OR              reduce using rule 124 (character_string_literal -> SCONST .)
    EQUAL           reduce using rule 124 (character_string_literal -> SCONST .)
    NOTEQ           reduce using rule 124 (character_string_literal -> SCONST .)
    GREATER         reduce using rule 124 (character_string_literal -> SCONST .)
    GTEQUAL         reduce using rule 124 (character_string_literal -> SCONST .)
    LESS            reduce using rule 124 (character_string_literal -> SCONST .)
    LTEQUAL         reduce using rule 124 (character_string_literal -> SCONST .)
    IN              reduce using rule 124 (character_string_literal -> SCONST .)
    COMMA           reduce using rule 124 (character_string_literal -> SCONST .)
    SEMI            reduce using rule 124 (character_string_literal -> SCONST .)
    ELSE            reduce using rule 124 (character_string_literal -> SCONST .)
    ELSIF           reduce using rule 124 (character_string_literal -> SCONST .)
    COLON           reduce using rule 124 (character_string_literal -> SCONST .)
    THEN            reduce using rule 124 (character_string_literal -> SCONST .)
    RBRACKET        reduce using rule 124 (character_string_literal -> SCONST .)
    LBRACKET        reduce using rule 124 (character_string_literal -> SCONST .)
    RPAREN          reduce using rule 124 (character_string_literal -> SCONST .)
    FI              reduce using rule 124 (character_string_literal -> SCONST .)


state 75

    (117) literal -> empty_literal .

    TIMES           reduce using rule 117 (literal -> empty_literal .)
    DIVIDE          reduce using rule 117 (literal -> empty_literal .)
    MODULO          reduce using rule 117 (literal -> empty_literal .)
    PLUS            reduce using rule 117 (literal -> empty_literal .)
    MINUS           reduce using rule 117 (literal -> empty_literal .)
    CONCAT          reduce using rule 117 (literal -> empty_literal .)
    AND             reduce using rule 117 (literal -> empty_literal .)
    OR              reduce using rule 117 (literal -> empty_literal .)
    EQUAL           reduce using rule 117 (literal -> empty_literal .)
    NOTEQ           reduce using rule 117 (literal -> empty_literal .)
    GREATER         reduce using rule 117 (literal -> empty_literal .)
    GTEQUAL         reduce using rule 117 (literal -> empty_literal .)
    LESS            reduce using rule 117 (literal -> empty_literal .)
    LTEQUAL         reduce using rule 117 (literal -> empty_literal .)
    IN              reduce using rule 117 (literal -> empty_literal .)
    THEN            reduce using rule 117 (literal -> empty_literal .)
    COLON           reduce using rule 117 (literal -> empty_literal .)
    COMMA           reduce using rule 117 (literal -> empty_literal .)
    SEMI            reduce using rule 117 (literal -> empty_literal .)
    RBRACKET        reduce using rule 117 (literal -> empty_literal .)
    LBRACKET        reduce using rule 117 (literal -> empty_literal .)
    RPAREN          reduce using rule 117 (literal -> empty_literal .)
    ELSE            reduce using rule 117 (literal -> empty_literal .)
    ELSIF           reduce using rule 117 (literal -> empty_literal .)
    FI              reduce using rule 117 (literal -> empty_literal .)


state 76

    (122) character_literal -> CCONST .

    TIMES           reduce using rule 122 (character_literal -> CCONST .)
    DIVIDE          reduce using rule 122 (character_literal -> CCONST .)
    MODULO          reduce using rule 122 (character_literal -> CCONST .)
    PLUS            reduce using rule 122 (character_literal -> CCONST .)
    MINUS           reduce using rule 122 (character_literal -> CCONST .)
    CONCAT          reduce using rule 122 (character_literal -> CCONST .)
    AND             reduce using rule 122 (character_literal -> CCONST .)
    OR              reduce using rule 122 (character_literal -> CCONST .)
    EQUAL           reduce using rule 122 (character_literal -> CCONST .)
    NOTEQ           reduce using rule 122 (character_literal -> CCONST .)
    GREATER         reduce using rule 122 (character_literal -> CCONST .)
    GTEQUAL         reduce using rule 122 (character_literal -> CCONST .)
    LESS            reduce using rule 122 (character_literal -> CCONST .)
    LTEQUAL         reduce using rule 122 (character_literal -> CCONST .)
    IN              reduce using rule 122 (character_literal -> CCONST .)
    COMMA           reduce using rule 122 (character_literal -> CCONST .)
    SEMI            reduce using rule 122 (character_literal -> CCONST .)
    COLON           reduce using rule 122 (character_literal -> CCONST .)
    THEN            reduce using rule 122 (character_literal -> CCONST .)
    RBRACKET        reduce using rule 122 (character_literal -> CCONST .)
    LBRACKET        reduce using rule 122 (character_literal -> CCONST .)
    RPAREN          reduce using rule 122 (character_literal -> CCONST .)
    ELSE            reduce using rule 122 (character_literal -> CCONST .)
    ELSIF           reduce using rule 122 (character_literal -> CCONST .)
    FI              reduce using rule 122 (character_literal -> CCONST .)


state 77

    (120) boolean_literal -> TRUE .

    TIMES           reduce using rule 120 (boolean_literal -> TRUE .)
    DIVIDE          reduce using rule 120 (boolean_literal -> TRUE .)
    MODULO          reduce using rule 120 (boolean_literal -> TRUE .)
    PLUS            reduce using rule 120 (boolean_literal -> TRUE .)
    MINUS           reduce using rule 120 (boolean_literal -> TRUE .)
    CONCAT          reduce using rule 120 (boolean_literal -> TRUE .)
    AND             reduce using rule 120 (boolean_literal -> TRUE .)
    OR              reduce using rule 120 (boolean_literal -> TRUE .)
    EQUAL           reduce using rule 120 (boolean_literal -> TRUE .)
    NOTEQ           reduce using rule 120 (boolean_literal -> TRUE .)
    GREATER         reduce using rule 120 (boolean_literal -> TRUE .)
    GTEQUAL         reduce using rule 120 (boolean_literal -> TRUE .)
    LESS            reduce using rule 120 (boolean_literal -> TRUE .)
    LTEQUAL         reduce using rule 120 (boolean_literal -> TRUE .)
    IN              reduce using rule 120 (boolean_literal -> TRUE .)
    COLON           reduce using rule 120 (boolean_literal -> TRUE .)
    RBRACKET        reduce using rule 120 (boolean_literal -> TRUE .)
    ELSE            reduce using rule 120 (boolean_literal -> TRUE .)
    ELSIF           reduce using rule 120 (boolean_literal -> TRUE .)
    COMMA           reduce using rule 120 (boolean_literal -> TRUE .)
    SEMI            reduce using rule 120 (boolean_literal -> TRUE .)
    THEN            reduce using rule 120 (boolean_literal -> TRUE .)
    LBRACKET        reduce using rule 120 (boolean_literal -> TRUE .)
    FI              reduce using rule 120 (boolean_literal -> TRUE .)
    RPAREN          reduce using rule 120 (boolean_literal -> TRUE .)


state 78

    (88) operand4 -> array_location .
    (61) dereferenced_reference -> array_location . ARROW
    (67) array_element -> array_location . LBRACKET expression_list RBRACKET
    (70) array_slice -> array_location . LBRACKET lower_bound COLON upper_bound RBRACKET

  ! shift/reduce conflict for LBRACKET resolved as shift
    TIMES           reduce using rule 88 (operand4 -> array_location .)
    DIVIDE          reduce using rule 88 (operand4 -> array_location .)
    MODULO          reduce using rule 88 (operand4 -> array_location .)
    PLUS            reduce using rule 88 (operand4 -> array_location .)
    MINUS           reduce using rule 88 (operand4 -> array_location .)
    CONCAT          reduce using rule 88 (operand4 -> array_location .)
    AND             reduce using rule 88 (operand4 -> array_location .)
    OR              reduce using rule 88 (operand4 -> array_location .)
    EQUAL           reduce using rule 88 (operand4 -> array_location .)
    NOTEQ           reduce using rule 88 (operand4 -> array_location .)
    GREATER         reduce using rule 88 (operand4 -> array_location .)
    GTEQUAL         reduce using rule 88 (operand4 -> array_location .)
    LESS            reduce using rule 88 (operand4 -> array_location .)
    LTEQUAL         reduce using rule 88 (operand4 -> array_location .)
    IN              reduce using rule 88 (operand4 -> array_location .)
    COLON           reduce using rule 88 (operand4 -> array_location .)
    COMMA           reduce using rule 88 (operand4 -> array_location .)
    SEMI            reduce using rule 88 (operand4 -> array_location .)
    THEN            reduce using rule 88 (operand4 -> array_location .)
    RBRACKET        reduce using rule 88 (operand4 -> array_location .)
    RPAREN          reduce using rule 88 (operand4 -> array_location .)
    ELSE            reduce using rule 88 (operand4 -> array_location .)
    ELSIF           reduce using rule 88 (operand4 -> array_location .)
    FI              reduce using rule 88 (operand4 -> array_location .)
    ARROW           shift and go to state 121
    LBRACKET        shift and go to state 122

  ! LBRACKET        [ reduce using rule 88 (operand4 -> array_location .) ]


state 79

    (87) operand3 -> operand4 .

    TIMES           reduce using rule 87 (operand3 -> operand4 .)
    DIVIDE          reduce using rule 87 (operand3 -> operand4 .)
    MODULO          reduce using rule 87 (operand3 -> operand4 .)
    PLUS            reduce using rule 87 (operand3 -> operand4 .)
    MINUS           reduce using rule 87 (operand3 -> operand4 .)
    CONCAT          reduce using rule 87 (operand3 -> operand4 .)
    AND             reduce using rule 87 (operand3 -> operand4 .)
    OR              reduce using rule 87 (operand3 -> operand4 .)
    EQUAL           reduce using rule 87 (operand3 -> operand4 .)
    NOTEQ           reduce using rule 87 (operand3 -> operand4 .)
    GREATER         reduce using rule 87 (operand3 -> operand4 .)
    GTEQUAL         reduce using rule 87 (operand3 -> operand4 .)
    LESS            reduce using rule 87 (operand3 -> operand4 .)
    LTEQUAL         reduce using rule 87 (operand3 -> operand4 .)
    IN              reduce using rule 87 (operand3 -> operand4 .)
    THEN            reduce using rule 87 (operand3 -> operand4 .)
    RPAREN          reduce using rule 87 (operand3 -> operand4 .)
    COMMA           reduce using rule 87 (operand3 -> operand4 .)
    RBRACKET        reduce using rule 87 (operand3 -> operand4 .)
    LBRACKET        reduce using rule 87 (operand3 -> operand4 .)
    COLON           reduce using rule 87 (operand3 -> operand4 .)
    ELSE            reduce using rule 87 (operand3 -> operand4 .)
    ELSIF           reduce using rule 87 (operand3 -> operand4 .)
    SEMI            reduce using rule 87 (operand3 -> operand4 .)
    FI              reduce using rule 87 (operand3 -> operand4 .)


state 80

    (114) literal -> integer_literal .

    TIMES           reduce using rule 114 (literal -> integer_literal .)
    DIVIDE          reduce using rule 114 (literal -> integer_literal .)
    MODULO          reduce using rule 114 (literal -> integer_literal .)
    PLUS            reduce using rule 114 (literal -> integer_literal .)
    MINUS           reduce using rule 114 (literal -> integer_literal .)
    CONCAT          reduce using rule 114 (literal -> integer_literal .)
    AND             reduce using rule 114 (literal -> integer_literal .)
    OR              reduce using rule 114 (literal -> integer_literal .)
    EQUAL           reduce using rule 114 (literal -> integer_literal .)
    NOTEQ           reduce using rule 114 (literal -> integer_literal .)
    GREATER         reduce using rule 114 (literal -> integer_literal .)
    GTEQUAL         reduce using rule 114 (literal -> integer_literal .)
    LESS            reduce using rule 114 (literal -> integer_literal .)
    LTEQUAL         reduce using rule 114 (literal -> integer_literal .)
    IN              reduce using rule 114 (literal -> integer_literal .)
    THEN            reduce using rule 114 (literal -> integer_literal .)
    COLON           reduce using rule 114 (literal -> integer_literal .)
    COMMA           reduce using rule 114 (literal -> integer_literal .)
    SEMI            reduce using rule 114 (literal -> integer_literal .)
    RBRACKET        reduce using rule 114 (literal -> integer_literal .)
    LBRACKET        reduce using rule 114 (literal -> integer_literal .)
    RPAREN          reduce using rule 114 (literal -> integer_literal .)
    ELSE            reduce using rule 114 (literal -> integer_literal .)
    ELSIF           reduce using rule 114 (literal -> integer_literal .)
    FI              reduce using rule 114 (literal -> integer_literal .)


state 81

    (58) location -> string_slice .

    ARROW           reduce using rule 58 (location -> string_slice .)
    LBRACKET        reduce using rule 58 (location -> string_slice .)
    TIMES           reduce using rule 58 (location -> string_slice .)
    DIVIDE          reduce using rule 58 (location -> string_slice .)
    MODULO          reduce using rule 58 (location -> string_slice .)
    PLUS            reduce using rule 58 (location -> string_slice .)
    MINUS           reduce using rule 58 (location -> string_slice .)
    CONCAT          reduce using rule 58 (location -> string_slice .)
    AND             reduce using rule 58 (location -> string_slice .)
    OR              reduce using rule 58 (location -> string_slice .)
    EQUAL           reduce using rule 58 (location -> string_slice .)
    NOTEQ           reduce using rule 58 (location -> string_slice .)
    GREATER         reduce using rule 58 (location -> string_slice .)
    GTEQUAL         reduce using rule 58 (location -> string_slice .)
    LESS            reduce using rule 58 (location -> string_slice .)
    LTEQUAL         reduce using rule 58 (location -> string_slice .)
    IN              reduce using rule 58 (location -> string_slice .)
    RBRACKET        reduce using rule 58 (location -> string_slice .)
    COLON           reduce using rule 58 (location -> string_slice .)
    COMMA           reduce using rule 58 (location -> string_slice .)
    SEMI            reduce using rule 58 (location -> string_slice .)
    THEN            reduce using rule 58 (location -> string_slice .)
    RPAREN          reduce using rule 58 (location -> string_slice .)
    ELSE            reduce using rule 58 (location -> string_slice .)
    ELSIF           reduce using rule 58 (location -> string_slice .)
    FI              reduce using rule 58 (location -> string_slice .)


state 82

    (96) referenced_location -> ARROW . array_location
    (71) array_location -> . location
    (55) location -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (21) identifier -> . ID
    (61) dereferenced_reference -> . array_location ARROW
    (62) string_element -> . identifier LBRACKET start_element LBRACKET
    (64) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (67) array_element -> . array_location LBRACKET expression_list RBRACKET
    (70) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET

    ID              shift and go to state 11

    string_element                 shift and go to state 67
    identifier                     shift and go to state 85
    array_slice                    shift and go to state 95
    location                       shift and go to state 90
    array_location                 shift and go to state 123
    dereferenced_reference         shift and go to state 92
    array_element                  shift and go to state 99
    string_slice                   shift and go to state 81

state 83

    (84) operand2 -> operand3 .

    TIMES           reduce using rule 84 (operand2 -> operand3 .)
    DIVIDE          reduce using rule 84 (operand2 -> operand3 .)
    MODULO          reduce using rule 84 (operand2 -> operand3 .)
    PLUS            reduce using rule 84 (operand2 -> operand3 .)
    MINUS           reduce using rule 84 (operand2 -> operand3 .)
    CONCAT          reduce using rule 84 (operand2 -> operand3 .)
    AND             reduce using rule 84 (operand2 -> operand3 .)
    OR              reduce using rule 84 (operand2 -> operand3 .)
    EQUAL           reduce using rule 84 (operand2 -> operand3 .)
    NOTEQ           reduce using rule 84 (operand2 -> operand3 .)
    GREATER         reduce using rule 84 (operand2 -> operand3 .)
    GTEQUAL         reduce using rule 84 (operand2 -> operand3 .)
    LESS            reduce using rule 84 (operand2 -> operand3 .)
    LTEQUAL         reduce using rule 84 (operand2 -> operand3 .)
    IN              reduce using rule 84 (operand2 -> operand3 .)
    FI              reduce using rule 84 (operand2 -> operand3 .)
    COMMA           reduce using rule 84 (operand2 -> operand3 .)
    SEMI            reduce using rule 84 (operand2 -> operand3 .)
    COLON           reduce using rule 84 (operand2 -> operand3 .)
    RBRACKET        reduce using rule 84 (operand2 -> operand3 .)
    THEN            reduce using rule 84 (operand2 -> operand3 .)
    RPAREN          reduce using rule 84 (operand2 -> operand3 .)
    LBRACKET        reduce using rule 84 (operand2 -> operand3 .)
    ELSE            reduce using rule 84 (operand2 -> operand3 .)
    ELSIF           reduce using rule 84 (operand2 -> operand3 .)


state 84

    (123) empty_literal -> NULL .

    TIMES           reduce using rule 123 (empty_literal -> NULL .)
    DIVIDE          reduce using rule 123 (empty_literal -> NULL .)
    MODULO          reduce using rule 123 (empty_literal -> NULL .)
    PLUS            reduce using rule 123 (empty_literal -> NULL .)
    MINUS           reduce using rule 123 (empty_literal -> NULL .)
    CONCAT          reduce using rule 123 (empty_literal -> NULL .)
    AND             reduce using rule 123 (empty_literal -> NULL .)
    OR              reduce using rule 123 (empty_literal -> NULL .)
    EQUAL           reduce using rule 123 (empty_literal -> NULL .)
    NOTEQ           reduce using rule 123 (empty_literal -> NULL .)
    GREATER         reduce using rule 123 (empty_literal -> NULL .)
    GTEQUAL         reduce using rule 123 (empty_literal -> NULL .)
    LESS            reduce using rule 123 (empty_literal -> NULL .)
    LTEQUAL         reduce using rule 123 (empty_literal -> NULL .)
    IN              reduce using rule 123 (empty_literal -> NULL .)
    COMMA           reduce using rule 123 (empty_literal -> NULL .)
    SEMI            reduce using rule 123 (empty_literal -> NULL .)
    COLON           reduce using rule 123 (empty_literal -> NULL .)
    THEN            reduce using rule 123 (empty_literal -> NULL .)
    RBRACKET        reduce using rule 123 (empty_literal -> NULL .)
    LBRACKET        reduce using rule 123 (empty_literal -> NULL .)
    RPAREN          reduce using rule 123 (empty_literal -> NULL .)
    ELSE            reduce using rule 123 (empty_literal -> NULL .)
    ELSIF           reduce using rule 123 (empty_literal -> NULL .)
    FI              reduce using rule 123 (empty_literal -> NULL .)


state 85

    (55) location -> identifier .
    (62) string_element -> identifier . LBRACKET start_element LBRACKET
    (64) string_slice -> identifier . LBRACKET left_element COLON right_element RBRACKET

  ! shift/reduce conflict for LBRACKET resolved as shift
    ARROW           reduce using rule 55 (location -> identifier .)
    TIMES           reduce using rule 55 (location -> identifier .)
    DIVIDE          reduce using rule 55 (location -> identifier .)
    MODULO          reduce using rule 55 (location -> identifier .)
    PLUS            reduce using rule 55 (location -> identifier .)
    MINUS           reduce using rule 55 (location -> identifier .)
    CONCAT          reduce using rule 55 (location -> identifier .)
    AND             reduce using rule 55 (location -> identifier .)
    OR              reduce using rule 55 (location -> identifier .)
    EQUAL           reduce using rule 55 (location -> identifier .)
    NOTEQ           reduce using rule 55 (location -> identifier .)
    GREATER         reduce using rule 55 (location -> identifier .)
    GTEQUAL         reduce using rule 55 (location -> identifier .)
    LESS            reduce using rule 55 (location -> identifier .)
    LTEQUAL         reduce using rule 55 (location -> identifier .)
    IN              reduce using rule 55 (location -> identifier .)
    RBRACKET        reduce using rule 55 (location -> identifier .)
    COLON           reduce using rule 55 (location -> identifier .)
    COMMA           reduce using rule 55 (location -> identifier .)
    SEMI            reduce using rule 55 (location -> identifier .)
    THEN            reduce using rule 55 (location -> identifier .)
    RPAREN          reduce using rule 55 (location -> identifier .)
    ELSE            reduce using rule 55 (location -> identifier .)
    ELSIF           reduce using rule 55 (location -> identifier .)
    FI              reduce using rule 55 (location -> identifier .)
    LBRACKET        shift and go to state 124

  ! LBRACKET        [ reduce using rule 55 (location -> identifier .) ]


state 86

    (90) operand4 -> primitive_value .

    TIMES           reduce using rule 90 (operand4 -> primitive_value .)
    DIVIDE          reduce using rule 90 (operand4 -> primitive_value .)
    MODULO          reduce using rule 90 (operand4 -> primitive_value .)
    PLUS            reduce using rule 90 (operand4 -> primitive_value .)
    MINUS           reduce using rule 90 (operand4 -> primitive_value .)
    CONCAT          reduce using rule 90 (operand4 -> primitive_value .)
    AND             reduce using rule 90 (operand4 -> primitive_value .)
    OR              reduce using rule 90 (operand4 -> primitive_value .)
    EQUAL           reduce using rule 90 (operand4 -> primitive_value .)
    NOTEQ           reduce using rule 90 (operand4 -> primitive_value .)
    GREATER         reduce using rule 90 (operand4 -> primitive_value .)
    GTEQUAL         reduce using rule 90 (operand4 -> primitive_value .)
    LESS            reduce using rule 90 (operand4 -> primitive_value .)
    LTEQUAL         reduce using rule 90 (operand4 -> primitive_value .)
    IN              reduce using rule 90 (operand4 -> primitive_value .)
    COLON           reduce using rule 90 (operand4 -> primitive_value .)
    COMMA           reduce using rule 90 (operand4 -> primitive_value .)
    SEMI            reduce using rule 90 (operand4 -> primitive_value .)
    THEN            reduce using rule 90 (operand4 -> primitive_value .)
    RBRACKET        reduce using rule 90 (operand4 -> primitive_value .)
    LBRACKET        reduce using rule 90 (operand4 -> primitive_value .)
    RPAREN          reduce using rule 90 (operand4 -> primitive_value .)
    ELSE            reduce using rule 90 (operand4 -> primitive_value .)
    ELSIF           reduce using rule 90 (operand4 -> primitive_value .)
    FI              reduce using rule 90 (operand4 -> primitive_value .)


state 87

    (82) operand1 -> operand2 .
    (85) operand2 -> operand2 . arithmetic_multiplicative_operator operand3
    (91) arithmetic_multiplicative_operator -> . TIMES
    (92) arithmetic_multiplicative_operator -> . DIVIDE
    (93) arithmetic_multiplicative_operator -> . MODULO

    PLUS            reduce using rule 82 (operand1 -> operand2 .)
    MINUS           reduce using rule 82 (operand1 -> operand2 .)
    CONCAT          reduce using rule 82 (operand1 -> operand2 .)
    AND             reduce using rule 82 (operand1 -> operand2 .)
    OR              reduce using rule 82 (operand1 -> operand2 .)
    EQUAL           reduce using rule 82 (operand1 -> operand2 .)
    NOTEQ           reduce using rule 82 (operand1 -> operand2 .)
    GREATER         reduce using rule 82 (operand1 -> operand2 .)
    GTEQUAL         reduce using rule 82 (operand1 -> operand2 .)
    LESS            reduce using rule 82 (operand1 -> operand2 .)
    LTEQUAL         reduce using rule 82 (operand1 -> operand2 .)
    IN              reduce using rule 82 (operand1 -> operand2 .)
    THEN            reduce using rule 82 (operand1 -> operand2 .)
    COLON           reduce using rule 82 (operand1 -> operand2 .)
    RPAREN          reduce using rule 82 (operand1 -> operand2 .)
    COMMA           reduce using rule 82 (operand1 -> operand2 .)
    RBRACKET        reduce using rule 82 (operand1 -> operand2 .)
    SEMI            reduce using rule 82 (operand1 -> operand2 .)
    LBRACKET        reduce using rule 82 (operand1 -> operand2 .)
    ELSE            reduce using rule 82 (operand1 -> operand2 .)
    ELSIF           reduce using rule 82 (operand1 -> operand2 .)
    FI              reduce using rule 82 (operand1 -> operand2 .)
    TIMES           shift and go to state 128
    DIVIDE          shift and go to state 125
    MODULO          shift and go to state 127

    arithmetic_multiplicative_operator shift and go to state 126

state 88

    (73) expression -> conditional_expression .

    THEN            reduce using rule 73 (expression -> conditional_expression .)
    COLON           reduce using rule 73 (expression -> conditional_expression .)
    COMMA           reduce using rule 73 (expression -> conditional_expression .)
    SEMI            reduce using rule 73 (expression -> conditional_expression .)
    RBRACKET        reduce using rule 73 (expression -> conditional_expression .)
    RPAREN          reduce using rule 73 (expression -> conditional_expression .)
    ELSE            reduce using rule 73 (expression -> conditional_expression .)
    ELSIF           reduce using rule 73 (expression -> conditional_expression .)
    LBRACKET        reduce using rule 73 (expression -> conditional_expression .)
    FI              reduce using rule 73 (expression -> conditional_expression .)


state 89

    (95) monadic_operator -> NOT .

    ARROW           reduce using rule 95 (monadic_operator -> NOT .)
    ID              reduce using rule 95 (monadic_operator -> NOT .)
    ICONST          reduce using rule 95 (monadic_operator -> NOT .)
    TRUE            reduce using rule 95 (monadic_operator -> NOT .)
    FALSE           reduce using rule 95 (monadic_operator -> NOT .)
    CCONST          reduce using rule 95 (monadic_operator -> NOT .)
    NULL            reduce using rule 95 (monadic_operator -> NOT .)
    SCONST          reduce using rule 95 (monadic_operator -> NOT .)


state 90

    (71) array_location -> location .

    ARROW           reduce using rule 71 (array_location -> location .)
    LBRACKET        reduce using rule 71 (array_location -> location .)
    TIMES           reduce using rule 71 (array_location -> location .)
    DIVIDE          reduce using rule 71 (array_location -> location .)
    MODULO          reduce using rule 71 (array_location -> location .)
    PLUS            reduce using rule 71 (array_location -> location .)
    MINUS           reduce using rule 71 (array_location -> location .)
    CONCAT          reduce using rule 71 (array_location -> location .)
    AND             reduce using rule 71 (array_location -> location .)
    OR              reduce using rule 71 (array_location -> location .)
    EQUAL           reduce using rule 71 (array_location -> location .)
    NOTEQ           reduce using rule 71 (array_location -> location .)
    GREATER         reduce using rule 71 (array_location -> location .)
    GTEQUAL         reduce using rule 71 (array_location -> location .)
    LESS            reduce using rule 71 (array_location -> location .)
    LTEQUAL         reduce using rule 71 (array_location -> location .)
    IN              reduce using rule 71 (array_location -> location .)
    THEN            reduce using rule 71 (array_location -> location .)
    COLON           reduce using rule 71 (array_location -> location .)
    COMMA           reduce using rule 71 (array_location -> location .)
    SEMI            reduce using rule 71 (array_location -> location .)
    RBRACKET        reduce using rule 71 (array_location -> location .)
    RPAREN          reduce using rule 71 (array_location -> location .)
    ELSE            reduce using rule 71 (array_location -> location .)
    ELSIF           reduce using rule 71 (array_location -> location .)
    FI              reduce using rule 71 (array_location -> location .)


state 91

    (94) monadic_operator -> MINUS .

    ARROW           reduce using rule 94 (monadic_operator -> MINUS .)
    ID              reduce using rule 94 (monadic_operator -> MINUS .)
    ICONST          reduce using rule 94 (monadic_operator -> MINUS .)
    TRUE            reduce using rule 94 (monadic_operator -> MINUS .)
    FALSE           reduce using rule 94 (monadic_operator -> MINUS .)
    CCONST          reduce using rule 94 (monadic_operator -> MINUS .)
    NULL            reduce using rule 94 (monadic_operator -> MINUS .)
    SCONST          reduce using rule 94 (monadic_operator -> MINUS .)


state 92

    (56) location -> dereferenced_reference .

    ARROW           reduce using rule 56 (location -> dereferenced_reference .)
    LBRACKET        reduce using rule 56 (location -> dereferenced_reference .)
    TIMES           reduce using rule 56 (location -> dereferenced_reference .)
    DIVIDE          reduce using rule 56 (location -> dereferenced_reference .)
    MODULO          reduce using rule 56 (location -> dereferenced_reference .)
    PLUS            reduce using rule 56 (location -> dereferenced_reference .)
    MINUS           reduce using rule 56 (location -> dereferenced_reference .)
    CONCAT          reduce using rule 56 (location -> dereferenced_reference .)
    AND             reduce using rule 56 (location -> dereferenced_reference .)
    OR              reduce using rule 56 (location -> dereferenced_reference .)
    EQUAL           reduce using rule 56 (location -> dereferenced_reference .)
    NOTEQ           reduce using rule 56 (location -> dereferenced_reference .)
    GREATER         reduce using rule 56 (location -> dereferenced_reference .)
    GTEQUAL         reduce using rule 56 (location -> dereferenced_reference .)
    LESS            reduce using rule 56 (location -> dereferenced_reference .)
    LTEQUAL         reduce using rule 56 (location -> dereferenced_reference .)
    IN              reduce using rule 56 (location -> dereferenced_reference .)
    RBRACKET        reduce using rule 56 (location -> dereferenced_reference .)
    COLON           reduce using rule 56 (location -> dereferenced_reference .)
    COMMA           reduce using rule 56 (location -> dereferenced_reference .)
    SEMI            reduce using rule 56 (location -> dereferenced_reference .)
    THEN            reduce using rule 56 (location -> dereferenced_reference .)
    RPAREN          reduce using rule 56 (location -> dereferenced_reference .)
    ELSE            reduce using rule 56 (location -> dereferenced_reference .)
    ELSIF           reduce using rule 56 (location -> dereferenced_reference .)
    FI              reduce using rule 56 (location -> dereferenced_reference .)


state 93

    (119) integer_literal -> ICONST .

    TIMES           reduce using rule 119 (integer_literal -> ICONST .)
    DIVIDE          reduce using rule 119 (integer_literal -> ICONST .)
    MODULO          reduce using rule 119 (integer_literal -> ICONST .)
    PLUS            reduce using rule 119 (integer_literal -> ICONST .)
    MINUS           reduce using rule 119 (integer_literal -> ICONST .)
    CONCAT          reduce using rule 119 (integer_literal -> ICONST .)
    AND             reduce using rule 119 (integer_literal -> ICONST .)
    OR              reduce using rule 119 (integer_literal -> ICONST .)
    EQUAL           reduce using rule 119 (integer_literal -> ICONST .)
    NOTEQ           reduce using rule 119 (integer_literal -> ICONST .)
    GREATER         reduce using rule 119 (integer_literal -> ICONST .)
    GTEQUAL         reduce using rule 119 (integer_literal -> ICONST .)
    LESS            reduce using rule 119 (integer_literal -> ICONST .)
    LTEQUAL         reduce using rule 119 (integer_literal -> ICONST .)
    IN              reduce using rule 119 (integer_literal -> ICONST .)
    LBRACKET        reduce using rule 119 (integer_literal -> ICONST .)
    COLON           reduce using rule 119 (integer_literal -> ICONST .)
    RBRACKET        reduce using rule 119 (integer_literal -> ICONST .)
    THEN            reduce using rule 119 (integer_literal -> ICONST .)
    COMMA           reduce using rule 119 (integer_literal -> ICONST .)
    SEMI            reduce using rule 119 (integer_literal -> ICONST .)
    RPAREN          reduce using rule 119 (integer_literal -> ICONST .)
    ELSE            reduce using rule 119 (integer_literal -> ICONST .)
    ELSIF           reduce using rule 119 (integer_literal -> ICONST .)
    FI              reduce using rule 119 (integer_literal -> ICONST .)


state 94

    (116) literal -> character_literal .

    TIMES           reduce using rule 116 (literal -> character_literal .)
    DIVIDE          reduce using rule 116 (literal -> character_literal .)
    MODULO          reduce using rule 116 (literal -> character_literal .)
    PLUS            reduce using rule 116 (literal -> character_literal .)
    MINUS           reduce using rule 116 (literal -> character_literal .)
    CONCAT          reduce using rule 116 (literal -> character_literal .)
    AND             reduce using rule 116 (literal -> character_literal .)
    OR              reduce using rule 116 (literal -> character_literal .)
    EQUAL           reduce using rule 116 (literal -> character_literal .)
    NOTEQ           reduce using rule 116 (literal -> character_literal .)
    GREATER         reduce using rule 116 (literal -> character_literal .)
    GTEQUAL         reduce using rule 116 (literal -> character_literal .)
    LESS            reduce using rule 116 (literal -> character_literal .)
    LTEQUAL         reduce using rule 116 (literal -> character_literal .)
    IN              reduce using rule 116 (literal -> character_literal .)
    THEN            reduce using rule 116 (literal -> character_literal .)
    COLON           reduce using rule 116 (literal -> character_literal .)
    COMMA           reduce using rule 116 (literal -> character_literal .)
    SEMI            reduce using rule 116 (literal -> character_literal .)
    RBRACKET        reduce using rule 116 (literal -> character_literal .)
    LBRACKET        reduce using rule 116 (literal -> character_literal .)
    RPAREN          reduce using rule 116 (literal -> character_literal .)
    ELSE            reduce using rule 116 (literal -> character_literal .)
    ELSIF           reduce using rule 116 (literal -> character_literal .)
    FI              reduce using rule 116 (literal -> character_literal .)


state 95

    (60) location -> array_slice .

    ARROW           reduce using rule 60 (location -> array_slice .)
    LBRACKET        reduce using rule 60 (location -> array_slice .)
    TIMES           reduce using rule 60 (location -> array_slice .)
    DIVIDE          reduce using rule 60 (location -> array_slice .)
    MODULO          reduce using rule 60 (location -> array_slice .)
    PLUS            reduce using rule 60 (location -> array_slice .)
    MINUS           reduce using rule 60 (location -> array_slice .)
    CONCAT          reduce using rule 60 (location -> array_slice .)
    AND             reduce using rule 60 (location -> array_slice .)
    OR              reduce using rule 60 (location -> array_slice .)
    EQUAL           reduce using rule 60 (location -> array_slice .)
    NOTEQ           reduce using rule 60 (location -> array_slice .)
    GREATER         reduce using rule 60 (location -> array_slice .)
    GTEQUAL         reduce using rule 60 (location -> array_slice .)
    LESS            reduce using rule 60 (location -> array_slice .)
    LTEQUAL         reduce using rule 60 (location -> array_slice .)
    IN              reduce using rule 60 (location -> array_slice .)
    RBRACKET        reduce using rule 60 (location -> array_slice .)
    COLON           reduce using rule 60 (location -> array_slice .)
    COMMA           reduce using rule 60 (location -> array_slice .)
    SEMI            reduce using rule 60 (location -> array_slice .)
    THEN            reduce using rule 60 (location -> array_slice .)
    RPAREN          reduce using rule 60 (location -> array_slice .)
    ELSE            reduce using rule 60 (location -> array_slice .)
    ELSIF           reduce using rule 60 (location -> array_slice .)
    FI              reduce using rule 60 (location -> array_slice .)


state 96

    (74) conditional_expression -> IF . expression then_expression else_expression FI
    (75) conditional_expression -> IF . expression then_expression elsif_expression else_expression FI
    (72) expression -> . operand0
    (73) expression -> . conditional_expression
    (80) operand0 -> . operand1
    (81) operand0 -> . operand0 operator1 operand1
    (74) conditional_expression -> . IF expression then_expression else_expression FI
    (75) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (82) operand1 -> . operand2
    (83) operand1 -> . operand1 operator2 operand2
    (84) operand2 -> . operand3
    (85) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (86) operand3 -> . monadic_operator operand4
    (87) operand3 -> . operand4
    (94) monadic_operator -> . MINUS
    (95) monadic_operator -> . NOT
    (88) operand4 -> . array_location
    (89) operand4 -> . referenced_location
    (90) operand4 -> . primitive_value
    (71) array_location -> . location
    (96) referenced_location -> . ARROW array_location
    (113) primitive_value -> . literal
    (55) location -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (114) literal -> . integer_literal
    (115) literal -> . boolean_literal
    (116) literal -> . character_literal
    (117) literal -> . empty_literal
    (118) literal -> . character_string_literal
    (21) identifier -> . ID
    (61) dereferenced_reference -> . array_location ARROW
    (62) string_element -> . identifier LBRACKET start_element LBRACKET
    (64) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (67) array_element -> . array_location LBRACKET expression_list RBRACKET
    (70) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (119) integer_literal -> . ICONST
    (120) boolean_literal -> . TRUE
    (121) boolean_literal -> . FALSE
    (122) character_literal -> . CCONST
    (123) empty_literal -> . NULL
    (124) character_string_literal -> . SCONST

    IF              shift and go to state 96
    MINUS           shift and go to state 91
    NOT             shift and go to state 89
    ARROW           shift and go to state 82
    ID              shift and go to state 11
    ICONST          shift and go to state 93
    TRUE            shift and go to state 77
    FALSE           shift and go to state 66
    CCONST          shift and go to state 76
    NULL            shift and go to state 84
    SCONST          shift and go to state 74

    operand3                       shift and go to state 83
    string_element                 shift and go to state 67
    expression                     shift and go to state 129
    identifier                     shift and go to state 85
    primitive_value                shift and go to state 86
    operand1                       shift and go to state 69
    operand2                       shift and go to state 87
    conditional_expression         shift and go to state 88
    literal                        shift and go to state 70
    location                       shift and go to state 90
    referenced_location            shift and go to state 71
    character_string_literal       shift and go to state 72
    dereferenced_reference         shift and go to state 92
    empty_literal                  shift and go to state 75
    array_slice                    shift and go to state 95
    character_literal              shift and go to state 94
    boolean_literal                shift and go to state 97
    monadic_operator               shift and go to state 73
    array_location                 shift and go to state 78
    operand0                       shift and go to state 98
    operand4                       shift and go to state 79
    integer_literal                shift and go to state 80
    array_element                  shift and go to state 99
    string_slice                   shift and go to state 81

state 97

    (115) literal -> boolean_literal .

    TIMES           reduce using rule 115 (literal -> boolean_literal .)
    DIVIDE          reduce using rule 115 (literal -> boolean_literal .)
    MODULO          reduce using rule 115 (literal -> boolean_literal .)
    PLUS            reduce using rule 115 (literal -> boolean_literal .)
    MINUS           reduce using rule 115 (literal -> boolean_literal .)
    CONCAT          reduce using rule 115 (literal -> boolean_literal .)
    AND             reduce using rule 115 (literal -> boolean_literal .)
    OR              reduce using rule 115 (literal -> boolean_literal .)
    EQUAL           reduce using rule 115 (literal -> boolean_literal .)
    NOTEQ           reduce using rule 115 (literal -> boolean_literal .)
    GREATER         reduce using rule 115 (literal -> boolean_literal .)
    GTEQUAL         reduce using rule 115 (literal -> boolean_literal .)
    LESS            reduce using rule 115 (literal -> boolean_literal .)
    LTEQUAL         reduce using rule 115 (literal -> boolean_literal .)
    IN              reduce using rule 115 (literal -> boolean_literal .)
    THEN            reduce using rule 115 (literal -> boolean_literal .)
    COLON           reduce using rule 115 (literal -> boolean_literal .)
    COMMA           reduce using rule 115 (literal -> boolean_literal .)
    SEMI            reduce using rule 115 (literal -> boolean_literal .)
    RBRACKET        reduce using rule 115 (literal -> boolean_literal .)
    LBRACKET        reduce using rule 115 (literal -> boolean_literal .)
    RPAREN          reduce using rule 115 (literal -> boolean_literal .)
    ELSE            reduce using rule 115 (literal -> boolean_literal .)
    ELSIF           reduce using rule 115 (literal -> boolean_literal .)
    FI              reduce using rule 115 (literal -> boolean_literal .)


state 98

    (72) expression -> operand0 .
    (81) operand0 -> operand0 . operator1 operand1
    (97) operator1 -> . relational_operator
    (98) operator1 -> . membership_operator
    (104) relational_operator -> . AND
    (105) relational_operator -> . OR
    (106) relational_operator -> . EQUAL
    (107) relational_operator -> . NOTEQ
    (108) relational_operator -> . GREATER
    (109) relational_operator -> . GTEQUAL
    (110) relational_operator -> . LESS
    (111) relational_operator -> . LTEQUAL
    (112) membership_operator -> . IN

    THEN            reduce using rule 72 (expression -> operand0 .)
    COLON           reduce using rule 72 (expression -> operand0 .)
    COMMA           reduce using rule 72 (expression -> operand0 .)
    SEMI            reduce using rule 72 (expression -> operand0 .)
    RBRACKET        reduce using rule 72 (expression -> operand0 .)
    RPAREN          reduce using rule 72 (expression -> operand0 .)
    ELSE            reduce using rule 72 (expression -> operand0 .)
    ELSIF           reduce using rule 72 (expression -> operand0 .)
    LBRACKET        reduce using rule 72 (expression -> operand0 .)
    FI              reduce using rule 72 (expression -> operand0 .)
    AND             shift and go to state 141
    OR              shift and go to state 140
    EQUAL           shift and go to state 130
    NOTEQ           shift and go to state 136
    GREATER         shift and go to state 135
    GTEQUAL         shift and go to state 138
    LESS            shift and go to state 137
    LTEQUAL         shift and go to state 139
    IN              shift and go to state 131

    operator1                      shift and go to state 133
    membership_operator            shift and go to state 134
    relational_operator            shift and go to state 132

state 99

    (59) location -> array_element .

    ARROW           reduce using rule 59 (location -> array_element .)
    LBRACKET        reduce using rule 59 (location -> array_element .)
    TIMES           reduce using rule 59 (location -> array_element .)
    DIVIDE          reduce using rule 59 (location -> array_element .)
    MODULO          reduce using rule 59 (location -> array_element .)
    PLUS            reduce using rule 59 (location -> array_element .)
    MINUS           reduce using rule 59 (location -> array_element .)
    CONCAT          reduce using rule 59 (location -> array_element .)
    AND             reduce using rule 59 (location -> array_element .)
    OR              reduce using rule 59 (location -> array_element .)
    EQUAL           reduce using rule 59 (location -> array_element .)
    NOTEQ           reduce using rule 59 (location -> array_element .)
    GREATER         reduce using rule 59 (location -> array_element .)
    GTEQUAL         reduce using rule 59 (location -> array_element .)
    LESS            reduce using rule 59 (location -> array_element .)
    LTEQUAL         reduce using rule 59 (location -> array_element .)
    IN              reduce using rule 59 (location -> array_element .)
    RBRACKET        reduce using rule 59 (location -> array_element .)
    COLON           reduce using rule 59 (location -> array_element .)
    COMMA           reduce using rule 59 (location -> array_element .)
    SEMI            reduce using rule 59 (location -> array_element .)
    THEN            reduce using rule 59 (location -> array_element .)
    RPAREN          reduce using rule 59 (location -> array_element .)
    ELSE            reduce using rule 59 (location -> array_element .)
    ELSIF           reduce using rule 59 (location -> array_element .)
    FI              reduce using rule 59 (location -> array_element .)


state 100

    (10) synonym_list -> synonym_definition COMMA synonym_list .

    SEMI            reduce using rule 10 (synonym_list -> synonym_definition COMMA synonym_list .)


state 101

    (18) initialization -> ASSIGN expression .

    COMMA           reduce using rule 18 (initialization -> ASSIGN expression .)
    SEMI            reduce using rule 18 (initialization -> ASSIGN expression .)


state 102

    (42) lower_bound -> expression .

    COLON           reduce using rule 42 (lower_bound -> expression .)


state 103

    (40) discrete_range_mode -> discrete_mode LPAREN literal_range . RPAREN

    RPAREN          shift and go to state 142


state 104

    (41) literal_range -> lower_bound . COLON upper_bound

    COLON           shift and go to state 143


state 105

    (47) string_mode -> CHARS LBRACKET string_length . RBRACKET

    RBRACKET        shift and go to state 144


state 106

    (48) string_length -> integer_literal .

    RBRACKET        reduce using rule 48 (string_length -> integer_literal .)


state 107

    (49) array_mode -> ARRAY LBRACKET index_mode_list . RBRACKET element_mode

    RBRACKET        shift and go to state 145


state 108

    (52) index_mode -> discrete_mode .
    (40) discrete_range_mode -> discrete_mode . LPAREN literal_range RPAREN

    COMMA           reduce using rule 52 (index_mode -> discrete_mode .)
    RBRACKET        reduce using rule 52 (index_mode -> discrete_mode .)
    LPAREN          shift and go to state 59


state 109

    (50) index_mode_list -> index_mode .
    (51) index_mode_list -> index_mode . COMMA index_mode_list

    RBRACKET        reduce using rule 50 (index_mode_list -> index_mode .)
    COMMA           shift and go to state 146


state 110

    (53) index_mode -> literal_range .

    COMMA           reduce using rule 53 (index_mode -> literal_range .)
    RBRACKET        reduce using rule 53 (index_mode -> literal_range .)


state 111

    (35) discrete_mode_name -> identifier .
    (55) location -> identifier .
    (62) string_element -> identifier . LBRACKET start_element LBRACKET
    (64) string_slice -> identifier . LBRACKET left_element COLON right_element RBRACKET

  ! shift/reduce conflict for LBRACKET resolved as shift
    LPAREN          reduce using rule 35 (discrete_mode_name -> identifier .)
    ARROW           reduce using rule 55 (location -> identifier .)
    TIMES           reduce using rule 55 (location -> identifier .)
    DIVIDE          reduce using rule 55 (location -> identifier .)
    MODULO          reduce using rule 55 (location -> identifier .)
    PLUS            reduce using rule 55 (location -> identifier .)
    MINUS           reduce using rule 55 (location -> identifier .)
    CONCAT          reduce using rule 55 (location -> identifier .)
    AND             reduce using rule 55 (location -> identifier .)
    OR              reduce using rule 55 (location -> identifier .)
    EQUAL           reduce using rule 55 (location -> identifier .)
    NOTEQ           reduce using rule 55 (location -> identifier .)
    GREATER         reduce using rule 55 (location -> identifier .)
    GTEQUAL         reduce using rule 55 (location -> identifier .)
    LESS            reduce using rule 55 (location -> identifier .)
    LTEQUAL         reduce using rule 55 (location -> identifier .)
    IN              reduce using rule 55 (location -> identifier .)
    COLON           reduce using rule 55 (location -> identifier .)
    LBRACKET        shift and go to state 124

  ! LBRACKET        [ reduce using rule 55 (location -> identifier .) ]


state 112

    (39) discrete_range_mode -> discrete_mode_name LPAREN literal_range . RPAREN

    RPAREN          shift and go to state 147


state 113

    (11) synonym_definition -> identifier_list mode ASSIGN expression .

    COMMA           reduce using rule 11 (synonym_definition -> identifier_list mode ASSIGN expression .)
    SEMI            reduce using rule 11 (synonym_definition -> identifier_list mode ASSIGN expression .)


state 114

    (101) arithmetic_additive_operator -> PLUS .

    MINUS           reduce using rule 101 (arithmetic_additive_operator -> PLUS .)
    NOT             reduce using rule 101 (arithmetic_additive_operator -> PLUS .)
    ARROW           reduce using rule 101 (arithmetic_additive_operator -> PLUS .)
    ID              reduce using rule 101 (arithmetic_additive_operator -> PLUS .)
    ICONST          reduce using rule 101 (arithmetic_additive_operator -> PLUS .)
    TRUE            reduce using rule 101 (arithmetic_additive_operator -> PLUS .)
    FALSE           reduce using rule 101 (arithmetic_additive_operator -> PLUS .)
    CCONST          reduce using rule 101 (arithmetic_additive_operator -> PLUS .)
    NULL            reduce using rule 101 (arithmetic_additive_operator -> PLUS .)
    SCONST          reduce using rule 101 (arithmetic_additive_operator -> PLUS .)


state 115

    (100) operator2 -> string_concatenation_operator .

    MINUS           reduce using rule 100 (operator2 -> string_concatenation_operator .)
    NOT             reduce using rule 100 (operator2 -> string_concatenation_operator .)
    ARROW           reduce using rule 100 (operator2 -> string_concatenation_operator .)
    ID              reduce using rule 100 (operator2 -> string_concatenation_operator .)
    ICONST          reduce using rule 100 (operator2 -> string_concatenation_operator .)
    TRUE            reduce using rule 100 (operator2 -> string_concatenation_operator .)
    FALSE           reduce using rule 100 (operator2 -> string_concatenation_operator .)
    CCONST          reduce using rule 100 (operator2 -> string_concatenation_operator .)
    NULL            reduce using rule 100 (operator2 -> string_concatenation_operator .)
    SCONST          reduce using rule 100 (operator2 -> string_concatenation_operator .)


state 116

    (102) arithmetic_additive_operator -> MINUS .

    MINUS           reduce using rule 102 (arithmetic_additive_operator -> MINUS .)
    NOT             reduce using rule 102 (arithmetic_additive_operator -> MINUS .)
    ARROW           reduce using rule 102 (arithmetic_additive_operator -> MINUS .)
    ID              reduce using rule 102 (arithmetic_additive_operator -> MINUS .)
    ICONST          reduce using rule 102 (arithmetic_additive_operator -> MINUS .)
    TRUE            reduce using rule 102 (arithmetic_additive_operator -> MINUS .)
    FALSE           reduce using rule 102 (arithmetic_additive_operator -> MINUS .)
    CCONST          reduce using rule 102 (arithmetic_additive_operator -> MINUS .)
    NULL            reduce using rule 102 (arithmetic_additive_operator -> MINUS .)
    SCONST          reduce using rule 102 (arithmetic_additive_operator -> MINUS .)


state 117

    (103) string_concatenation_operator -> CONCAT .

    MINUS           reduce using rule 103 (string_concatenation_operator -> CONCAT .)
    NOT             reduce using rule 103 (string_concatenation_operator -> CONCAT .)
    ARROW           reduce using rule 103 (string_concatenation_operator -> CONCAT .)
    ID              reduce using rule 103 (string_concatenation_operator -> CONCAT .)
    ICONST          reduce using rule 103 (string_concatenation_operator -> CONCAT .)
    TRUE            reduce using rule 103 (string_concatenation_operator -> CONCAT .)
    FALSE           reduce using rule 103 (string_concatenation_operator -> CONCAT .)
    CCONST          reduce using rule 103 (string_concatenation_operator -> CONCAT .)
    NULL            reduce using rule 103 (string_concatenation_operator -> CONCAT .)
    SCONST          reduce using rule 103 (string_concatenation_operator -> CONCAT .)


state 118

    (83) operand1 -> operand1 operator2 . operand2
    (84) operand2 -> . operand3
    (85) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (86) operand3 -> . monadic_operator operand4
    (87) operand3 -> . operand4
    (94) monadic_operator -> . MINUS
    (95) monadic_operator -> . NOT
    (88) operand4 -> . array_location
    (89) operand4 -> . referenced_location
    (90) operand4 -> . primitive_value
    (71) array_location -> . location
    (96) referenced_location -> . ARROW array_location
    (113) primitive_value -> . literal
    (55) location -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (114) literal -> . integer_literal
    (115) literal -> . boolean_literal
    (116) literal -> . character_literal
    (117) literal -> . empty_literal
    (118) literal -> . character_string_literal
    (21) identifier -> . ID
    (61) dereferenced_reference -> . array_location ARROW
    (62) string_element -> . identifier LBRACKET start_element LBRACKET
    (64) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (67) array_element -> . array_location LBRACKET expression_list RBRACKET
    (70) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (119) integer_literal -> . ICONST
    (120) boolean_literal -> . TRUE
    (121) boolean_literal -> . FALSE
    (122) character_literal -> . CCONST
    (123) empty_literal -> . NULL
    (124) character_string_literal -> . SCONST

    MINUS           shift and go to state 91
    NOT             shift and go to state 89
    ARROW           shift and go to state 82
    ID              shift and go to state 11
    ICONST          shift and go to state 93
    TRUE            shift and go to state 77
    FALSE           shift and go to state 66
    CCONST          shift and go to state 76
    NULL            shift and go to state 84
    SCONST          shift and go to state 74

    operand3                       shift and go to state 83
    string_element                 shift and go to state 67
    identifier                     shift and go to state 85
    primitive_value                shift and go to state 86
    operand2                       shift and go to state 148
    literal                        shift and go to state 70
    location                       shift and go to state 90
    referenced_location            shift and go to state 71
    character_string_literal       shift and go to state 72
    dereferenced_reference         shift and go to state 92
    character_literal              shift and go to state 94
    array_slice                    shift and go to state 95
    monadic_operator               shift and go to state 73
    empty_literal                  shift and go to state 75
    boolean_literal                shift and go to state 97
    array_location                 shift and go to state 78
    operand4                       shift and go to state 79
    integer_literal                shift and go to state 80
    array_element                  shift and go to state 99
    string_slice                   shift and go to state 81

state 119

    (99) operator2 -> arithmetic_additive_operator .

    MINUS           reduce using rule 99 (operator2 -> arithmetic_additive_operator .)
    NOT             reduce using rule 99 (operator2 -> arithmetic_additive_operator .)
    ARROW           reduce using rule 99 (operator2 -> arithmetic_additive_operator .)
    ID              reduce using rule 99 (operator2 -> arithmetic_additive_operator .)
    ICONST          reduce using rule 99 (operator2 -> arithmetic_additive_operator .)
    TRUE            reduce using rule 99 (operator2 -> arithmetic_additive_operator .)
    FALSE           reduce using rule 99 (operator2 -> arithmetic_additive_operator .)
    CCONST          reduce using rule 99 (operator2 -> arithmetic_additive_operator .)
    NULL            reduce using rule 99 (operator2 -> arithmetic_additive_operator .)
    SCONST          reduce using rule 99 (operator2 -> arithmetic_additive_operator .)


state 120

    (86) operand3 -> monadic_operator operand4 .

    TIMES           reduce using rule 86 (operand3 -> monadic_operator operand4 .)
    DIVIDE          reduce using rule 86 (operand3 -> monadic_operator operand4 .)
    MODULO          reduce using rule 86 (operand3 -> monadic_operator operand4 .)
    PLUS            reduce using rule 86 (operand3 -> monadic_operator operand4 .)
    MINUS           reduce using rule 86 (operand3 -> monadic_operator operand4 .)
    CONCAT          reduce using rule 86 (operand3 -> monadic_operator operand4 .)
    AND             reduce using rule 86 (operand3 -> monadic_operator operand4 .)
    OR              reduce using rule 86 (operand3 -> monadic_operator operand4 .)
    EQUAL           reduce using rule 86 (operand3 -> monadic_operator operand4 .)
    NOTEQ           reduce using rule 86 (operand3 -> monadic_operator operand4 .)
    GREATER         reduce using rule 86 (operand3 -> monadic_operator operand4 .)
    GTEQUAL         reduce using rule 86 (operand3 -> monadic_operator operand4 .)
    LESS            reduce using rule 86 (operand3 -> monadic_operator operand4 .)
    LTEQUAL         reduce using rule 86 (operand3 -> monadic_operator operand4 .)
    IN              reduce using rule 86 (operand3 -> monadic_operator operand4 .)
    THEN            reduce using rule 86 (operand3 -> monadic_operator operand4 .)
    RPAREN          reduce using rule 86 (operand3 -> monadic_operator operand4 .)
    COMMA           reduce using rule 86 (operand3 -> monadic_operator operand4 .)
    RBRACKET        reduce using rule 86 (operand3 -> monadic_operator operand4 .)
    LBRACKET        reduce using rule 86 (operand3 -> monadic_operator operand4 .)
    COLON           reduce using rule 86 (operand3 -> monadic_operator operand4 .)
    ELSE            reduce using rule 86 (operand3 -> monadic_operator operand4 .)
    ELSIF           reduce using rule 86 (operand3 -> monadic_operator operand4 .)
    SEMI            reduce using rule 86 (operand3 -> monadic_operator operand4 .)
    FI              reduce using rule 86 (operand3 -> monadic_operator operand4 .)


state 121

    (61) dereferenced_reference -> array_location ARROW .

    ARROW           reduce using rule 61 (dereferenced_reference -> array_location ARROW .)
    LBRACKET        reduce using rule 61 (dereferenced_reference -> array_location ARROW .)
    TIMES           reduce using rule 61 (dereferenced_reference -> array_location ARROW .)
    DIVIDE          reduce using rule 61 (dereferenced_reference -> array_location ARROW .)
    MODULO          reduce using rule 61 (dereferenced_reference -> array_location ARROW .)
    PLUS            reduce using rule 61 (dereferenced_reference -> array_location ARROW .)
    MINUS           reduce using rule 61 (dereferenced_reference -> array_location ARROW .)
    CONCAT          reduce using rule 61 (dereferenced_reference -> array_location ARROW .)
    AND             reduce using rule 61 (dereferenced_reference -> array_location ARROW .)
    OR              reduce using rule 61 (dereferenced_reference -> array_location ARROW .)
    EQUAL           reduce using rule 61 (dereferenced_reference -> array_location ARROW .)
    NOTEQ           reduce using rule 61 (dereferenced_reference -> array_location ARROW .)
    GREATER         reduce using rule 61 (dereferenced_reference -> array_location ARROW .)
    GTEQUAL         reduce using rule 61 (dereferenced_reference -> array_location ARROW .)
    LESS            reduce using rule 61 (dereferenced_reference -> array_location ARROW .)
    LTEQUAL         reduce using rule 61 (dereferenced_reference -> array_location ARROW .)
    IN              reduce using rule 61 (dereferenced_reference -> array_location ARROW .)
    COLON           reduce using rule 61 (dereferenced_reference -> array_location ARROW .)
    RBRACKET        reduce using rule 61 (dereferenced_reference -> array_location ARROW .)
    COMMA           reduce using rule 61 (dereferenced_reference -> array_location ARROW .)
    SEMI            reduce using rule 61 (dereferenced_reference -> array_location ARROW .)
    THEN            reduce using rule 61 (dereferenced_reference -> array_location ARROW .)
    RPAREN          reduce using rule 61 (dereferenced_reference -> array_location ARROW .)
    ELSE            reduce using rule 61 (dereferenced_reference -> array_location ARROW .)
    ELSIF           reduce using rule 61 (dereferenced_reference -> array_location ARROW .)
    FI              reduce using rule 61 (dereferenced_reference -> array_location ARROW .)


state 122

    (67) array_element -> array_location LBRACKET . expression_list RBRACKET
    (70) array_slice -> array_location LBRACKET . lower_bound COLON upper_bound RBRACKET
    (68) expression_list -> . expression
    (69) expression_list -> . expression COMMA expression_list
    (42) lower_bound -> . expression
    (72) expression -> . operand0
    (73) expression -> . conditional_expression
    (80) operand0 -> . operand1
    (81) operand0 -> . operand0 operator1 operand1
    (74) conditional_expression -> . IF expression then_expression else_expression FI
    (75) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (82) operand1 -> . operand2
    (83) operand1 -> . operand1 operator2 operand2
    (84) operand2 -> . operand3
    (85) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (86) operand3 -> . monadic_operator operand4
    (87) operand3 -> . operand4
    (94) monadic_operator -> . MINUS
    (95) monadic_operator -> . NOT
    (88) operand4 -> . array_location
    (89) operand4 -> . referenced_location
    (90) operand4 -> . primitive_value
    (71) array_location -> . location
    (96) referenced_location -> . ARROW array_location
    (113) primitive_value -> . literal
    (55) location -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (114) literal -> . integer_literal
    (115) literal -> . boolean_literal
    (116) literal -> . character_literal
    (117) literal -> . empty_literal
    (118) literal -> . character_string_literal
    (21) identifier -> . ID
    (61) dereferenced_reference -> . array_location ARROW
    (62) string_element -> . identifier LBRACKET start_element LBRACKET
    (64) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (67) array_element -> . array_location LBRACKET expression_list RBRACKET
    (70) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (119) integer_literal -> . ICONST
    (120) boolean_literal -> . TRUE
    (121) boolean_literal -> . FALSE
    (122) character_literal -> . CCONST
    (123) empty_literal -> . NULL
    (124) character_string_literal -> . SCONST

    IF              shift and go to state 96
    MINUS           shift and go to state 91
    NOT             shift and go to state 89
    ARROW           shift and go to state 82
    ID              shift and go to state 11
    ICONST          shift and go to state 93
    TRUE            shift and go to state 77
    FALSE           shift and go to state 66
    CCONST          shift and go to state 76
    NULL            shift and go to state 84
    SCONST          shift and go to state 74

    operand3                       shift and go to state 83
    string_element                 shift and go to state 67
    expression_list                shift and go to state 149
    expression                     shift and go to state 150
    identifier                     shift and go to state 85
    primitive_value                shift and go to state 86
    lower_bound                    shift and go to state 151
    operand1                       shift and go to state 69
    operand2                       shift and go to state 87
    conditional_expression         shift and go to state 88
    literal                        shift and go to state 70
    location                       shift and go to state 90
    referenced_location            shift and go to state 71
    character_string_literal       shift and go to state 72
    empty_literal                  shift and go to state 75
    array_location                 shift and go to state 78
    array_slice                    shift and go to state 95
    character_literal              shift and go to state 94
    boolean_literal                shift and go to state 97
    monadic_operator               shift and go to state 73
    operand0                       shift and go to state 98
    operand4                       shift and go to state 79
    integer_literal                shift and go to state 80
    dereferenced_reference         shift and go to state 92
    array_element                  shift and go to state 99
    string_slice                   shift and go to state 81

state 123

    (96) referenced_location -> ARROW array_location .
    (61) dereferenced_reference -> array_location . ARROW
    (67) array_element -> array_location . LBRACKET expression_list RBRACKET
    (70) array_slice -> array_location . LBRACKET lower_bound COLON upper_bound RBRACKET

  ! shift/reduce conflict for LBRACKET resolved as shift
    TIMES           reduce using rule 96 (referenced_location -> ARROW array_location .)
    DIVIDE          reduce using rule 96 (referenced_location -> ARROW array_location .)
    MODULO          reduce using rule 96 (referenced_location -> ARROW array_location .)
    PLUS            reduce using rule 96 (referenced_location -> ARROW array_location .)
    MINUS           reduce using rule 96 (referenced_location -> ARROW array_location .)
    CONCAT          reduce using rule 96 (referenced_location -> ARROW array_location .)
    AND             reduce using rule 96 (referenced_location -> ARROW array_location .)
    OR              reduce using rule 96 (referenced_location -> ARROW array_location .)
    EQUAL           reduce using rule 96 (referenced_location -> ARROW array_location .)
    NOTEQ           reduce using rule 96 (referenced_location -> ARROW array_location .)
    GREATER         reduce using rule 96 (referenced_location -> ARROW array_location .)
    GTEQUAL         reduce using rule 96 (referenced_location -> ARROW array_location .)
    LESS            reduce using rule 96 (referenced_location -> ARROW array_location .)
    LTEQUAL         reduce using rule 96 (referenced_location -> ARROW array_location .)
    IN              reduce using rule 96 (referenced_location -> ARROW array_location .)
    RBRACKET        reduce using rule 96 (referenced_location -> ARROW array_location .)
    COMMA           reduce using rule 96 (referenced_location -> ARROW array_location .)
    COLON           reduce using rule 96 (referenced_location -> ARROW array_location .)
    THEN            reduce using rule 96 (referenced_location -> ARROW array_location .)
    ELSE            reduce using rule 96 (referenced_location -> ARROW array_location .)
    ELSIF           reduce using rule 96 (referenced_location -> ARROW array_location .)
    SEMI            reduce using rule 96 (referenced_location -> ARROW array_location .)
    RPAREN          reduce using rule 96 (referenced_location -> ARROW array_location .)
    FI              reduce using rule 96 (referenced_location -> ARROW array_location .)
    ARROW           shift and go to state 121
    LBRACKET        shift and go to state 122

  ! LBRACKET        [ reduce using rule 96 (referenced_location -> ARROW array_location .) ]


state 124

    (62) string_element -> identifier LBRACKET . start_element LBRACKET
    (64) string_slice -> identifier LBRACKET . left_element COLON right_element RBRACKET
    (63) start_element -> . expression
    (65) left_element -> . expression
    (72) expression -> . operand0
    (73) expression -> . conditional_expression
    (80) operand0 -> . operand1
    (81) operand0 -> . operand0 operator1 operand1
    (74) conditional_expression -> . IF expression then_expression else_expression FI
    (75) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (82) operand1 -> . operand2
    (83) operand1 -> . operand1 operator2 operand2
    (84) operand2 -> . operand3
    (85) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (86) operand3 -> . monadic_operator operand4
    (87) operand3 -> . operand4
    (94) monadic_operator -> . MINUS
    (95) monadic_operator -> . NOT
    (88) operand4 -> . array_location
    (89) operand4 -> . referenced_location
    (90) operand4 -> . primitive_value
    (71) array_location -> . location
    (96) referenced_location -> . ARROW array_location
    (113) primitive_value -> . literal
    (55) location -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (114) literal -> . integer_literal
    (115) literal -> . boolean_literal
    (116) literal -> . character_literal
    (117) literal -> . empty_literal
    (118) literal -> . character_string_literal
    (21) identifier -> . ID
    (61) dereferenced_reference -> . array_location ARROW
    (62) string_element -> . identifier LBRACKET start_element LBRACKET
    (64) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (67) array_element -> . array_location LBRACKET expression_list RBRACKET
    (70) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (119) integer_literal -> . ICONST
    (120) boolean_literal -> . TRUE
    (121) boolean_literal -> . FALSE
    (122) character_literal -> . CCONST
    (123) empty_literal -> . NULL
    (124) character_string_literal -> . SCONST

    IF              shift and go to state 96
    MINUS           shift and go to state 91
    NOT             shift and go to state 89
    ARROW           shift and go to state 82
    ID              shift and go to state 11
    ICONST          shift and go to state 93
    TRUE            shift and go to state 77
    FALSE           shift and go to state 66
    CCONST          shift and go to state 76
    NULL            shift and go to state 84
    SCONST          shift and go to state 74

    operand3                       shift and go to state 83
    string_element                 shift and go to state 67
    expression                     shift and go to state 152
    identifier                     shift and go to state 85
    primitive_value                shift and go to state 86
    operand1                       shift and go to state 69
    operand2                       shift and go to state 87
    conditional_expression         shift and go to state 88
    literal                        shift and go to state 70
    location                       shift and go to state 90
    left_element                   shift and go to state 153
    referenced_location            shift and go to state 71
    character_string_literal       shift and go to state 72
    start_element                  shift and go to state 154
    array_slice                    shift and go to state 95
    character_literal              shift and go to state 94
    boolean_literal                shift and go to state 97
    empty_literal                  shift and go to state 75
    monadic_operator               shift and go to state 73
    array_location                 shift and go to state 78
    operand0                       shift and go to state 98
    operand4                       shift and go to state 79
    integer_literal                shift and go to state 80
    dereferenced_reference         shift and go to state 92
    array_element                  shift and go to state 99
    string_slice                   shift and go to state 81

state 125

    (92) arithmetic_multiplicative_operator -> DIVIDE .

    MINUS           reduce using rule 92 (arithmetic_multiplicative_operator -> DIVIDE .)
    NOT             reduce using rule 92 (arithmetic_multiplicative_operator -> DIVIDE .)
    ARROW           reduce using rule 92 (arithmetic_multiplicative_operator -> DIVIDE .)
    ID              reduce using rule 92 (arithmetic_multiplicative_operator -> DIVIDE .)
    ICONST          reduce using rule 92 (arithmetic_multiplicative_operator -> DIVIDE .)
    TRUE            reduce using rule 92 (arithmetic_multiplicative_operator -> DIVIDE .)
    FALSE           reduce using rule 92 (arithmetic_multiplicative_operator -> DIVIDE .)
    CCONST          reduce using rule 92 (arithmetic_multiplicative_operator -> DIVIDE .)
    NULL            reduce using rule 92 (arithmetic_multiplicative_operator -> DIVIDE .)
    SCONST          reduce using rule 92 (arithmetic_multiplicative_operator -> DIVIDE .)


state 126

    (85) operand2 -> operand2 arithmetic_multiplicative_operator . operand3
    (86) operand3 -> . monadic_operator operand4
    (87) operand3 -> . operand4
    (94) monadic_operator -> . MINUS
    (95) monadic_operator -> . NOT
    (88) operand4 -> . array_location
    (89) operand4 -> . referenced_location
    (90) operand4 -> . primitive_value
    (71) array_location -> . location
    (96) referenced_location -> . ARROW array_location
    (113) primitive_value -> . literal
    (55) location -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (114) literal -> . integer_literal
    (115) literal -> . boolean_literal
    (116) literal -> . character_literal
    (117) literal -> . empty_literal
    (118) literal -> . character_string_literal
    (21) identifier -> . ID
    (61) dereferenced_reference -> . array_location ARROW
    (62) string_element -> . identifier LBRACKET start_element LBRACKET
    (64) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (67) array_element -> . array_location LBRACKET expression_list RBRACKET
    (70) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (119) integer_literal -> . ICONST
    (120) boolean_literal -> . TRUE
    (121) boolean_literal -> . FALSE
    (122) character_literal -> . CCONST
    (123) empty_literal -> . NULL
    (124) character_string_literal -> . SCONST

    MINUS           shift and go to state 91
    NOT             shift and go to state 89
    ARROW           shift and go to state 82
    ID              shift and go to state 11
    ICONST          shift and go to state 93
    TRUE            shift and go to state 77
    FALSE           shift and go to state 66
    CCONST          shift and go to state 76
    NULL            shift and go to state 84
    SCONST          shift and go to state 74

    operand3                       shift and go to state 155
    string_element                 shift and go to state 67
    identifier                     shift and go to state 85
    primitive_value                shift and go to state 86
    literal                        shift and go to state 70
    location                       shift and go to state 90
    referenced_location            shift and go to state 71
    character_string_literal       shift and go to state 72
    dereferenced_reference         shift and go to state 92
    character_literal              shift and go to state 94
    array_slice                    shift and go to state 95
    monadic_operator               shift and go to state 73
    empty_literal                  shift and go to state 75
    boolean_literal                shift and go to state 97
    array_location                 shift and go to state 78
    operand4                       shift and go to state 79
    integer_literal                shift and go to state 80
    array_element                  shift and go to state 99
    string_slice                   shift and go to state 81

state 127

    (93) arithmetic_multiplicative_operator -> MODULO .

    MINUS           reduce using rule 93 (arithmetic_multiplicative_operator -> MODULO .)
    NOT             reduce using rule 93 (arithmetic_multiplicative_operator -> MODULO .)
    ARROW           reduce using rule 93 (arithmetic_multiplicative_operator -> MODULO .)
    ID              reduce using rule 93 (arithmetic_multiplicative_operator -> MODULO .)
    ICONST          reduce using rule 93 (arithmetic_multiplicative_operator -> MODULO .)
    TRUE            reduce using rule 93 (arithmetic_multiplicative_operator -> MODULO .)
    FALSE           reduce using rule 93 (arithmetic_multiplicative_operator -> MODULO .)
    CCONST          reduce using rule 93 (arithmetic_multiplicative_operator -> MODULO .)
    NULL            reduce using rule 93 (arithmetic_multiplicative_operator -> MODULO .)
    SCONST          reduce using rule 93 (arithmetic_multiplicative_operator -> MODULO .)


state 128

    (91) arithmetic_multiplicative_operator -> TIMES .

    MINUS           reduce using rule 91 (arithmetic_multiplicative_operator -> TIMES .)
    NOT             reduce using rule 91 (arithmetic_multiplicative_operator -> TIMES .)
    ARROW           reduce using rule 91 (arithmetic_multiplicative_operator -> TIMES .)
    ID              reduce using rule 91 (arithmetic_multiplicative_operator -> TIMES .)
    ICONST          reduce using rule 91 (arithmetic_multiplicative_operator -> TIMES .)
    TRUE            reduce using rule 91 (arithmetic_multiplicative_operator -> TIMES .)
    FALSE           reduce using rule 91 (arithmetic_multiplicative_operator -> TIMES .)
    CCONST          reduce using rule 91 (arithmetic_multiplicative_operator -> TIMES .)
    NULL            reduce using rule 91 (arithmetic_multiplicative_operator -> TIMES .)
    SCONST          reduce using rule 91 (arithmetic_multiplicative_operator -> TIMES .)


state 129

    (74) conditional_expression -> IF expression . then_expression else_expression FI
    (75) conditional_expression -> IF expression . then_expression elsif_expression else_expression FI
    (76) then_expression -> . THEN expression

    THEN            shift and go to state 157

    then_expression                shift and go to state 156

state 130

    (106) relational_operator -> EQUAL .

    MINUS           reduce using rule 106 (relational_operator -> EQUAL .)
    NOT             reduce using rule 106 (relational_operator -> EQUAL .)
    ARROW           reduce using rule 106 (relational_operator -> EQUAL .)
    ID              reduce using rule 106 (relational_operator -> EQUAL .)
    ICONST          reduce using rule 106 (relational_operator -> EQUAL .)
    TRUE            reduce using rule 106 (relational_operator -> EQUAL .)
    FALSE           reduce using rule 106 (relational_operator -> EQUAL .)
    CCONST          reduce using rule 106 (relational_operator -> EQUAL .)
    NULL            reduce using rule 106 (relational_operator -> EQUAL .)
    SCONST          reduce using rule 106 (relational_operator -> EQUAL .)


state 131

    (112) membership_operator -> IN .

    MINUS           reduce using rule 112 (membership_operator -> IN .)
    NOT             reduce using rule 112 (membership_operator -> IN .)
    ARROW           reduce using rule 112 (membership_operator -> IN .)
    ID              reduce using rule 112 (membership_operator -> IN .)
    ICONST          reduce using rule 112 (membership_operator -> IN .)
    TRUE            reduce using rule 112 (membership_operator -> IN .)
    FALSE           reduce using rule 112 (membership_operator -> IN .)
    CCONST          reduce using rule 112 (membership_operator -> IN .)
    NULL            reduce using rule 112 (membership_operator -> IN .)
    SCONST          reduce using rule 112 (membership_operator -> IN .)


state 132

    (97) operator1 -> relational_operator .

    MINUS           reduce using rule 97 (operator1 -> relational_operator .)
    NOT             reduce using rule 97 (operator1 -> relational_operator .)
    ARROW           reduce using rule 97 (operator1 -> relational_operator .)
    ID              reduce using rule 97 (operator1 -> relational_operator .)
    ICONST          reduce using rule 97 (operator1 -> relational_operator .)
    TRUE            reduce using rule 97 (operator1 -> relational_operator .)
    FALSE           reduce using rule 97 (operator1 -> relational_operator .)
    CCONST          reduce using rule 97 (operator1 -> relational_operator .)
    NULL            reduce using rule 97 (operator1 -> relational_operator .)
    SCONST          reduce using rule 97 (operator1 -> relational_operator .)


state 133

    (81) operand0 -> operand0 operator1 . operand1
    (82) operand1 -> . operand2
    (83) operand1 -> . operand1 operator2 operand2
    (84) operand2 -> . operand3
    (85) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (86) operand3 -> . monadic_operator operand4
    (87) operand3 -> . operand4
    (94) monadic_operator -> . MINUS
    (95) monadic_operator -> . NOT
    (88) operand4 -> . array_location
    (89) operand4 -> . referenced_location
    (90) operand4 -> . primitive_value
    (71) array_location -> . location
    (96) referenced_location -> . ARROW array_location
    (113) primitive_value -> . literal
    (55) location -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (114) literal -> . integer_literal
    (115) literal -> . boolean_literal
    (116) literal -> . character_literal
    (117) literal -> . empty_literal
    (118) literal -> . character_string_literal
    (21) identifier -> . ID
    (61) dereferenced_reference -> . array_location ARROW
    (62) string_element -> . identifier LBRACKET start_element LBRACKET
    (64) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (67) array_element -> . array_location LBRACKET expression_list RBRACKET
    (70) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (119) integer_literal -> . ICONST
    (120) boolean_literal -> . TRUE
    (121) boolean_literal -> . FALSE
    (122) character_literal -> . CCONST
    (123) empty_literal -> . NULL
    (124) character_string_literal -> . SCONST

    MINUS           shift and go to state 91
    NOT             shift and go to state 89
    ARROW           shift and go to state 82
    ID              shift and go to state 11
    ICONST          shift and go to state 93
    TRUE            shift and go to state 77
    FALSE           shift and go to state 66
    CCONST          shift and go to state 76
    NULL            shift and go to state 84
    SCONST          shift and go to state 74

    operand3                       shift and go to state 83
    string_element                 shift and go to state 67
    identifier                     shift and go to state 85
    primitive_value                shift and go to state 86
    operand1                       shift and go to state 158
    operand2                       shift and go to state 87
    literal                        shift and go to state 70
    location                       shift and go to state 90
    referenced_location            shift and go to state 71
    character_string_literal       shift and go to state 72
    dereferenced_reference         shift and go to state 92
    array_slice                    shift and go to state 95
    character_literal              shift and go to state 94
    boolean_literal                shift and go to state 97
    empty_literal                  shift and go to state 75
    monadic_operator               shift and go to state 73
    array_location                 shift and go to state 78
    operand4                       shift and go to state 79
    integer_literal                shift and go to state 80
    array_element                  shift and go to state 99
    string_slice                   shift and go to state 81

state 134

    (98) operator1 -> membership_operator .

    MINUS           reduce using rule 98 (operator1 -> membership_operator .)
    NOT             reduce using rule 98 (operator1 -> membership_operator .)
    ARROW           reduce using rule 98 (operator1 -> membership_operator .)
    ID              reduce using rule 98 (operator1 -> membership_operator .)
    ICONST          reduce using rule 98 (operator1 -> membership_operator .)
    TRUE            reduce using rule 98 (operator1 -> membership_operator .)
    FALSE           reduce using rule 98 (operator1 -> membership_operator .)
    CCONST          reduce using rule 98 (operator1 -> membership_operator .)
    NULL            reduce using rule 98 (operator1 -> membership_operator .)
    SCONST          reduce using rule 98 (operator1 -> membership_operator .)


state 135

    (108) relational_operator -> GREATER .

    MINUS           reduce using rule 108 (relational_operator -> GREATER .)
    NOT             reduce using rule 108 (relational_operator -> GREATER .)
    ARROW           reduce using rule 108 (relational_operator -> GREATER .)
    ID              reduce using rule 108 (relational_operator -> GREATER .)
    ICONST          reduce using rule 108 (relational_operator -> GREATER .)
    TRUE            reduce using rule 108 (relational_operator -> GREATER .)
    FALSE           reduce using rule 108 (relational_operator -> GREATER .)
    CCONST          reduce using rule 108 (relational_operator -> GREATER .)
    NULL            reduce using rule 108 (relational_operator -> GREATER .)
    SCONST          reduce using rule 108 (relational_operator -> GREATER .)


state 136

    (107) relational_operator -> NOTEQ .

    MINUS           reduce using rule 107 (relational_operator -> NOTEQ .)
    NOT             reduce using rule 107 (relational_operator -> NOTEQ .)
    ARROW           reduce using rule 107 (relational_operator -> NOTEQ .)
    ID              reduce using rule 107 (relational_operator -> NOTEQ .)
    ICONST          reduce using rule 107 (relational_operator -> NOTEQ .)
    TRUE            reduce using rule 107 (relational_operator -> NOTEQ .)
    FALSE           reduce using rule 107 (relational_operator -> NOTEQ .)
    CCONST          reduce using rule 107 (relational_operator -> NOTEQ .)
    NULL            reduce using rule 107 (relational_operator -> NOTEQ .)
    SCONST          reduce using rule 107 (relational_operator -> NOTEQ .)


state 137

    (110) relational_operator -> LESS .

    MINUS           reduce using rule 110 (relational_operator -> LESS .)
    NOT             reduce using rule 110 (relational_operator -> LESS .)
    ARROW           reduce using rule 110 (relational_operator -> LESS .)
    ID              reduce using rule 110 (relational_operator -> LESS .)
    ICONST          reduce using rule 110 (relational_operator -> LESS .)
    TRUE            reduce using rule 110 (relational_operator -> LESS .)
    FALSE           reduce using rule 110 (relational_operator -> LESS .)
    CCONST          reduce using rule 110 (relational_operator -> LESS .)
    NULL            reduce using rule 110 (relational_operator -> LESS .)
    SCONST          reduce using rule 110 (relational_operator -> LESS .)


state 138

    (109) relational_operator -> GTEQUAL .

    MINUS           reduce using rule 109 (relational_operator -> GTEQUAL .)
    NOT             reduce using rule 109 (relational_operator -> GTEQUAL .)
    ARROW           reduce using rule 109 (relational_operator -> GTEQUAL .)
    ID              reduce using rule 109 (relational_operator -> GTEQUAL .)
    ICONST          reduce using rule 109 (relational_operator -> GTEQUAL .)
    TRUE            reduce using rule 109 (relational_operator -> GTEQUAL .)
    FALSE           reduce using rule 109 (relational_operator -> GTEQUAL .)
    CCONST          reduce using rule 109 (relational_operator -> GTEQUAL .)
    NULL            reduce using rule 109 (relational_operator -> GTEQUAL .)
    SCONST          reduce using rule 109 (relational_operator -> GTEQUAL .)


state 139

    (111) relational_operator -> LTEQUAL .

    MINUS           reduce using rule 111 (relational_operator -> LTEQUAL .)
    NOT             reduce using rule 111 (relational_operator -> LTEQUAL .)
    ARROW           reduce using rule 111 (relational_operator -> LTEQUAL .)
    ID              reduce using rule 111 (relational_operator -> LTEQUAL .)
    ICONST          reduce using rule 111 (relational_operator -> LTEQUAL .)
    TRUE            reduce using rule 111 (relational_operator -> LTEQUAL .)
    FALSE           reduce using rule 111 (relational_operator -> LTEQUAL .)
    CCONST          reduce using rule 111 (relational_operator -> LTEQUAL .)
    NULL            reduce using rule 111 (relational_operator -> LTEQUAL .)
    SCONST          reduce using rule 111 (relational_operator -> LTEQUAL .)


state 140

    (105) relational_operator -> OR .

    MINUS           reduce using rule 105 (relational_operator -> OR .)
    NOT             reduce using rule 105 (relational_operator -> OR .)
    ARROW           reduce using rule 105 (relational_operator -> OR .)
    ID              reduce using rule 105 (relational_operator -> OR .)
    ICONST          reduce using rule 105 (relational_operator -> OR .)
    TRUE            reduce using rule 105 (relational_operator -> OR .)
    FALSE           reduce using rule 105 (relational_operator -> OR .)
    CCONST          reduce using rule 105 (relational_operator -> OR .)
    NULL            reduce using rule 105 (relational_operator -> OR .)
    SCONST          reduce using rule 105 (relational_operator -> OR .)


state 141

    (104) relational_operator -> AND .

    MINUS           reduce using rule 104 (relational_operator -> AND .)
    NOT             reduce using rule 104 (relational_operator -> AND .)
    ARROW           reduce using rule 104 (relational_operator -> AND .)
    ID              reduce using rule 104 (relational_operator -> AND .)
    ICONST          reduce using rule 104 (relational_operator -> AND .)
    TRUE            reduce using rule 104 (relational_operator -> AND .)
    FALSE           reduce using rule 104 (relational_operator -> AND .)
    CCONST          reduce using rule 104 (relational_operator -> AND .)
    NULL            reduce using rule 104 (relational_operator -> AND .)
    SCONST          reduce using rule 104 (relational_operator -> AND .)


state 142

    (40) discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .

    LPAREN          reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    COMMA           reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    RBRACKET        reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    ASSIGN          reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    SEMI            reduce using rule 40 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)


state 143

    (41) literal_range -> lower_bound COLON . upper_bound
    (43) upper_bound -> . expression
    (72) expression -> . operand0
    (73) expression -> . conditional_expression
    (80) operand0 -> . operand1
    (81) operand0 -> . operand0 operator1 operand1
    (74) conditional_expression -> . IF expression then_expression else_expression FI
    (75) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (82) operand1 -> . operand2
    (83) operand1 -> . operand1 operator2 operand2
    (84) operand2 -> . operand3
    (85) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (86) operand3 -> . monadic_operator operand4
    (87) operand3 -> . operand4
    (94) monadic_operator -> . MINUS
    (95) monadic_operator -> . NOT
    (88) operand4 -> . array_location
    (89) operand4 -> . referenced_location
    (90) operand4 -> . primitive_value
    (71) array_location -> . location
    (96) referenced_location -> . ARROW array_location
    (113) primitive_value -> . literal
    (55) location -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (114) literal -> . integer_literal
    (115) literal -> . boolean_literal
    (116) literal -> . character_literal
    (117) literal -> . empty_literal
    (118) literal -> . character_string_literal
    (21) identifier -> . ID
    (61) dereferenced_reference -> . array_location ARROW
    (62) string_element -> . identifier LBRACKET start_element LBRACKET
    (64) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (67) array_element -> . array_location LBRACKET expression_list RBRACKET
    (70) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (119) integer_literal -> . ICONST
    (120) boolean_literal -> . TRUE
    (121) boolean_literal -> . FALSE
    (122) character_literal -> . CCONST
    (123) empty_literal -> . NULL
    (124) character_string_literal -> . SCONST

    IF              shift and go to state 96
    MINUS           shift and go to state 91
    NOT             shift and go to state 89
    ARROW           shift and go to state 82
    ID              shift and go to state 11
    ICONST          shift and go to state 93
    TRUE            shift and go to state 77
    FALSE           shift and go to state 66
    CCONST          shift and go to state 76
    NULL            shift and go to state 84
    SCONST          shift and go to state 74

    operand3                       shift and go to state 83
    string_element                 shift and go to state 67
    expression                     shift and go to state 159
    identifier                     shift and go to state 85
    primitive_value                shift and go to state 86
    operand1                       shift and go to state 69
    operand2                       shift and go to state 87
    conditional_expression         shift and go to state 88
    literal                        shift and go to state 70
    location                       shift and go to state 90
    referenced_location            shift and go to state 71
    character_string_literal       shift and go to state 72
    empty_literal                  shift and go to state 75
    upper_bound                    shift and go to state 160
    array_slice                    shift and go to state 95
    character_literal              shift and go to state 94
    boolean_literal                shift and go to state 97
    monadic_operator               shift and go to state 73
    array_location                 shift and go to state 78
    operand0                       shift and go to state 98
    operand4                       shift and go to state 79
    integer_literal                shift and go to state 80
    dereferenced_reference         shift and go to state 92
    array_element                  shift and go to state 99
    string_slice                   shift and go to state 81

state 144

    (47) string_mode -> CHARS LBRACKET string_length RBRACKET .

    ASSIGN          reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    COMMA           reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    SEMI            reduce using rule 47 (string_mode -> CHARS LBRACKET string_length RBRACKET .)


state 145

    (49) array_mode -> ARRAY LBRACKET index_mode_list RBRACKET . element_mode
    (54) element_mode -> . mode
    (26) mode -> . mode_name
    (27) mode -> . discrete_mode
    (28) mode -> . reference_mode
    (29) mode -> . composite_mode
    (30) mode_name -> . identifier
    (31) discrete_mode -> . integer_mode
    (32) discrete_mode -> . boolean_mode
    (33) discrete_mode -> . character_mode
    (34) discrete_mode -> . discrete_range_mode
    (44) reference_mode -> . REF mode
    (45) composite_mode -> . string_mode
    (46) composite_mode -> . array_mode
    (21) identifier -> . ID
    (36) integer_mode -> . INT
    (37) boolean_mode -> . BOOL
    (38) character_mode -> . CHAR
    (39) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (40) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (47) string_mode -> . CHARS LBRACKET string_length RBRACKET
    (49) array_mode -> . ARRAY LBRACKET index_mode_list RBRACKET element_mode
    (35) discrete_mode_name -> . identifier

    REF             shift and go to state 38
    ID              shift and go to state 11
    INT             shift and go to state 36
    BOOL            shift and go to state 33
    CHAR            shift and go to state 42
    CHARS           shift and go to state 35
    ARRAY           shift and go to state 39

    composite_mode                 shift and go to state 41
    mode_name                      shift and go to state 43
    element_mode                   shift and go to state 161
    reference_mode                 shift and go to state 29
    identifier                     shift and go to state 30
    discrete_range_mode            shift and go to state 31
    boolean_mode                   shift and go to state 44
    mode                           shift and go to state 162
    string_mode                    shift and go to state 45
    discrete_mode_name             shift and go to state 46
    discrete_mode                  shift and go to state 34
    character_mode                 shift and go to state 37
    array_mode                     shift and go to state 47
    integer_mode                   shift and go to state 40

state 146

    (51) index_mode_list -> index_mode COMMA . index_mode_list
    (50) index_mode_list -> . index_mode
    (51) index_mode_list -> . index_mode COMMA index_mode_list
    (52) index_mode -> . discrete_mode
    (53) index_mode -> . literal_range
    (31) discrete_mode -> . integer_mode
    (32) discrete_mode -> . boolean_mode
    (33) discrete_mode -> . character_mode
    (34) discrete_mode -> . discrete_range_mode
    (41) literal_range -> . lower_bound COLON upper_bound
    (36) integer_mode -> . INT
    (37) boolean_mode -> . BOOL
    (38) character_mode -> . CHAR
    (39) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (40) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (42) lower_bound -> . expression
    (35) discrete_mode_name -> . identifier
    (72) expression -> . operand0
    (73) expression -> . conditional_expression
    (21) identifier -> . ID
    (80) operand0 -> . operand1
    (81) operand0 -> . operand0 operator1 operand1
    (74) conditional_expression -> . IF expression then_expression else_expression FI
    (75) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (82) operand1 -> . operand2
    (83) operand1 -> . operand1 operator2 operand2
    (84) operand2 -> . operand3
    (85) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (86) operand3 -> . monadic_operator operand4
    (87) operand3 -> . operand4
    (94) monadic_operator -> . MINUS
    (95) monadic_operator -> . NOT
    (88) operand4 -> . array_location
    (89) operand4 -> . referenced_location
    (90) operand4 -> . primitive_value
    (71) array_location -> . location
    (96) referenced_location -> . ARROW array_location
    (113) primitive_value -> . literal
    (55) location -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (114) literal -> . integer_literal
    (115) literal -> . boolean_literal
    (116) literal -> . character_literal
    (117) literal -> . empty_literal
    (118) literal -> . character_string_literal
    (61) dereferenced_reference -> . array_location ARROW
    (62) string_element -> . identifier LBRACKET start_element LBRACKET
    (64) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (67) array_element -> . array_location LBRACKET expression_list RBRACKET
    (70) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (119) integer_literal -> . ICONST
    (120) boolean_literal -> . TRUE
    (121) boolean_literal -> . FALSE
    (122) character_literal -> . CCONST
    (123) empty_literal -> . NULL
    (124) character_string_literal -> . SCONST

    INT             shift and go to state 36
    BOOL            shift and go to state 33
    CHAR            shift and go to state 42
    ID              shift and go to state 11
    IF              shift and go to state 96
    MINUS           shift and go to state 91
    NOT             shift and go to state 89
    ARROW           shift and go to state 82
    ICONST          shift and go to state 93
    TRUE            shift and go to state 77
    FALSE           shift and go to state 66
    CCONST          shift and go to state 76
    NULL            shift and go to state 84
    SCONST          shift and go to state 74

    string_element                 shift and go to state 67
    expression                     shift and go to state 102
    discrete_range_mode            shift and go to state 31
    index_mode_list                shift and go to state 163
    operand1                       shift and go to state 69
    literal                        shift and go to state 70
    discrete_mode                  shift and go to state 108
    referenced_location            shift and go to state 71
    character_string_literal       shift and go to state 72
    monadic_operator               shift and go to state 73
    empty_literal                  shift and go to state 75
    discrete_mode_name             shift and go to state 46
    index_mode                     shift and go to state 109
    literal_range                  shift and go to state 110
    integer_mode                   shift and go to state 40
    array_location                 shift and go to state 78
    operand4                       shift and go to state 79
    integer_literal                shift and go to state 80
    string_slice                   shift and go to state 81
    operand3                       shift and go to state 83
    identifier                     shift and go to state 111
    primitive_value                shift and go to state 86
    lower_bound                    shift and go to state 104
    operand2                       shift and go to state 87
    conditional_expression         shift and go to state 88
    location                       shift and go to state 90
    character_mode                 shift and go to state 37
    character_literal              shift and go to state 94
    dereferenced_reference         shift and go to state 92
    boolean_mode                   shift and go to state 44
    array_slice                    shift and go to state 95
    boolean_literal                shift and go to state 97
    operand0                       shift and go to state 98
    array_element                  shift and go to state 99

state 147

    (39) discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .

    LPAREN          reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    COMMA           reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    RBRACKET        reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    ASSIGN          reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    SEMI            reduce using rule 39 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)


state 148

    (83) operand1 -> operand1 operator2 operand2 .
    (85) operand2 -> operand2 . arithmetic_multiplicative_operator operand3
    (91) arithmetic_multiplicative_operator -> . TIMES
    (92) arithmetic_multiplicative_operator -> . DIVIDE
    (93) arithmetic_multiplicative_operator -> . MODULO

    PLUS            reduce using rule 83 (operand1 -> operand1 operator2 operand2 .)
    MINUS           reduce using rule 83 (operand1 -> operand1 operator2 operand2 .)
    CONCAT          reduce using rule 83 (operand1 -> operand1 operator2 operand2 .)
    AND             reduce using rule 83 (operand1 -> operand1 operator2 operand2 .)
    OR              reduce using rule 83 (operand1 -> operand1 operator2 operand2 .)
    EQUAL           reduce using rule 83 (operand1 -> operand1 operator2 operand2 .)
    NOTEQ           reduce using rule 83 (operand1 -> operand1 operator2 operand2 .)
    GREATER         reduce using rule 83 (operand1 -> operand1 operator2 operand2 .)
    GTEQUAL         reduce using rule 83 (operand1 -> operand1 operator2 operand2 .)
    LESS            reduce using rule 83 (operand1 -> operand1 operator2 operand2 .)
    LTEQUAL         reduce using rule 83 (operand1 -> operand1 operator2 operand2 .)
    IN              reduce using rule 83 (operand1 -> operand1 operator2 operand2 .)
    THEN            reduce using rule 83 (operand1 -> operand1 operator2 operand2 .)
    COLON           reduce using rule 83 (operand1 -> operand1 operator2 operand2 .)
    RPAREN          reduce using rule 83 (operand1 -> operand1 operator2 operand2 .)
    COMMA           reduce using rule 83 (operand1 -> operand1 operator2 operand2 .)
    RBRACKET        reduce using rule 83 (operand1 -> operand1 operator2 operand2 .)
    SEMI            reduce using rule 83 (operand1 -> operand1 operator2 operand2 .)
    LBRACKET        reduce using rule 83 (operand1 -> operand1 operator2 operand2 .)
    ELSE            reduce using rule 83 (operand1 -> operand1 operator2 operand2 .)
    ELSIF           reduce using rule 83 (operand1 -> operand1 operator2 operand2 .)
    FI              reduce using rule 83 (operand1 -> operand1 operator2 operand2 .)
    TIMES           shift and go to state 128
    DIVIDE          shift and go to state 125
    MODULO          shift and go to state 127

    arithmetic_multiplicative_operator shift and go to state 126

state 149

    (67) array_element -> array_location LBRACKET expression_list . RBRACKET

    RBRACKET        shift and go to state 164


state 150

    (68) expression_list -> expression .
    (69) expression_list -> expression . COMMA expression_list
    (42) lower_bound -> expression .

    RBRACKET        reduce using rule 68 (expression_list -> expression .)
    COMMA           shift and go to state 165
    COLON           reduce using rule 42 (lower_bound -> expression .)


state 151

    (70) array_slice -> array_location LBRACKET lower_bound . COLON upper_bound RBRACKET

    COLON           shift and go to state 166


state 152

    (63) start_element -> expression .
    (65) left_element -> expression .

    LBRACKET        reduce using rule 63 (start_element -> expression .)
    COLON           reduce using rule 65 (left_element -> expression .)


state 153

    (64) string_slice -> identifier LBRACKET left_element . COLON right_element RBRACKET

    COLON           shift and go to state 167


state 154

    (62) string_element -> identifier LBRACKET start_element . LBRACKET

    LBRACKET        shift and go to state 168


state 155

    (85) operand2 -> operand2 arithmetic_multiplicative_operator operand3 .

    TIMES           reduce using rule 85 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    DIVIDE          reduce using rule 85 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    MODULO          reduce using rule 85 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    PLUS            reduce using rule 85 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    MINUS           reduce using rule 85 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    CONCAT          reduce using rule 85 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    AND             reduce using rule 85 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    OR              reduce using rule 85 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    EQUAL           reduce using rule 85 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    NOTEQ           reduce using rule 85 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    GREATER         reduce using rule 85 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    GTEQUAL         reduce using rule 85 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    LESS            reduce using rule 85 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    LTEQUAL         reduce using rule 85 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    IN              reduce using rule 85 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    FI              reduce using rule 85 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    COMMA           reduce using rule 85 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    SEMI            reduce using rule 85 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    COLON           reduce using rule 85 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    RBRACKET        reduce using rule 85 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    THEN            reduce using rule 85 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    RPAREN          reduce using rule 85 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    LBRACKET        reduce using rule 85 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    ELSE            reduce using rule 85 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    ELSIF           reduce using rule 85 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)


state 156

    (74) conditional_expression -> IF expression then_expression . else_expression FI
    (75) conditional_expression -> IF expression then_expression . elsif_expression else_expression FI
    (77) else_expression -> . ELSE expression
    (78) elsif_expression -> . ELSIF expression then_expression
    (79) elsif_expression -> . elsif_expression ELSIF expression then_expression

    ELSE            shift and go to state 169
    ELSIF           shift and go to state 171

    elsif_expression               shift and go to state 170
    else_expression                shift and go to state 172

state 157

    (76) then_expression -> THEN . expression
    (72) expression -> . operand0
    (73) expression -> . conditional_expression
    (80) operand0 -> . operand1
    (81) operand0 -> . operand0 operator1 operand1
    (74) conditional_expression -> . IF expression then_expression else_expression FI
    (75) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (82) operand1 -> . operand2
    (83) operand1 -> . operand1 operator2 operand2
    (84) operand2 -> . operand3
    (85) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (86) operand3 -> . monadic_operator operand4
    (87) operand3 -> . operand4
    (94) monadic_operator -> . MINUS
    (95) monadic_operator -> . NOT
    (88) operand4 -> . array_location
    (89) operand4 -> . referenced_location
    (90) operand4 -> . primitive_value
    (71) array_location -> . location
    (96) referenced_location -> . ARROW array_location
    (113) primitive_value -> . literal
    (55) location -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (114) literal -> . integer_literal
    (115) literal -> . boolean_literal
    (116) literal -> . character_literal
    (117) literal -> . empty_literal
    (118) literal -> . character_string_literal
    (21) identifier -> . ID
    (61) dereferenced_reference -> . array_location ARROW
    (62) string_element -> . identifier LBRACKET start_element LBRACKET
    (64) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (67) array_element -> . array_location LBRACKET expression_list RBRACKET
    (70) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (119) integer_literal -> . ICONST
    (120) boolean_literal -> . TRUE
    (121) boolean_literal -> . FALSE
    (122) character_literal -> . CCONST
    (123) empty_literal -> . NULL
    (124) character_string_literal -> . SCONST

    IF              shift and go to state 96
    MINUS           shift and go to state 91
    NOT             shift and go to state 89
    ARROW           shift and go to state 82
    ID              shift and go to state 11
    ICONST          shift and go to state 93
    TRUE            shift and go to state 77
    FALSE           shift and go to state 66
    CCONST          shift and go to state 76
    NULL            shift and go to state 84
    SCONST          shift and go to state 74

    operand3                       shift and go to state 83
    string_element                 shift and go to state 67
    expression                     shift and go to state 173
    identifier                     shift and go to state 85
    primitive_value                shift and go to state 86
    operand1                       shift and go to state 69
    operand2                       shift and go to state 87
    conditional_expression         shift and go to state 88
    literal                        shift and go to state 70
    location                       shift and go to state 90
    referenced_location            shift and go to state 71
    character_string_literal       shift and go to state 72
    dereferenced_reference         shift and go to state 92
    empty_literal                  shift and go to state 75
    array_slice                    shift and go to state 95
    character_literal              shift and go to state 94
    boolean_literal                shift and go to state 97
    monadic_operator               shift and go to state 73
    array_location                 shift and go to state 78
    operand0                       shift and go to state 98
    operand4                       shift and go to state 79
    integer_literal                shift and go to state 80
    array_element                  shift and go to state 99
    string_slice                   shift and go to state 81

state 158

    (81) operand0 -> operand0 operator1 operand1 .
    (83) operand1 -> operand1 . operator2 operand2
    (99) operator2 -> . arithmetic_additive_operator
    (100) operator2 -> . string_concatenation_operator
    (101) arithmetic_additive_operator -> . PLUS
    (102) arithmetic_additive_operator -> . MINUS
    (103) string_concatenation_operator -> . CONCAT

    AND             reduce using rule 81 (operand0 -> operand0 operator1 operand1 .)
    OR              reduce using rule 81 (operand0 -> operand0 operator1 operand1 .)
    EQUAL           reduce using rule 81 (operand0 -> operand0 operator1 operand1 .)
    NOTEQ           reduce using rule 81 (operand0 -> operand0 operator1 operand1 .)
    GREATER         reduce using rule 81 (operand0 -> operand0 operator1 operand1 .)
    GTEQUAL         reduce using rule 81 (operand0 -> operand0 operator1 operand1 .)
    LESS            reduce using rule 81 (operand0 -> operand0 operator1 operand1 .)
    LTEQUAL         reduce using rule 81 (operand0 -> operand0 operator1 operand1 .)
    IN              reduce using rule 81 (operand0 -> operand0 operator1 operand1 .)
    RBRACKET        reduce using rule 81 (operand0 -> operand0 operator1 operand1 .)
    COLON           reduce using rule 81 (operand0 -> operand0 operator1 operand1 .)
    COMMA           reduce using rule 81 (operand0 -> operand0 operator1 operand1 .)
    SEMI            reduce using rule 81 (operand0 -> operand0 operator1 operand1 .)
    FI              reduce using rule 81 (operand0 -> operand0 operator1 operand1 .)
    RPAREN          reduce using rule 81 (operand0 -> operand0 operator1 operand1 .)
    THEN            reduce using rule 81 (operand0 -> operand0 operator1 operand1 .)
    ELSE            reduce using rule 81 (operand0 -> operand0 operator1 operand1 .)
    ELSIF           reduce using rule 81 (operand0 -> operand0 operator1 operand1 .)
    LBRACKET        reduce using rule 81 (operand0 -> operand0 operator1 operand1 .)
    PLUS            shift and go to state 114
    MINUS           shift and go to state 116
    CONCAT          shift and go to state 117

    string_concatenation_operator  shift and go to state 115
    operator2                      shift and go to state 118
    arithmetic_additive_operator   shift and go to state 119

state 159

    (43) upper_bound -> expression .

    RPAREN          reduce using rule 43 (upper_bound -> expression .)
    COMMA           reduce using rule 43 (upper_bound -> expression .)
    RBRACKET        reduce using rule 43 (upper_bound -> expression .)


state 160

    (41) literal_range -> lower_bound COLON upper_bound .

    COMMA           reduce using rule 41 (literal_range -> lower_bound COLON upper_bound .)
    RBRACKET        reduce using rule 41 (literal_range -> lower_bound COLON upper_bound .)
    RPAREN          reduce using rule 41 (literal_range -> lower_bound COLON upper_bound .)


state 161

    (49) array_mode -> ARRAY LBRACKET index_mode_list RBRACKET element_mode .

    ASSIGN          reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode_list RBRACKET element_mode .)
    COMMA           reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode_list RBRACKET element_mode .)
    SEMI            reduce using rule 49 (array_mode -> ARRAY LBRACKET index_mode_list RBRACKET element_mode .)


state 162

    (54) element_mode -> mode .

    ASSIGN          reduce using rule 54 (element_mode -> mode .)
    COMMA           reduce using rule 54 (element_mode -> mode .)
    SEMI            reduce using rule 54 (element_mode -> mode .)


state 163

    (51) index_mode_list -> index_mode COMMA index_mode_list .

    RBRACKET        reduce using rule 51 (index_mode_list -> index_mode COMMA index_mode_list .)


state 164

    (67) array_element -> array_location LBRACKET expression_list RBRACKET .

    ARROW           reduce using rule 67 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    LBRACKET        reduce using rule 67 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    TIMES           reduce using rule 67 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    DIVIDE          reduce using rule 67 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    MODULO          reduce using rule 67 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    PLUS            reduce using rule 67 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    MINUS           reduce using rule 67 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    CONCAT          reduce using rule 67 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    AND             reduce using rule 67 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    OR              reduce using rule 67 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    EQUAL           reduce using rule 67 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    NOTEQ           reduce using rule 67 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    GREATER         reduce using rule 67 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    GTEQUAL         reduce using rule 67 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    LESS            reduce using rule 67 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    LTEQUAL         reduce using rule 67 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    IN              reduce using rule 67 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    COLON           reduce using rule 67 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    COMMA           reduce using rule 67 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    SEMI            reduce using rule 67 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    FI              reduce using rule 67 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    RPAREN          reduce using rule 67 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    RBRACKET        reduce using rule 67 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    THEN            reduce using rule 67 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    ELSE            reduce using rule 67 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    ELSIF           reduce using rule 67 (array_element -> array_location LBRACKET expression_list RBRACKET .)


state 165

    (69) expression_list -> expression COMMA . expression_list
    (68) expression_list -> . expression
    (69) expression_list -> . expression COMMA expression_list
    (72) expression -> . operand0
    (73) expression -> . conditional_expression
    (80) operand0 -> . operand1
    (81) operand0 -> . operand0 operator1 operand1
    (74) conditional_expression -> . IF expression then_expression else_expression FI
    (75) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (82) operand1 -> . operand2
    (83) operand1 -> . operand1 operator2 operand2
    (84) operand2 -> . operand3
    (85) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (86) operand3 -> . monadic_operator operand4
    (87) operand3 -> . operand4
    (94) monadic_operator -> . MINUS
    (95) monadic_operator -> . NOT
    (88) operand4 -> . array_location
    (89) operand4 -> . referenced_location
    (90) operand4 -> . primitive_value
    (71) array_location -> . location
    (96) referenced_location -> . ARROW array_location
    (113) primitive_value -> . literal
    (55) location -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (114) literal -> . integer_literal
    (115) literal -> . boolean_literal
    (116) literal -> . character_literal
    (117) literal -> . empty_literal
    (118) literal -> . character_string_literal
    (21) identifier -> . ID
    (61) dereferenced_reference -> . array_location ARROW
    (62) string_element -> . identifier LBRACKET start_element LBRACKET
    (64) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (67) array_element -> . array_location LBRACKET expression_list RBRACKET
    (70) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (119) integer_literal -> . ICONST
    (120) boolean_literal -> . TRUE
    (121) boolean_literal -> . FALSE
    (122) character_literal -> . CCONST
    (123) empty_literal -> . NULL
    (124) character_string_literal -> . SCONST

    IF              shift and go to state 96
    MINUS           shift and go to state 91
    NOT             shift and go to state 89
    ARROW           shift and go to state 82
    ID              shift and go to state 11
    ICONST          shift and go to state 93
    TRUE            shift and go to state 77
    FALSE           shift and go to state 66
    CCONST          shift and go to state 76
    NULL            shift and go to state 84
    SCONST          shift and go to state 74

    operand3                       shift and go to state 83
    string_element                 shift and go to state 67
    expression_list                shift and go to state 174
    expression                     shift and go to state 175
    identifier                     shift and go to state 85
    primitive_value                shift and go to state 86
    operand1                       shift and go to state 69
    operand2                       shift and go to state 87
    conditional_expression         shift and go to state 88
    literal                        shift and go to state 70
    location                       shift and go to state 90
    referenced_location            shift and go to state 71
    character_string_literal       shift and go to state 72
    empty_literal                  shift and go to state 75
    array_slice                    shift and go to state 95
    character_literal              shift and go to state 94
    boolean_literal                shift and go to state 97
    monadic_operator               shift and go to state 73
    array_location                 shift and go to state 78
    operand0                       shift and go to state 98
    operand4                       shift and go to state 79
    integer_literal                shift and go to state 80
    dereferenced_reference         shift and go to state 92
    array_element                  shift and go to state 99
    string_slice                   shift and go to state 81

state 166

    (70) array_slice -> array_location LBRACKET lower_bound COLON . upper_bound RBRACKET
    (43) upper_bound -> . expression
    (72) expression -> . operand0
    (73) expression -> . conditional_expression
    (80) operand0 -> . operand1
    (81) operand0 -> . operand0 operator1 operand1
    (74) conditional_expression -> . IF expression then_expression else_expression FI
    (75) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (82) operand1 -> . operand2
    (83) operand1 -> . operand1 operator2 operand2
    (84) operand2 -> . operand3
    (85) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (86) operand3 -> . monadic_operator operand4
    (87) operand3 -> . operand4
    (94) monadic_operator -> . MINUS
    (95) monadic_operator -> . NOT
    (88) operand4 -> . array_location
    (89) operand4 -> . referenced_location
    (90) operand4 -> . primitive_value
    (71) array_location -> . location
    (96) referenced_location -> . ARROW array_location
    (113) primitive_value -> . literal
    (55) location -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (114) literal -> . integer_literal
    (115) literal -> . boolean_literal
    (116) literal -> . character_literal
    (117) literal -> . empty_literal
    (118) literal -> . character_string_literal
    (21) identifier -> . ID
    (61) dereferenced_reference -> . array_location ARROW
    (62) string_element -> . identifier LBRACKET start_element LBRACKET
    (64) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (67) array_element -> . array_location LBRACKET expression_list RBRACKET
    (70) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (119) integer_literal -> . ICONST
    (120) boolean_literal -> . TRUE
    (121) boolean_literal -> . FALSE
    (122) character_literal -> . CCONST
    (123) empty_literal -> . NULL
    (124) character_string_literal -> . SCONST

    IF              shift and go to state 96
    MINUS           shift and go to state 91
    NOT             shift and go to state 89
    ARROW           shift and go to state 82
    ID              shift and go to state 11
    ICONST          shift and go to state 93
    TRUE            shift and go to state 77
    FALSE           shift and go to state 66
    CCONST          shift and go to state 76
    NULL            shift and go to state 84
    SCONST          shift and go to state 74

    operand3                       shift and go to state 83
    string_element                 shift and go to state 67
    identifier                     shift and go to state 85
    primitive_value                shift and go to state 86
    operand1                       shift and go to state 69
    operand2                       shift and go to state 87
    conditional_expression         shift and go to state 88
    literal                        shift and go to state 70
    location                       shift and go to state 90
    referenced_location            shift and go to state 71
    character_string_literal       shift and go to state 72
    expression                     shift and go to state 159
    empty_literal                  shift and go to state 75
    upper_bound                    shift and go to state 176
    array_slice                    shift and go to state 95
    character_literal              shift and go to state 94
    boolean_literal                shift and go to state 97
    monadic_operator               shift and go to state 73
    array_location                 shift and go to state 78
    operand0                       shift and go to state 98
    operand4                       shift and go to state 79
    integer_literal                shift and go to state 80
    dereferenced_reference         shift and go to state 92
    array_element                  shift and go to state 99
    string_slice                   shift and go to state 81

state 167

    (64) string_slice -> identifier LBRACKET left_element COLON . right_element RBRACKET
    (66) right_element -> . expression
    (72) expression -> . operand0
    (73) expression -> . conditional_expression
    (80) operand0 -> . operand1
    (81) operand0 -> . operand0 operator1 operand1
    (74) conditional_expression -> . IF expression then_expression else_expression FI
    (75) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (82) operand1 -> . operand2
    (83) operand1 -> . operand1 operator2 operand2
    (84) operand2 -> . operand3
    (85) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (86) operand3 -> . monadic_operator operand4
    (87) operand3 -> . operand4
    (94) monadic_operator -> . MINUS
    (95) monadic_operator -> . NOT
    (88) operand4 -> . array_location
    (89) operand4 -> . referenced_location
    (90) operand4 -> . primitive_value
    (71) array_location -> . location
    (96) referenced_location -> . ARROW array_location
    (113) primitive_value -> . literal
    (55) location -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (114) literal -> . integer_literal
    (115) literal -> . boolean_literal
    (116) literal -> . character_literal
    (117) literal -> . empty_literal
    (118) literal -> . character_string_literal
    (21) identifier -> . ID
    (61) dereferenced_reference -> . array_location ARROW
    (62) string_element -> . identifier LBRACKET start_element LBRACKET
    (64) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (67) array_element -> . array_location LBRACKET expression_list RBRACKET
    (70) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (119) integer_literal -> . ICONST
    (120) boolean_literal -> . TRUE
    (121) boolean_literal -> . FALSE
    (122) character_literal -> . CCONST
    (123) empty_literal -> . NULL
    (124) character_string_literal -> . SCONST

    IF              shift and go to state 96
    MINUS           shift and go to state 91
    NOT             shift and go to state 89
    ARROW           shift and go to state 82
    ID              shift and go to state 11
    ICONST          shift and go to state 93
    TRUE            shift and go to state 77
    FALSE           shift and go to state 66
    CCONST          shift and go to state 76
    NULL            shift and go to state 84
    SCONST          shift and go to state 74

    operand3                       shift and go to state 83
    string_element                 shift and go to state 67
    expression                     shift and go to state 177
    identifier                     shift and go to state 85
    primitive_value                shift and go to state 86
    operand1                       shift and go to state 69
    operand2                       shift and go to state 87
    conditional_expression         shift and go to state 88
    literal                        shift and go to state 70
    location                       shift and go to state 90
    referenced_location            shift and go to state 71
    character_string_literal       shift and go to state 72
    empty_literal                  shift and go to state 75
    array_slice                    shift and go to state 95
    character_literal              shift and go to state 94
    boolean_literal                shift and go to state 97
    monadic_operator               shift and go to state 73
    right_element                  shift and go to state 178
    array_location                 shift and go to state 78
    operand0                       shift and go to state 98
    operand4                       shift and go to state 79
    integer_literal                shift and go to state 80
    dereferenced_reference         shift and go to state 92
    array_element                  shift and go to state 99
    string_slice                   shift and go to state 81

state 168

    (62) string_element -> identifier LBRACKET start_element LBRACKET .

    ARROW           reduce using rule 62 (string_element -> identifier LBRACKET start_element LBRACKET .)
    LBRACKET        reduce using rule 62 (string_element -> identifier LBRACKET start_element LBRACKET .)
    TIMES           reduce using rule 62 (string_element -> identifier LBRACKET start_element LBRACKET .)
    DIVIDE          reduce using rule 62 (string_element -> identifier LBRACKET start_element LBRACKET .)
    MODULO          reduce using rule 62 (string_element -> identifier LBRACKET start_element LBRACKET .)
    PLUS            reduce using rule 62 (string_element -> identifier LBRACKET start_element LBRACKET .)
    MINUS           reduce using rule 62 (string_element -> identifier LBRACKET start_element LBRACKET .)
    CONCAT          reduce using rule 62 (string_element -> identifier LBRACKET start_element LBRACKET .)
    AND             reduce using rule 62 (string_element -> identifier LBRACKET start_element LBRACKET .)
    OR              reduce using rule 62 (string_element -> identifier LBRACKET start_element LBRACKET .)
    EQUAL           reduce using rule 62 (string_element -> identifier LBRACKET start_element LBRACKET .)
    NOTEQ           reduce using rule 62 (string_element -> identifier LBRACKET start_element LBRACKET .)
    GREATER         reduce using rule 62 (string_element -> identifier LBRACKET start_element LBRACKET .)
    GTEQUAL         reduce using rule 62 (string_element -> identifier LBRACKET start_element LBRACKET .)
    LESS            reduce using rule 62 (string_element -> identifier LBRACKET start_element LBRACKET .)
    LTEQUAL         reduce using rule 62 (string_element -> identifier LBRACKET start_element LBRACKET .)
    IN              reduce using rule 62 (string_element -> identifier LBRACKET start_element LBRACKET .)
    COMMA           reduce using rule 62 (string_element -> identifier LBRACKET start_element LBRACKET .)
    SEMI            reduce using rule 62 (string_element -> identifier LBRACKET start_element LBRACKET .)
    COLON           reduce using rule 62 (string_element -> identifier LBRACKET start_element LBRACKET .)
    THEN            reduce using rule 62 (string_element -> identifier LBRACKET start_element LBRACKET .)
    RBRACKET        reduce using rule 62 (string_element -> identifier LBRACKET start_element LBRACKET .)
    RPAREN          reduce using rule 62 (string_element -> identifier LBRACKET start_element LBRACKET .)
    ELSE            reduce using rule 62 (string_element -> identifier LBRACKET start_element LBRACKET .)
    ELSIF           reduce using rule 62 (string_element -> identifier LBRACKET start_element LBRACKET .)
    FI              reduce using rule 62 (string_element -> identifier LBRACKET start_element LBRACKET .)


state 169

    (77) else_expression -> ELSE . expression
    (72) expression -> . operand0
    (73) expression -> . conditional_expression
    (80) operand0 -> . operand1
    (81) operand0 -> . operand0 operator1 operand1
    (74) conditional_expression -> . IF expression then_expression else_expression FI
    (75) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (82) operand1 -> . operand2
    (83) operand1 -> . operand1 operator2 operand2
    (84) operand2 -> . operand3
    (85) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (86) operand3 -> . monadic_operator operand4
    (87) operand3 -> . operand4
    (94) monadic_operator -> . MINUS
    (95) monadic_operator -> . NOT
    (88) operand4 -> . array_location
    (89) operand4 -> . referenced_location
    (90) operand4 -> . primitive_value
    (71) array_location -> . location
    (96) referenced_location -> . ARROW array_location
    (113) primitive_value -> . literal
    (55) location -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (114) literal -> . integer_literal
    (115) literal -> . boolean_literal
    (116) literal -> . character_literal
    (117) literal -> . empty_literal
    (118) literal -> . character_string_literal
    (21) identifier -> . ID
    (61) dereferenced_reference -> . array_location ARROW
    (62) string_element -> . identifier LBRACKET start_element LBRACKET
    (64) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (67) array_element -> . array_location LBRACKET expression_list RBRACKET
    (70) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (119) integer_literal -> . ICONST
    (120) boolean_literal -> . TRUE
    (121) boolean_literal -> . FALSE
    (122) character_literal -> . CCONST
    (123) empty_literal -> . NULL
    (124) character_string_literal -> . SCONST

    IF              shift and go to state 96
    MINUS           shift and go to state 91
    NOT             shift and go to state 89
    ARROW           shift and go to state 82
    ID              shift and go to state 11
    ICONST          shift and go to state 93
    TRUE            shift and go to state 77
    FALSE           shift and go to state 66
    CCONST          shift and go to state 76
    NULL            shift and go to state 84
    SCONST          shift and go to state 74

    operand3                       shift and go to state 83
    string_element                 shift and go to state 67
    expression                     shift and go to state 179
    identifier                     shift and go to state 85
    primitive_value                shift and go to state 86
    operand1                       shift and go to state 69
    operand2                       shift and go to state 87
    conditional_expression         shift and go to state 88
    literal                        shift and go to state 70
    location                       shift and go to state 90
    referenced_location            shift and go to state 71
    character_string_literal       shift and go to state 72
    dereferenced_reference         shift and go to state 92
    empty_literal                  shift and go to state 75
    array_slice                    shift and go to state 95
    character_literal              shift and go to state 94
    boolean_literal                shift and go to state 97
    monadic_operator               shift and go to state 73
    array_location                 shift and go to state 78
    operand0                       shift and go to state 98
    operand4                       shift and go to state 79
    integer_literal                shift and go to state 80
    array_element                  shift and go to state 99
    string_slice                   shift and go to state 81

state 170

    (75) conditional_expression -> IF expression then_expression elsif_expression . else_expression FI
    (79) elsif_expression -> elsif_expression . ELSIF expression then_expression
    (77) else_expression -> . ELSE expression

    ELSIF           shift and go to state 180
    ELSE            shift and go to state 169

    else_expression                shift and go to state 181

state 171

    (78) elsif_expression -> ELSIF . expression then_expression
    (72) expression -> . operand0
    (73) expression -> . conditional_expression
    (80) operand0 -> . operand1
    (81) operand0 -> . operand0 operator1 operand1
    (74) conditional_expression -> . IF expression then_expression else_expression FI
    (75) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (82) operand1 -> . operand2
    (83) operand1 -> . operand1 operator2 operand2
    (84) operand2 -> . operand3
    (85) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (86) operand3 -> . monadic_operator operand4
    (87) operand3 -> . operand4
    (94) monadic_operator -> . MINUS
    (95) monadic_operator -> . NOT
    (88) operand4 -> . array_location
    (89) operand4 -> . referenced_location
    (90) operand4 -> . primitive_value
    (71) array_location -> . location
    (96) referenced_location -> . ARROW array_location
    (113) primitive_value -> . literal
    (55) location -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (114) literal -> . integer_literal
    (115) literal -> . boolean_literal
    (116) literal -> . character_literal
    (117) literal -> . empty_literal
    (118) literal -> . character_string_literal
    (21) identifier -> . ID
    (61) dereferenced_reference -> . array_location ARROW
    (62) string_element -> . identifier LBRACKET start_element LBRACKET
    (64) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (67) array_element -> . array_location LBRACKET expression_list RBRACKET
    (70) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (119) integer_literal -> . ICONST
    (120) boolean_literal -> . TRUE
    (121) boolean_literal -> . FALSE
    (122) character_literal -> . CCONST
    (123) empty_literal -> . NULL
    (124) character_string_literal -> . SCONST

    IF              shift and go to state 96
    MINUS           shift and go to state 91
    NOT             shift and go to state 89
    ARROW           shift and go to state 82
    ID              shift and go to state 11
    ICONST          shift and go to state 93
    TRUE            shift and go to state 77
    FALSE           shift and go to state 66
    CCONST          shift and go to state 76
    NULL            shift and go to state 84
    SCONST          shift and go to state 74

    operand3                       shift and go to state 83
    string_element                 shift and go to state 67
    expression                     shift and go to state 182
    identifier                     shift and go to state 85
    primitive_value                shift and go to state 86
    operand1                       shift and go to state 69
    operand2                       shift and go to state 87
    conditional_expression         shift and go to state 88
    literal                        shift and go to state 70
    location                       shift and go to state 90
    referenced_location            shift and go to state 71
    character_string_literal       shift and go to state 72
    dereferenced_reference         shift and go to state 92
    empty_literal                  shift and go to state 75
    array_slice                    shift and go to state 95
    character_literal              shift and go to state 94
    boolean_literal                shift and go to state 97
    monadic_operator               shift and go to state 73
    array_location                 shift and go to state 78
    operand0                       shift and go to state 98
    operand4                       shift and go to state 79
    integer_literal                shift and go to state 80
    array_element                  shift and go to state 99
    string_slice                   shift and go to state 81

state 172

    (74) conditional_expression -> IF expression then_expression else_expression . FI

    FI              shift and go to state 183


state 173

    (76) then_expression -> THEN expression .

    ELSIF           reduce using rule 76 (then_expression -> THEN expression .)
    ELSE            reduce using rule 76 (then_expression -> THEN expression .)


state 174

    (69) expression_list -> expression COMMA expression_list .

    RBRACKET        reduce using rule 69 (expression_list -> expression COMMA expression_list .)


state 175

    (68) expression_list -> expression .
    (69) expression_list -> expression . COMMA expression_list

    RBRACKET        reduce using rule 68 (expression_list -> expression .)
    COMMA           shift and go to state 165


state 176

    (70) array_slice -> array_location LBRACKET lower_bound COLON upper_bound . RBRACKET

    RBRACKET        shift and go to state 184


state 177

    (66) right_element -> expression .

    RBRACKET        reduce using rule 66 (right_element -> expression .)


state 178

    (64) string_slice -> identifier LBRACKET left_element COLON right_element . RBRACKET

    RBRACKET        shift and go to state 185


state 179

    (77) else_expression -> ELSE expression .

    FI              reduce using rule 77 (else_expression -> ELSE expression .)


state 180

    (79) elsif_expression -> elsif_expression ELSIF . expression then_expression
    (72) expression -> . operand0
    (73) expression -> . conditional_expression
    (80) operand0 -> . operand1
    (81) operand0 -> . operand0 operator1 operand1
    (74) conditional_expression -> . IF expression then_expression else_expression FI
    (75) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (82) operand1 -> . operand2
    (83) operand1 -> . operand1 operator2 operand2
    (84) operand2 -> . operand3
    (85) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (86) operand3 -> . monadic_operator operand4
    (87) operand3 -> . operand4
    (94) monadic_operator -> . MINUS
    (95) monadic_operator -> . NOT
    (88) operand4 -> . array_location
    (89) operand4 -> . referenced_location
    (90) operand4 -> . primitive_value
    (71) array_location -> . location
    (96) referenced_location -> . ARROW array_location
    (113) primitive_value -> . literal
    (55) location -> . identifier
    (56) location -> . dereferenced_reference
    (57) location -> . string_element
    (58) location -> . string_slice
    (59) location -> . array_element
    (60) location -> . array_slice
    (114) literal -> . integer_literal
    (115) literal -> . boolean_literal
    (116) literal -> . character_literal
    (117) literal -> . empty_literal
    (118) literal -> . character_string_literal
    (21) identifier -> . ID
    (61) dereferenced_reference -> . array_location ARROW
    (62) string_element -> . identifier LBRACKET start_element LBRACKET
    (64) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (67) array_element -> . array_location LBRACKET expression_list RBRACKET
    (70) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (119) integer_literal -> . ICONST
    (120) boolean_literal -> . TRUE
    (121) boolean_literal -> . FALSE
    (122) character_literal -> . CCONST
    (123) empty_literal -> . NULL
    (124) character_string_literal -> . SCONST

    IF              shift and go to state 96
    MINUS           shift and go to state 91
    NOT             shift and go to state 89
    ARROW           shift and go to state 82
    ID              shift and go to state 11
    ICONST          shift and go to state 93
    TRUE            shift and go to state 77
    FALSE           shift and go to state 66
    CCONST          shift and go to state 76
    NULL            shift and go to state 84
    SCONST          shift and go to state 74

    operand3                       shift and go to state 83
    string_element                 shift and go to state 67
    expression                     shift and go to state 186
    identifier                     shift and go to state 85
    primitive_value                shift and go to state 86
    operand1                       shift and go to state 69
    operand2                       shift and go to state 87
    conditional_expression         shift and go to state 88
    literal                        shift and go to state 70
    location                       shift and go to state 90
    referenced_location            shift and go to state 71
    character_string_literal       shift and go to state 72
    dereferenced_reference         shift and go to state 92
    empty_literal                  shift and go to state 75
    array_slice                    shift and go to state 95
    character_literal              shift and go to state 94
    boolean_literal                shift and go to state 97
    monadic_operator               shift and go to state 73
    array_location                 shift and go to state 78
    operand0                       shift and go to state 98
    operand4                       shift and go to state 79
    integer_literal                shift and go to state 80
    array_element                  shift and go to state 99
    string_slice                   shift and go to state 81

state 181

    (75) conditional_expression -> IF expression then_expression elsif_expression else_expression . FI

    FI              shift and go to state 187


state 182

    (78) elsif_expression -> ELSIF expression . then_expression
    (76) then_expression -> . THEN expression

    THEN            shift and go to state 157

    then_expression                shift and go to state 188

state 183

    (74) conditional_expression -> IF expression then_expression else_expression FI .

    ELSE            reduce using rule 74 (conditional_expression -> IF expression then_expression else_expression FI .)
    ELSIF           reduce using rule 74 (conditional_expression -> IF expression then_expression else_expression FI .)
    COLON           reduce using rule 74 (conditional_expression -> IF expression then_expression else_expression FI .)
    FI              reduce using rule 74 (conditional_expression -> IF expression then_expression else_expression FI .)
    COMMA           reduce using rule 74 (conditional_expression -> IF expression then_expression else_expression FI .)
    SEMI            reduce using rule 74 (conditional_expression -> IF expression then_expression else_expression FI .)
    RPAREN          reduce using rule 74 (conditional_expression -> IF expression then_expression else_expression FI .)
    RBRACKET        reduce using rule 74 (conditional_expression -> IF expression then_expression else_expression FI .)
    THEN            reduce using rule 74 (conditional_expression -> IF expression then_expression else_expression FI .)
    LBRACKET        reduce using rule 74 (conditional_expression -> IF expression then_expression else_expression FI .)


state 184

    (70) array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .

    ARROW           reduce using rule 70 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    LBRACKET        reduce using rule 70 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    TIMES           reduce using rule 70 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    DIVIDE          reduce using rule 70 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    MODULO          reduce using rule 70 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    PLUS            reduce using rule 70 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    MINUS           reduce using rule 70 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    CONCAT          reduce using rule 70 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    AND             reduce using rule 70 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    OR              reduce using rule 70 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    EQUAL           reduce using rule 70 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    NOTEQ           reduce using rule 70 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    GREATER         reduce using rule 70 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    GTEQUAL         reduce using rule 70 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    LESS            reduce using rule 70 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    LTEQUAL         reduce using rule 70 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    IN              reduce using rule 70 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    FI              reduce using rule 70 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    COMMA           reduce using rule 70 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    SEMI            reduce using rule 70 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    RBRACKET        reduce using rule 70 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    COLON           reduce using rule 70 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    THEN            reduce using rule 70 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    RPAREN          reduce using rule 70 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    ELSE            reduce using rule 70 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    ELSIF           reduce using rule 70 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)


state 185

    (64) string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .

    ARROW           reduce using rule 64 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    LBRACKET        reduce using rule 64 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    TIMES           reduce using rule 64 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    DIVIDE          reduce using rule 64 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    MODULO          reduce using rule 64 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    PLUS            reduce using rule 64 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    MINUS           reduce using rule 64 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    CONCAT          reduce using rule 64 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    AND             reduce using rule 64 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    OR              reduce using rule 64 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    EQUAL           reduce using rule 64 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    NOTEQ           reduce using rule 64 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    GREATER         reduce using rule 64 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    GTEQUAL         reduce using rule 64 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    LESS            reduce using rule 64 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    LTEQUAL         reduce using rule 64 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    IN              reduce using rule 64 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    COLON           reduce using rule 64 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    COMMA           reduce using rule 64 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    SEMI            reduce using rule 64 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    THEN            reduce using rule 64 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    RBRACKET        reduce using rule 64 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    RPAREN          reduce using rule 64 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    ELSE            reduce using rule 64 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    ELSIF           reduce using rule 64 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    FI              reduce using rule 64 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)


state 186

    (79) elsif_expression -> elsif_expression ELSIF expression . then_expression
    (76) then_expression -> . THEN expression

    THEN            shift and go to state 157

    then_expression                shift and go to state 189

state 187

    (75) conditional_expression -> IF expression then_expression elsif_expression else_expression FI .

    ELSE            reduce using rule 75 (conditional_expression -> IF expression then_expression elsif_expression else_expression FI .)
    ELSIF           reduce using rule 75 (conditional_expression -> IF expression then_expression elsif_expression else_expression FI .)
    COLON           reduce using rule 75 (conditional_expression -> IF expression then_expression elsif_expression else_expression FI .)
    FI              reduce using rule 75 (conditional_expression -> IF expression then_expression elsif_expression else_expression FI .)
    COMMA           reduce using rule 75 (conditional_expression -> IF expression then_expression elsif_expression else_expression FI .)
    SEMI            reduce using rule 75 (conditional_expression -> IF expression then_expression elsif_expression else_expression FI .)
    RPAREN          reduce using rule 75 (conditional_expression -> IF expression then_expression elsif_expression else_expression FI .)
    RBRACKET        reduce using rule 75 (conditional_expression -> IF expression then_expression elsif_expression else_expression FI .)
    THEN            reduce using rule 75 (conditional_expression -> IF expression then_expression elsif_expression else_expression FI .)
    LBRACKET        reduce using rule 75 (conditional_expression -> IF expression then_expression elsif_expression else_expression FI .)


state 188

    (78) elsif_expression -> ELSIF expression then_expression .

    ELSIF           reduce using rule 78 (elsif_expression -> ELSIF expression then_expression .)
    ELSE            reduce using rule 78 (elsif_expression -> ELSIF expression then_expression .)


state 189

    (79) elsif_expression -> elsif_expression ELSIF expression then_expression .

    ELSIF           reduce using rule 79 (elsif_expression -> elsif_expression ELSIF expression then_expression .)
    ELSE            reduce using rule 79 (elsif_expression -> elsif_expression ELSIF expression then_expression .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LBRACKET in state 78 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 85 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 111 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 123 resolved as shift

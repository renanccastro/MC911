Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Unused terminals:

<<<<<<< HEAD
    FOR
    RESULT
    LENGTH
    ABS
    RETURN
    DOWN
    LOWER
    NUM
    DO
    LOC
    UPPER
    TO
    BY
    EXIT
    ASC
    PROC
    RETURNS
    PRINT
    OD
    READ
    END
=======
    UPPER
    BY
    ASC
    DOWN
    READ
    LOWER
    LENGTH
    RETURN
    DO
    EXIT
    OD
    RESULT
    PRINT
    ABS
    FOR
    TO
    NUM
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559
    WHILE

Grammar

Rule 0     S' -> program
Rule 1     program -> statement_list
Rule 2     statement_list -> statement statement_nullable
Rule 3     statement_nullable -> statement statement_nullable
Rule 4     statement_nullable -> empty
Rule 5     statement -> declaration_statement
Rule 6     statement -> synonym_statement
Rule 7     statement -> newmode_statement
<<<<<<< HEAD
Rule 8     statement -> action_statement
=======
Rule 8     statement -> procedure_statement
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559
Rule 9     synonym_statement -> SYN synonym_list SEMI
Rule 10    synonym_list -> synonym_definition
Rule 11    synonym_list -> synonym_definition COMMA synonym_list
Rule 12    synonym_definition -> identifier_list mode ASSIGN expression
Rule 13    synonym_definition -> identifier_list ASSIGN expression
Rule 14    declaration_statement -> DCL declaration_list SEMI
Rule 15    declaration_list -> declaration
Rule 16    declaration_list -> declaration COMMA declaration_list
Rule 17    declaration -> identifier_list mode initialization
Rule 18    declaration -> identifier_list mode
Rule 19    initialization -> ASSIGN expression
Rule 20    identifier_list -> identifier
Rule 21    identifier_list -> identifier COMMA identifier_list
Rule 22    identifier -> ID
Rule 23    newmode_statement -> TYPE newmode_list SEMI
Rule 24    newmode_list -> mode_definition
Rule 25    newmode_list -> mode_definition COMMA newmode_list
Rule 26    mode_definition -> identifier_list ASSIGN mode
<<<<<<< HEAD
Rule 27    mode -> mode_name
Rule 28    mode -> discrete_mode
Rule 29    mode -> reference_mode
Rule 30    mode -> composite_mode
Rule 31    mode_name -> identifier
Rule 32    discrete_mode -> integer_mode
Rule 33    discrete_mode -> boolean_mode
Rule 34    discrete_mode -> character_mode
Rule 35    discrete_mode -> discrete_range_mode
Rule 36    discrete_mode_name -> identifier
Rule 37    integer_mode -> INT
Rule 38    boolean_mode -> BOOL
Rule 39    character_mode -> CHAR
Rule 40    discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN
Rule 41    discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN
Rule 42    literal_range -> lower_bound COLON upper_bound
Rule 43    lower_bound -> expression
Rule 44    upper_bound -> expression
Rule 45    reference_mode -> REF mode
Rule 46    composite_mode -> string_mode
Rule 47    composite_mode -> array_mode
Rule 48    string_mode -> CHARS LBRACKET string_length RBRACKET
Rule 49    string_length -> integer_literal
Rule 50    array_mode -> ARRAY LBRACKET index_mode_list RBRACKET element_mode
Rule 51    index_mode_list -> index_mode
Rule 52    index_mode_list -> index_mode COMMA index_mode_list
Rule 53    index_mode -> discrete_mode
Rule 54    index_mode -> literal_range
Rule 55    element_mode -> mode
Rule 56    location -> identifier
Rule 57    location -> dereferenced_reference
Rule 58    location -> string_element
Rule 59    location -> string_slice
Rule 60    location -> array_element
Rule 61    location -> array_slice
Rule 62    dereferenced_reference -> array_location ARROW
Rule 63    string_element -> identifier LBRACKET start_element LBRACKET
Rule 64    start_element -> expression
Rule 65    string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET
Rule 66    left_element -> expression
Rule 67    right_element -> expression
Rule 68    array_element -> array_location LBRACKET expression_list RBRACKET
Rule 69    expression_list -> expression
Rule 70    expression_list -> expression COMMA expression_list
Rule 71    array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET
Rule 72    array_location -> location
Rule 73    expression -> operand0
Rule 74    expression -> conditional_expression
Rule 75    parenthesized_expression -> LPAREN expression RPAREN
Rule 76    conditional_expression -> IF expression then_expression else_expression FI
Rule 77    conditional_expression -> IF expression then_expression elsif_expression else_expression FI
Rule 78    then_expression -> THEN expression
Rule 79    else_expression -> ELSE expression
Rule 80    elsif_expression -> ELSIF expression then_expression
Rule 81    elsif_expression -> elsif_expression ELSIF expression then_expression
Rule 82    operand0 -> operand1
Rule 83    operand0 -> operand0 operator1 operand1
Rule 84    operand1 -> operand2
Rule 85    operand1 -> operand1 operator2 operand2
Rule 86    operand2 -> operand3
Rule 87    operand2 -> operand2 arithmetic_multiplicative_operator operand3
Rule 88    operand3 -> monadic_operator operand4
Rule 89    operand3 -> operand4
Rule 90    operand4 -> array_location
Rule 91    operand4 -> referenced_location
Rule 92    operand4 -> primitive_value
Rule 93    arithmetic_multiplicative_operator -> TIMES
Rule 94    arithmetic_multiplicative_operator -> DIVIDE
Rule 95    arithmetic_multiplicative_operator -> MODULO
Rule 96    monadic_operator -> MINUS
Rule 97    monadic_operator -> NOT
Rule 98    referenced_location -> ARROW array_location
Rule 99    operator1 -> relational_operator
Rule 100   operator1 -> membership_operator
Rule 101   operator2 -> arithmetic_additive_operator
Rule 102   operator2 -> string_concatenation_operator
Rule 103   arithmetic_additive_operator -> PLUS
Rule 104   arithmetic_additive_operator -> MINUS
Rule 105   string_concatenation_operator -> CONCAT
Rule 106   relational_operator -> AND
Rule 107   relational_operator -> OR
Rule 108   relational_operator -> EQUAL
Rule 109   relational_operator -> NOTEQ
Rule 110   relational_operator -> GREATER
Rule 111   relational_operator -> GTEQUAL
Rule 112   relational_operator -> LESS
Rule 113   relational_operator -> LTEQUAL
Rule 114   membership_operator -> IN
Rule 115   primitive_value -> literal
Rule 116   primitive_value -> value_array_element
Rule 117   primitive_value -> value_array_slice
Rule 118   primitive_value -> parenthesized_expression
Rule 119   literal -> integer_literal
Rule 120   literal -> boolean_literal
Rule 121   literal -> character_literal
Rule 122   literal -> empty_literal
Rule 123   literal -> character_string_literal
Rule 124   value_array_element -> primitive_value LBRACKET expression_list RBRACKET
Rule 125   value_array_slice -> primitive_value LBRACKET expression COLON expression RBRACKET
Rule 126   integer_literal -> ICONST
Rule 127   boolean_literal -> TRUE
Rule 128   boolean_literal -> FALSE
Rule 129   character_literal -> CCONST
Rule 130   empty_literal -> NULL
Rule 131   character_string_literal -> SCONST
Rule 132   action_statement -> identifier COLON action
Rule 133   action_statement -> action
Rule 134   action -> bracketed_action
Rule 135   action -> assignment_action
Rule 136   bracketed_action -> if_action
Rule 137   assignment_action -> array_location assigning_operator expression
Rule 138   assigning_operator -> closed_dyadic_operator ASSIGN
Rule 139   assigning_operator -> ASSIGN
Rule 140   closed_dyadic_operator -> arithmetic_additive_operator
Rule 141   closed_dyadic_operator -> arithmetic_multiplicative_operator
Rule 142   closed_dyadic_operator -> string_concatenation_operator
Rule 143   if_action -> IF expression then_clause else_clause FI
Rule 144   if_action -> IF expression then_clause
Rule 145   then_clause -> THEN action_statement_list
Rule 146   else_clause -> ELSE action_statement_list
Rule 147   else_clause -> ELSIF expression then_clause else_clause
Rule 148   else_clause -> ELSIF expression then_clause
Rule 149   action_statement_list -> action_statement action_statement_nullable
Rule 150   action_statement_nullable -> action_statement action_statement_nullable
Rule 151   action_statement_nullable -> empty
Rule 152   empty -> <empty>
=======
Rule 27    procedure_statement -> ID COLON procedure_definition
Rule 28    procedure_definition -> PROC LPAREN formal_parameter_list RPAREN result_spec SEMI statement_nullable END SEMI
Rule 29    procedure_definition -> PROC LPAREN formal_parameter_list RPAREN SEMI statement_nullable END SEMI
Rule 30    formal_parameter_list -> formal_parameter
Rule 31    formal_parameter_list -> formal_parameter COMMA formal_parameter
Rule 32    formal_parameter -> identifier_list mode LOC
Rule 33    formal_parameter -> identifier_list mode
Rule 34    result_spec -> RETURNS LPAREN mode LOC RPAREN
Rule 35    result_spec -> RETURNS LPAREN mode RPAREN
Rule 36    mode -> mode_name
Rule 37    mode -> discrete_mode
Rule 38    mode -> reference_mode
Rule 39    mode -> composite_mode
Rule 40    mode_name -> identifier
Rule 41    discrete_mode -> integer_mode
Rule 42    discrete_mode -> boolean_mode
Rule 43    discrete_mode -> character_mode
Rule 44    discrete_mode -> discrete_range_mode
Rule 45    discrete_mode_name -> identifier
Rule 46    integer_mode -> INT
Rule 47    boolean_mode -> BOOL
Rule 48    character_mode -> CHAR
Rule 49    discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN
Rule 50    discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN
Rule 51    literal_range -> lower_bound COLON upper_bound
Rule 52    lower_bound -> expression
Rule 53    upper_bound -> expression
Rule 54    reference_mode -> REF mode
Rule 55    composite_mode -> string_mode
Rule 56    composite_mode -> array_mode
Rule 57    string_mode -> CHARS LBRACKET string_length RBRACKET
Rule 58    string_length -> integer_literal
Rule 59    array_mode -> ARRAY LBRACKET index_mode_list RBRACKET element_mode
Rule 60    index_mode_list -> index_mode
Rule 61    index_mode_list -> index_mode COMMA index_mode_list
Rule 62    index_mode -> discrete_mode
Rule 63    index_mode -> literal_range
Rule 64    element_mode -> mode
Rule 65    location -> identifier
Rule 66    location -> dereferenced_reference
Rule 67    location -> string_element
Rule 68    location -> string_slice
Rule 69    location -> array_element
Rule 70    location -> array_slice
Rule 71    dereferenced_reference -> array_location ARROW
Rule 72    string_element -> identifier LBRACKET start_element LBRACKET
Rule 73    start_element -> expression
Rule 74    string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET
Rule 75    left_element -> expression
Rule 76    right_element -> expression
Rule 77    array_element -> array_location LBRACKET expression_list RBRACKET
Rule 78    expression_list -> expression
Rule 79    expression_list -> expression COMMA expression_list
Rule 80    array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET
Rule 81    array_location -> location
Rule 82    expression -> operand0
Rule 83    expression -> conditional_expression
Rule 84    conditional_expression -> IF expression then_expression else_expression FI
Rule 85    conditional_expression -> IF expression then_expression elsif_expression else_expression FI
Rule 86    then_expression -> THEN expression
Rule 87    else_expression -> ELSE expression
Rule 88    elsif_expression -> ELSIF expression then_expression
Rule 89    elsif_expression -> elsif_expression ELSIF expression then_expression
Rule 90    operand0 -> operand1
Rule 91    operand0 -> operand0 operator1 operand1
Rule 92    operand1 -> operand2
Rule 93    operand1 -> operand1 operator2 operand2
Rule 94    operand2 -> operand3
Rule 95    operand2 -> operand2 arithmetic_multiplicative_operator operand3
Rule 96    operand3 -> monadic_operator operand4
Rule 97    operand3 -> operand4
Rule 98    operand4 -> array_location
Rule 99    operand4 -> referenced_location
Rule 100   operand4 -> primitive_value
Rule 101   arithmetic_multiplicative_operator -> TIMES
Rule 102   arithmetic_multiplicative_operator -> DIVIDE
Rule 103   arithmetic_multiplicative_operator -> MODULO
Rule 104   monadic_operator -> MINUS
Rule 105   monadic_operator -> NOT
Rule 106   referenced_location -> ARROW array_location
Rule 107   operator1 -> relational_operator
Rule 108   operator1 -> membership_operator
Rule 109   operator2 -> arithmetic_additive_operator
Rule 110   operator2 -> string_concatenation_operator
Rule 111   arithmetic_additive_operator -> PLUS
Rule 112   arithmetic_additive_operator -> MINUS
Rule 113   string_concatenation_operator -> CONCAT
Rule 114   relational_operator -> AND
Rule 115   relational_operator -> OR
Rule 116   relational_operator -> EQUAL
Rule 117   relational_operator -> NOTEQ
Rule 118   relational_operator -> GREATER
Rule 119   relational_operator -> GTEQUAL
Rule 120   relational_operator -> LESS
Rule 121   relational_operator -> LTEQUAL
Rule 122   membership_operator -> IN
Rule 123   primitive_value -> literal
Rule 124   literal -> integer_literal
Rule 125   literal -> boolean_literal
Rule 126   literal -> character_literal
Rule 127   literal -> empty_literal
Rule 128   literal -> character_string_literal
Rule 129   integer_literal -> ICONST
Rule 130   boolean_literal -> TRUE
Rule 131   boolean_literal -> FALSE
Rule 132   character_literal -> CCONST
Rule 133   empty_literal -> NULL
Rule 134   character_string_literal -> SCONST
Rule 135   empty -> <empty>
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

Terminals, with rules where they appear

ABS                  : 
<<<<<<< HEAD
AND                  : 106
ARRAY                : 50
ARROW                : 62 98
ASC                  : 
ASSIGN               : 12 13 19 26 138 139
BOOL                 : 38
BY                   : 
CCONST               : 129
CHAR                 : 39
CHARS                : 48
COLON                : 42 65 71 125 132
COMMA                : 11 16 21 25 52 70
CONCAT               : 105
DCL                  : 14
DIVIDE               : 94
DO                   : 
DOWN                 : 
ELSE                 : 79 146
ELSIF                : 80 81 147 148
END                  : 
EQUAL                : 108
EXIT                 : 
FALSE                : 128
FI                   : 76 77 143
FOR                  : 
GREATER              : 110
GTEQUAL              : 111
ICONST               : 126
ID                   : 22
IF                   : 76 77 143 144
IN                   : 114
INT                  : 37
LBRACKET             : 48 50 63 63 65 68 71 124 125
LENGTH               : 
LESS                 : 112
LOC                  : 
LOWER                : 
LPAREN               : 40 41 75
LTEQUAL              : 113
MINUS                : 96 104
MODULO               : 95
NOT                  : 97
NOTEQ                : 109
NULL                 : 130
NUM                  : 
OD                   : 
OR                   : 107
PLUS                 : 103
PRINT                : 
PROC                 : 
RBRACKET             : 48 50 65 68 71 124 125
READ                 : 
REF                  : 45
RESULT               : 
RETURN               : 
RETURNS              : 
RPAREN               : 40 41 75
SCONST               : 131
SEMI                 : 9 14 23
SYN                  : 9
THEN                 : 78 145
TIMES                : 93
TO                   : 
TRUE                 : 127
=======
AND                  : 114
ARRAY                : 59
ARROW                : 71 106
ASC                  : 
ASSIGN               : 12 13 19 26
BOOL                 : 47
BY                   : 
CCONST               : 132
CHAR                 : 48
CHARS                : 57
COLON                : 27 51 74 80
COMMA                : 11 16 21 25 31 61 79
CONCAT               : 113
DCL                  : 14
DIVIDE               : 102
DO                   : 
DOWN                 : 
ELSE                 : 87
ELSIF                : 88 89
END                  : 28 29
EQUAL                : 116
EXIT                 : 
FALSE                : 131
FI                   : 84 85
FOR                  : 
GREATER              : 118
GTEQUAL              : 119
ICONST               : 129
ID                   : 22 27
IF                   : 84 85
IN                   : 122
INT                  : 46
LBRACKET             : 57 59 72 72 74 77 80
LENGTH               : 
LESS                 : 120
LOC                  : 32 34
LOWER                : 
LPAREN               : 28 29 34 35 49 50
LTEQUAL              : 121
MINUS                : 104 112
MODULO               : 103
NOT                  : 105
NOTEQ                : 117
NULL                 : 133
NUM                  : 
OD                   : 
OR                   : 115
PLUS                 : 111
PRINT                : 
PROC                 : 28 29
RBRACKET             : 57 59 74 77 80
READ                 : 
REF                  : 54
RESULT               : 
RETURN               : 
RETURNS              : 34 35
RPAREN               : 28 29 34 35 49 50
SCONST               : 134
SEMI                 : 9 14 23 28 28 29 29
SYN                  : 9
THEN                 : 86
TIMES                : 101
TO                   : 
TRUE                 : 130
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559
TYPE                 : 23
UPPER                : 
WHILE                : 
error                : 

Nonterminals, with rules where they appear

<<<<<<< HEAD
action               : 132 133
action_statement     : 8 149 150
action_statement_list : 145 146
action_statement_nullable : 149 150
arithmetic_additive_operator : 101 140
arithmetic_multiplicative_operator : 87 141
array_element        : 60
array_location       : 62 68 71 90 98 137
array_mode           : 47
array_slice          : 61
assigning_operator   : 137
assignment_action    : 135
boolean_literal      : 120
boolean_mode         : 33
bracketed_action     : 134
character_literal    : 121
character_mode       : 34
character_string_literal : 123
closed_dyadic_operator : 138
composite_mode       : 30
conditional_expression : 74
declaration          : 15 16
declaration_list     : 14 16
declaration_statement : 5
dereferenced_reference : 57
discrete_mode        : 28 41 53
discrete_mode_name   : 40
discrete_range_mode  : 35
element_mode         : 50
else_clause          : 143 147
else_expression      : 76 77
elsif_expression     : 77 81
empty                : 4 151
empty_literal        : 122
expression           : 12 13 19 43 44 64 66 67 69 70 75 76 77 78 79 80 81 125 125 137 143 144 147 148
expression_list      : 68 70 124
identifier           : 20 21 31 36 56 63 65 132
identifier_list      : 12 13 17 18 21 26
if_action            : 136
index_mode           : 51 52
index_mode_list      : 50 52
initialization       : 17
integer_literal      : 49 119
integer_mode         : 32
left_element         : 65
literal              : 115
literal_range        : 40 41 54
location             : 72
lower_bound          : 42 71
membership_operator  : 100
mode                 : 12 17 18 26 45 55
mode_definition      : 24 25
mode_name            : 27
monadic_operator     : 88
newmode_list         : 23 25
newmode_statement    : 7
operand0             : 73 83
operand1             : 82 83 85
operand2             : 84 85 87
operand3             : 86 87
operand4             : 88 89
operator1            : 83
operator2            : 85
parenthesized_expression : 118
primitive_value      : 92 124 125
program              : 0
reference_mode       : 29
referenced_location  : 91
relational_operator  : 99
right_element        : 65
start_element        : 63
statement            : 2 3
statement_list       : 1
statement_nullable   : 2 3
string_concatenation_operator : 102 142
string_element       : 58
string_length        : 48
string_mode          : 46
string_slice         : 59
synonym_definition   : 10 11
synonym_list         : 9 11
synonym_statement    : 6
then_clause          : 143 144 147 148
then_expression      : 76 77 80 81
upper_bound          : 42 71
value_array_element  : 116
value_array_slice    : 117
=======
arithmetic_additive_operator : 109
arithmetic_multiplicative_operator : 95
array_element        : 69
array_location       : 71 77 80 98 106
array_mode           : 56
array_slice          : 70
boolean_literal      : 125
boolean_mode         : 42
character_literal    : 126
character_mode       : 43
character_string_literal : 128
composite_mode       : 39
conditional_expression : 83
declaration          : 15 16
declaration_list     : 14 16
declaration_statement : 5
dereferenced_reference : 66
discrete_mode        : 37 50 62
discrete_mode_name   : 49
discrete_range_mode  : 44
element_mode         : 59
else_expression      : 84 85
elsif_expression     : 85 89
empty                : 4
empty_literal        : 127
expression           : 12 13 19 52 53 73 75 76 78 79 84 85 86 87 88 89
expression_list      : 77 79
formal_parameter     : 30 31 31
formal_parameter_list : 28 29
identifier           : 20 21 40 45 65 72 74
identifier_list      : 12 13 17 18 21 26 32 33
index_mode           : 60 61
index_mode_list      : 59 61
initialization       : 17
integer_literal      : 58 124
integer_mode         : 41
left_element         : 74
literal              : 123
literal_range        : 49 50 63
location             : 81
lower_bound          : 51 80
membership_operator  : 108
mode                 : 12 17 18 26 32 33 34 35 54 64
mode_definition      : 24 25
mode_name            : 36
monadic_operator     : 96
newmode_list         : 23 25
newmode_statement    : 7
operand0             : 82 91
operand1             : 90 91 93
operand2             : 92 93 95
operand3             : 94 95
operand4             : 96 97
operator1            : 91
operator2            : 93
primitive_value      : 100
procedure_definition : 27
procedure_statement  : 8
program              : 0
reference_mode       : 38
referenced_location  : 99
relational_operator  : 107
result_spec          : 28
right_element        : 74
start_element        : 72
statement            : 2 3
statement_list       : 1
statement_nullable   : 2 3 28 29
string_concatenation_operator : 110
string_element       : 67
string_length        : 57
string_mode          : 55
string_slice         : 68
synonym_definition   : 10 11
synonym_list         : 9 11
synonym_statement    : 6
then_expression      : 84 85 88 89
upper_bound          : 51 80
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statement_list
    (2) statement_list -> . statement statement_nullable
    (5) statement -> . declaration_statement
    (6) statement -> . synonym_statement
    (7) statement -> . newmode_statement
<<<<<<< HEAD
    (8) statement -> . action_statement
    (14) declaration_statement -> . DCL declaration_list SEMI
    (9) synonym_statement -> . SYN synonym_list SEMI
    (23) newmode_statement -> . TYPE newmode_list SEMI
    (132) action_statement -> . identifier COLON action
    (133) action_statement -> . action
    (22) identifier -> . ID
    (134) action -> . bracketed_action
    (135) action -> . assignment_action
    (136) bracketed_action -> . if_action
    (137) assignment_action -> . array_location assigning_operator expression
    (143) if_action -> . IF expression then_clause else_clause FI
    (144) if_action -> . IF expression then_clause
    (72) array_location -> . location
    (56) location -> . identifier
    (57) location -> . dereferenced_reference
    (58) location -> . string_element
    (59) location -> . string_slice
    (60) location -> . array_element
    (61) location -> . array_slice
    (62) dereferenced_reference -> . array_location ARROW
    (63) string_element -> . identifier LBRACKET start_element LBRACKET
    (65) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (68) array_element -> . array_location LBRACKET expression_list RBRACKET
    (71) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET

    DCL             shift and go to state 16
    SYN             shift and go to state 9
    TYPE            shift and go to state 14
    ID              shift and go to state 21
    IF              shift and go to state 4

    location                       shift and go to state 6
    string_element                 shift and go to state 1
    action_statement               shift and go to state 2
    string_slice                   shift and go to state 3
    array_slice                    shift and go to state 15
    statement_list                 shift and go to state 23
    if_action                      shift and go to state 17
    bracketed_action               shift and go to state 22
    statement                      shift and go to state 18
    array_location                 shift and go to state 13
    program                        shift and go to state 19
    array_element                  shift and go to state 7
    action                         shift and go to state 8
    newmode_statement              shift and go to state 5
    declaration_statement          shift and go to state 10
    assignment_action              shift and go to state 11
    dereferenced_reference         shift and go to state 20
    synonym_statement              shift and go to state 12
    identifier                     shift and go to state 24

state 1

    (58) location -> string_element .

    ARROW           reduce using rule 58 (location -> string_element .)
    LBRACKET        reduce using rule 58 (location -> string_element .)
    TIMES           reduce using rule 58 (location -> string_element .)
    DIVIDE          reduce using rule 58 (location -> string_element .)
    MODULO          reduce using rule 58 (location -> string_element .)
    PLUS            reduce using rule 58 (location -> string_element .)
    MINUS           reduce using rule 58 (location -> string_element .)
    CONCAT          reduce using rule 58 (location -> string_element .)
    AND             reduce using rule 58 (location -> string_element .)
    OR              reduce using rule 58 (location -> string_element .)
    EQUAL           reduce using rule 58 (location -> string_element .)
    NOTEQ           reduce using rule 58 (location -> string_element .)
    GREATER         reduce using rule 58 (location -> string_element .)
    GTEQUAL         reduce using rule 58 (location -> string_element .)
    LESS            reduce using rule 58 (location -> string_element .)
    LTEQUAL         reduce using rule 58 (location -> string_element .)
    IN              reduce using rule 58 (location -> string_element .)
    COLON           reduce using rule 58 (location -> string_element .)
    COMMA           reduce using rule 58 (location -> string_element .)
    SEMI            reduce using rule 58 (location -> string_element .)
    THEN            reduce using rule 58 (location -> string_element .)
    FI              reduce using rule 58 (location -> string_element .)
    RPAREN          reduce using rule 58 (location -> string_element .)
    DCL             reduce using rule 58 (location -> string_element .)
    SYN             reduce using rule 58 (location -> string_element .)
    TYPE            reduce using rule 58 (location -> string_element .)
    ID              reduce using rule 58 (location -> string_element .)
    IF              reduce using rule 58 (location -> string_element .)
    $end            reduce using rule 58 (location -> string_element .)
    ELSE            reduce using rule 58 (location -> string_element .)
    ELSIF           reduce using rule 58 (location -> string_element .)
    RBRACKET        reduce using rule 58 (location -> string_element .)
    ASSIGN          reduce using rule 58 (location -> string_element .)
=======
    (8) statement -> . procedure_statement
    (14) declaration_statement -> . DCL declaration_list SEMI
    (9) synonym_statement -> . SYN synonym_list SEMI
    (23) newmode_statement -> . TYPE newmode_list SEMI
    (27) procedure_statement -> . ID COLON procedure_definition

    DCL             shift and go to state 7
    SYN             shift and go to state 11
    TYPE            shift and go to state 4
    ID              shift and go to state 2

    declaration_statement          shift and go to state 1
    statement_list                 shift and go to state 3
    synonym_statement              shift and go to state 6
    procedure_statement            shift and go to state 5
    newmode_statement              shift and go to state 8
    program                        shift and go to state 9
    statement                      shift and go to state 10

state 1

    (5) statement -> declaration_statement .

    DCL             reduce using rule 5 (statement -> declaration_statement .)
    SYN             reduce using rule 5 (statement -> declaration_statement .)
    TYPE            reduce using rule 5 (statement -> declaration_statement .)
    ID              reduce using rule 5 (statement -> declaration_statement .)
    $end            reduce using rule 5 (statement -> declaration_statement .)
    END             reduce using rule 5 (statement -> declaration_statement .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 2

<<<<<<< HEAD
    (8) statement -> action_statement .

    DCL             reduce using rule 8 (statement -> action_statement .)
    SYN             reduce using rule 8 (statement -> action_statement .)
    TYPE            reduce using rule 8 (statement -> action_statement .)
    ID              reduce using rule 8 (statement -> action_statement .)
    IF              reduce using rule 8 (statement -> action_statement .)
    $end            reduce using rule 8 (statement -> action_statement .)
=======
    (27) procedure_statement -> ID . COLON procedure_definition

    COLON           shift and go to state 12
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 3

<<<<<<< HEAD
    (59) location -> string_slice .

    ARROW           reduce using rule 59 (location -> string_slice .)
    LBRACKET        reduce using rule 59 (location -> string_slice .)
    TIMES           reduce using rule 59 (location -> string_slice .)
    DIVIDE          reduce using rule 59 (location -> string_slice .)
    MODULO          reduce using rule 59 (location -> string_slice .)
    PLUS            reduce using rule 59 (location -> string_slice .)
    MINUS           reduce using rule 59 (location -> string_slice .)
    CONCAT          reduce using rule 59 (location -> string_slice .)
    AND             reduce using rule 59 (location -> string_slice .)
    OR              reduce using rule 59 (location -> string_slice .)
    EQUAL           reduce using rule 59 (location -> string_slice .)
    NOTEQ           reduce using rule 59 (location -> string_slice .)
    GREATER         reduce using rule 59 (location -> string_slice .)
    GTEQUAL         reduce using rule 59 (location -> string_slice .)
    LESS            reduce using rule 59 (location -> string_slice .)
    LTEQUAL         reduce using rule 59 (location -> string_slice .)
    IN              reduce using rule 59 (location -> string_slice .)
    COLON           reduce using rule 59 (location -> string_slice .)
    COMMA           reduce using rule 59 (location -> string_slice .)
    SEMI            reduce using rule 59 (location -> string_slice .)
    THEN            reduce using rule 59 (location -> string_slice .)
    FI              reduce using rule 59 (location -> string_slice .)
    RPAREN          reduce using rule 59 (location -> string_slice .)
    DCL             reduce using rule 59 (location -> string_slice .)
    SYN             reduce using rule 59 (location -> string_slice .)
    TYPE            reduce using rule 59 (location -> string_slice .)
    ID              reduce using rule 59 (location -> string_slice .)
    IF              reduce using rule 59 (location -> string_slice .)
    $end            reduce using rule 59 (location -> string_slice .)
    ELSE            reduce using rule 59 (location -> string_slice .)
    ELSIF           reduce using rule 59 (location -> string_slice .)
    RBRACKET        reduce using rule 59 (location -> string_slice .)
    ASSIGN          reduce using rule 59 (location -> string_slice .)
=======
    (1) program -> statement_list .

    $end            reduce using rule 1 (program -> statement_list .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 4

<<<<<<< HEAD
    (143) if_action -> IF . expression then_clause else_clause FI
    (144) if_action -> IF . expression then_clause
    (73) expression -> . operand0
    (74) expression -> . conditional_expression
    (82) operand0 -> . operand1
    (83) operand0 -> . operand0 operator1 operand1
    (76) conditional_expression -> . IF expression then_expression else_expression FI
    (77) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (84) operand1 -> . operand2
    (85) operand1 -> . operand1 operator2 operand2
    (86) operand2 -> . operand3
    (87) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (88) operand3 -> . monadic_operator operand4
    (89) operand3 -> . operand4
    (96) monadic_operator -> . MINUS
    (97) monadic_operator -> . NOT
    (90) operand4 -> . array_location
    (91) operand4 -> . referenced_location
    (92) operand4 -> . primitive_value
    (72) array_location -> . location
    (98) referenced_location -> . ARROW array_location
    (115) primitive_value -> . literal
    (116) primitive_value -> . value_array_element
    (117) primitive_value -> . value_array_slice
    (118) primitive_value -> . parenthesized_expression
    (56) location -> . identifier
    (57) location -> . dereferenced_reference
    (58) location -> . string_element
    (59) location -> . string_slice
    (60) location -> . array_element
    (61) location -> . array_slice
    (119) literal -> . integer_literal
    (120) literal -> . boolean_literal
    (121) literal -> . character_literal
    (122) literal -> . empty_literal
    (123) literal -> . character_string_literal
    (124) value_array_element -> . primitive_value LBRACKET expression_list RBRACKET
    (125) value_array_slice -> . primitive_value LBRACKET expression COLON expression RBRACKET
    (75) parenthesized_expression -> . LPAREN expression RPAREN
    (22) identifier -> . ID
    (62) dereferenced_reference -> . array_location ARROW
    (63) string_element -> . identifier LBRACKET start_element LBRACKET
    (65) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (68) array_element -> . array_location LBRACKET expression_list RBRACKET
    (71) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (126) integer_literal -> . ICONST
    (127) boolean_literal -> . TRUE
    (128) boolean_literal -> . FALSE
    (129) character_literal -> . CCONST
    (130) empty_literal -> . NULL
    (131) character_string_literal -> . SCONST

    IF              shift and go to state 31
    MINUS           shift and go to state 36
    NOT             shift and go to state 35
    ARROW           shift and go to state 45
    LPAREN          shift and go to state 44
    ID              shift and go to state 21
    ICONST          shift and go to state 40
    TRUE            shift and go to state 55
    FALSE           shift and go to state 53
    CCONST          shift and go to state 34
    NULL            shift and go to state 27
    SCONST          shift and go to state 52

    location                       shift and go to state 6
    monadic_operator               shift and go to state 47
    operand2                       shift and go to state 49
    value_array_element            shift and go to state 48
    operand1                       shift and go to state 25
    expression                     shift and go to state 26
    character_literal              shift and go to state 41
    conditional_expression         shift and go to state 28
    referenced_location            shift and go to state 29
    parenthesized_expression       shift and go to state 30
    array_slice                    shift and go to state 15
    integer_literal                shift and go to state 32
    empty_literal                  shift and go to state 50
    operand3                       shift and go to state 33
    string_slice                   shift and go to state 3
    string_element                 shift and go to state 1
    boolean_literal                shift and go to state 51
    array_location                 shift and go to state 46
    literal                        shift and go to state 37
    operand0                       shift and go to state 38
    primitive_value                shift and go to state 39
    array_element                  shift and go to state 7
    value_array_slice              shift and go to state 42
    operand4                       shift and go to state 54
    character_string_literal       shift and go to state 43
    dereferenced_reference         shift and go to state 20
    identifier                     shift and go to state 56

state 5

    (7) statement -> newmode_statement .

    DCL             reduce using rule 7 (statement -> newmode_statement .)
    SYN             reduce using rule 7 (statement -> newmode_statement .)
    TYPE            reduce using rule 7 (statement -> newmode_statement .)
    ID              reduce using rule 7 (statement -> newmode_statement .)
    IF              reduce using rule 7 (statement -> newmode_statement .)
    $end            reduce using rule 7 (statement -> newmode_statement .)
=======
    (23) newmode_statement -> TYPE . newmode_list SEMI
    (24) newmode_list -> . mode_definition
    (25) newmode_list -> . mode_definition COMMA newmode_list
    (26) mode_definition -> . identifier_list ASSIGN mode
    (20) identifier_list -> . identifier
    (21) identifier_list -> . identifier COMMA identifier_list
    (22) identifier -> . ID

    ID              shift and go to state 15

    identifier                     shift and go to state 16
    newmode_list                   shift and go to state 13
    mode_definition                shift and go to state 14
    identifier_list                shift and go to state 17

state 5

    (8) statement -> procedure_statement .

    DCL             reduce using rule 8 (statement -> procedure_statement .)
    SYN             reduce using rule 8 (statement -> procedure_statement .)
    TYPE            reduce using rule 8 (statement -> procedure_statement .)
    ID              reduce using rule 8 (statement -> procedure_statement .)
    $end            reduce using rule 8 (statement -> procedure_statement .)
    END             reduce using rule 8 (statement -> procedure_statement .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 6

<<<<<<< HEAD
    (72) array_location -> location .

    ARROW           reduce using rule 72 (array_location -> location .)
    LBRACKET        reduce using rule 72 (array_location -> location .)
    TIMES           reduce using rule 72 (array_location -> location .)
    DIVIDE          reduce using rule 72 (array_location -> location .)
    MODULO          reduce using rule 72 (array_location -> location .)
    PLUS            reduce using rule 72 (array_location -> location .)
    MINUS           reduce using rule 72 (array_location -> location .)
    CONCAT          reduce using rule 72 (array_location -> location .)
    AND             reduce using rule 72 (array_location -> location .)
    OR              reduce using rule 72 (array_location -> location .)
    EQUAL           reduce using rule 72 (array_location -> location .)
    NOTEQ           reduce using rule 72 (array_location -> location .)
    GREATER         reduce using rule 72 (array_location -> location .)
    GTEQUAL         reduce using rule 72 (array_location -> location .)
    LESS            reduce using rule 72 (array_location -> location .)
    LTEQUAL         reduce using rule 72 (array_location -> location .)
    IN              reduce using rule 72 (array_location -> location .)
    COMMA           reduce using rule 72 (array_location -> location .)
    SEMI            reduce using rule 72 (array_location -> location .)
    RPAREN          reduce using rule 72 (array_location -> location .)
    RBRACKET        reduce using rule 72 (array_location -> location .)
    THEN            reduce using rule 72 (array_location -> location .)
    DCL             reduce using rule 72 (array_location -> location .)
    SYN             reduce using rule 72 (array_location -> location .)
    TYPE            reduce using rule 72 (array_location -> location .)
    ID              reduce using rule 72 (array_location -> location .)
    IF              reduce using rule 72 (array_location -> location .)
    $end            reduce using rule 72 (array_location -> location .)
    ELSE            reduce using rule 72 (array_location -> location .)
    ELSIF           reduce using rule 72 (array_location -> location .)
    FI              reduce using rule 72 (array_location -> location .)
    COLON           reduce using rule 72 (array_location -> location .)
    ASSIGN          reduce using rule 72 (array_location -> location .)


state 7

    (60) location -> array_element .

    ARROW           reduce using rule 60 (location -> array_element .)
    LBRACKET        reduce using rule 60 (location -> array_element .)
    TIMES           reduce using rule 60 (location -> array_element .)
    DIVIDE          reduce using rule 60 (location -> array_element .)
    MODULO          reduce using rule 60 (location -> array_element .)
    PLUS            reduce using rule 60 (location -> array_element .)
    MINUS           reduce using rule 60 (location -> array_element .)
    CONCAT          reduce using rule 60 (location -> array_element .)
    AND             reduce using rule 60 (location -> array_element .)
    OR              reduce using rule 60 (location -> array_element .)
    EQUAL           reduce using rule 60 (location -> array_element .)
    NOTEQ           reduce using rule 60 (location -> array_element .)
    GREATER         reduce using rule 60 (location -> array_element .)
    GTEQUAL         reduce using rule 60 (location -> array_element .)
    LESS            reduce using rule 60 (location -> array_element .)
    LTEQUAL         reduce using rule 60 (location -> array_element .)
    IN              reduce using rule 60 (location -> array_element .)
    COLON           reduce using rule 60 (location -> array_element .)
    COMMA           reduce using rule 60 (location -> array_element .)
    SEMI            reduce using rule 60 (location -> array_element .)
    THEN            reduce using rule 60 (location -> array_element .)
    FI              reduce using rule 60 (location -> array_element .)
    RPAREN          reduce using rule 60 (location -> array_element .)
    DCL             reduce using rule 60 (location -> array_element .)
    SYN             reduce using rule 60 (location -> array_element .)
    TYPE            reduce using rule 60 (location -> array_element .)
    ID              reduce using rule 60 (location -> array_element .)
    IF              reduce using rule 60 (location -> array_element .)
    $end            reduce using rule 60 (location -> array_element .)
    ELSE            reduce using rule 60 (location -> array_element .)
    ELSIF           reduce using rule 60 (location -> array_element .)
    RBRACKET        reduce using rule 60 (location -> array_element .)
    ASSIGN          reduce using rule 60 (location -> array_element .)
=======
    (6) statement -> synonym_statement .

    DCL             reduce using rule 6 (statement -> synonym_statement .)
    SYN             reduce using rule 6 (statement -> synonym_statement .)
    TYPE            reduce using rule 6 (statement -> synonym_statement .)
    ID              reduce using rule 6 (statement -> synonym_statement .)
    $end            reduce using rule 6 (statement -> synonym_statement .)
    END             reduce using rule 6 (statement -> synonym_statement .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 7

    (14) declaration_statement -> DCL . declaration_list SEMI
    (15) declaration_list -> . declaration
    (16) declaration_list -> . declaration COMMA declaration_list
    (17) declaration -> . identifier_list mode initialization
    (18) declaration -> . identifier_list mode
    (20) identifier_list -> . identifier
    (21) identifier_list -> . identifier COMMA identifier_list
    (22) identifier -> . ID

    ID              shift and go to state 15

    declaration_list               shift and go to state 18
    identifier                     shift and go to state 16
    declaration                    shift and go to state 19
    identifier_list                shift and go to state 20

state 8

<<<<<<< HEAD
    (133) action_statement -> action .

    ELSE            reduce using rule 133 (action_statement -> action .)
    ELSIF           reduce using rule 133 (action_statement -> action .)
    DCL             reduce using rule 133 (action_statement -> action .)
    SYN             reduce using rule 133 (action_statement -> action .)
    TYPE            reduce using rule 133 (action_statement -> action .)
    ID              reduce using rule 133 (action_statement -> action .)
    IF              reduce using rule 133 (action_statement -> action .)
    $end            reduce using rule 133 (action_statement -> action .)
    FI              reduce using rule 133 (action_statement -> action .)
=======
    (7) statement -> newmode_statement .

    DCL             reduce using rule 7 (statement -> newmode_statement .)
    SYN             reduce using rule 7 (statement -> newmode_statement .)
    TYPE            reduce using rule 7 (statement -> newmode_statement .)
    ID              reduce using rule 7 (statement -> newmode_statement .)
    $end            reduce using rule 7 (statement -> newmode_statement .)
    END             reduce using rule 7 (statement -> newmode_statement .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 9

<<<<<<< HEAD
    (9) synonym_statement -> SYN . synonym_list SEMI
    (10) synonym_list -> . synonym_definition
    (11) synonym_list -> . synonym_definition COMMA synonym_list
    (12) synonym_definition -> . identifier_list mode ASSIGN expression
    (13) synonym_definition -> . identifier_list ASSIGN expression
    (20) identifier_list -> . identifier
    (21) identifier_list -> . identifier COMMA identifier_list
    (22) identifier -> . ID

    ID              shift and go to state 21
=======
    (0) S' -> program .

>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

    identifier                     shift and go to state 57
    synonym_definition             shift and go to state 58
    identifier_list                shift and go to state 59
    synonym_list                   shift and go to state 60

state 10

<<<<<<< HEAD
    (5) statement -> declaration_statement .

    DCL             reduce using rule 5 (statement -> declaration_statement .)
    SYN             reduce using rule 5 (statement -> declaration_statement .)
    TYPE            reduce using rule 5 (statement -> declaration_statement .)
    ID              reduce using rule 5 (statement -> declaration_statement .)
    IF              reduce using rule 5 (statement -> declaration_statement .)
    $end            reduce using rule 5 (statement -> declaration_statement .)


state 11

    (135) action -> assignment_action .

    ELSE            reduce using rule 135 (action -> assignment_action .)
    ELSIF           reduce using rule 135 (action -> assignment_action .)
    DCL             reduce using rule 135 (action -> assignment_action .)
    SYN             reduce using rule 135 (action -> assignment_action .)
    TYPE            reduce using rule 135 (action -> assignment_action .)
    ID              reduce using rule 135 (action -> assignment_action .)
    IF              reduce using rule 135 (action -> assignment_action .)
    $end            reduce using rule 135 (action -> assignment_action .)
    FI              reduce using rule 135 (action -> assignment_action .)
=======
    (2) statement_list -> statement . statement_nullable
    (3) statement_nullable -> . statement statement_nullable
    (4) statement_nullable -> . empty
    (5) statement -> . declaration_statement
    (6) statement -> . synonym_statement
    (7) statement -> . newmode_statement
    (8) statement -> . procedure_statement
    (135) empty -> .
    (14) declaration_statement -> . DCL declaration_list SEMI
    (9) synonym_statement -> . SYN synonym_list SEMI
    (23) newmode_statement -> . TYPE newmode_list SEMI
    (27) procedure_statement -> . ID COLON procedure_definition

    $end            reduce using rule 135 (empty -> .)
    DCL             shift and go to state 7
    SYN             shift and go to state 11
    TYPE            shift and go to state 4
    ID              shift and go to state 2

    declaration_statement          shift and go to state 1
    newmode_statement              shift and go to state 8
    synonym_statement              shift and go to state 6
    procedure_statement            shift and go to state 5
    statement_nullable             shift and go to state 23
    statement                      shift and go to state 22
    empty                          shift and go to state 21

state 11

    (9) synonym_statement -> SYN . synonym_list SEMI
    (10) synonym_list -> . synonym_definition
    (11) synonym_list -> . synonym_definition COMMA synonym_list
    (12) synonym_definition -> . identifier_list mode ASSIGN expression
    (13) synonym_definition -> . identifier_list ASSIGN expression
    (20) identifier_list -> . identifier
    (21) identifier_list -> . identifier COMMA identifier_list
    (22) identifier -> . ID

    ID              shift and go to state 15
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

    synonym_definition             shift and go to state 24
    identifier                     shift and go to state 16
    synonym_list                   shift and go to state 25
    identifier_list                shift and go to state 26

state 12

<<<<<<< HEAD
    (6) statement -> synonym_statement .

    DCL             reduce using rule 6 (statement -> synonym_statement .)
    SYN             reduce using rule 6 (statement -> synonym_statement .)
    TYPE            reduce using rule 6 (statement -> synonym_statement .)
    ID              reduce using rule 6 (statement -> synonym_statement .)
    IF              reduce using rule 6 (statement -> synonym_statement .)
    $end            reduce using rule 6 (statement -> synonym_statement .)
=======
    (27) procedure_statement -> ID COLON . procedure_definition
    (28) procedure_definition -> . PROC LPAREN formal_parameter_list RPAREN result_spec SEMI statement_nullable END SEMI
    (29) procedure_definition -> . PROC LPAREN formal_parameter_list RPAREN SEMI statement_nullable END SEMI

    PROC            shift and go to state 27
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

    procedure_definition           shift and go to state 28

state 13

<<<<<<< HEAD
    (137) assignment_action -> array_location . assigning_operator expression
    (62) dereferenced_reference -> array_location . ARROW
    (68) array_element -> array_location . LBRACKET expression_list RBRACKET
    (71) array_slice -> array_location . LBRACKET lower_bound COLON upper_bound RBRACKET
    (138) assigning_operator -> . closed_dyadic_operator ASSIGN
    (139) assigning_operator -> . ASSIGN
    (140) closed_dyadic_operator -> . arithmetic_additive_operator
    (141) closed_dyadic_operator -> . arithmetic_multiplicative_operator
    (142) closed_dyadic_operator -> . string_concatenation_operator
    (103) arithmetic_additive_operator -> . PLUS
    (104) arithmetic_additive_operator -> . MINUS
    (93) arithmetic_multiplicative_operator -> . TIMES
    (94) arithmetic_multiplicative_operator -> . DIVIDE
    (95) arithmetic_multiplicative_operator -> . MODULO
    (105) string_concatenation_operator -> . CONCAT

    ARROW           shift and go to state 61
    LBRACKET        shift and go to state 71
    ASSIGN          shift and go to state 63
    PLUS            shift and go to state 64
    MINUS           shift and go to state 74
    TIMES           shift and go to state 73
    DIVIDE          shift and go to state 70
    MODULO          shift and go to state 72
    CONCAT          shift and go to state 68

    arithmetic_additive_operator   shift and go to state 67
    assigning_operator             shift and go to state 69
    string_concatenation_operator  shift and go to state 65
    arithmetic_multiplicative_operator shift and go to state 62
    closed_dyadic_operator         shift and go to state 66

state 14

    (23) newmode_statement -> TYPE . newmode_list SEMI
    (24) newmode_list -> . mode_definition
    (25) newmode_list -> . mode_definition COMMA newmode_list
    (26) mode_definition -> . identifier_list ASSIGN mode
    (20) identifier_list -> . identifier
    (21) identifier_list -> . identifier COMMA identifier_list
    (22) identifier -> . ID

    ID              shift and go to state 21
=======
    (23) newmode_statement -> TYPE newmode_list . SEMI

    SEMI            shift and go to state 29


state 14

    (24) newmode_list -> mode_definition .
    (25) newmode_list -> mode_definition . COMMA newmode_list

    SEMI            reduce using rule 24 (newmode_list -> mode_definition .)
    COMMA           shift and go to state 30
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

    newmode_list                   shift and go to state 75
    identifier_list                shift and go to state 77
    identifier                     shift and go to state 57
    mode_definition                shift and go to state 76

state 15

<<<<<<< HEAD
    (61) location -> array_slice .

    ARROW           reduce using rule 61 (location -> array_slice .)
    LBRACKET        reduce using rule 61 (location -> array_slice .)
    TIMES           reduce using rule 61 (location -> array_slice .)
    DIVIDE          reduce using rule 61 (location -> array_slice .)
    MODULO          reduce using rule 61 (location -> array_slice .)
    PLUS            reduce using rule 61 (location -> array_slice .)
    MINUS           reduce using rule 61 (location -> array_slice .)
    CONCAT          reduce using rule 61 (location -> array_slice .)
    AND             reduce using rule 61 (location -> array_slice .)
    OR              reduce using rule 61 (location -> array_slice .)
    EQUAL           reduce using rule 61 (location -> array_slice .)
    NOTEQ           reduce using rule 61 (location -> array_slice .)
    GREATER         reduce using rule 61 (location -> array_slice .)
    GTEQUAL         reduce using rule 61 (location -> array_slice .)
    LESS            reduce using rule 61 (location -> array_slice .)
    LTEQUAL         reduce using rule 61 (location -> array_slice .)
    IN              reduce using rule 61 (location -> array_slice .)
    COLON           reduce using rule 61 (location -> array_slice .)
    COMMA           reduce using rule 61 (location -> array_slice .)
    SEMI            reduce using rule 61 (location -> array_slice .)
    THEN            reduce using rule 61 (location -> array_slice .)
    FI              reduce using rule 61 (location -> array_slice .)
    RPAREN          reduce using rule 61 (location -> array_slice .)
    DCL             reduce using rule 61 (location -> array_slice .)
    SYN             reduce using rule 61 (location -> array_slice .)
    TYPE            reduce using rule 61 (location -> array_slice .)
    ID              reduce using rule 61 (location -> array_slice .)
    IF              reduce using rule 61 (location -> array_slice .)
    $end            reduce using rule 61 (location -> array_slice .)
    ELSE            reduce using rule 61 (location -> array_slice .)
    ELSIF           reduce using rule 61 (location -> array_slice .)
    RBRACKET        reduce using rule 61 (location -> array_slice .)
    ASSIGN          reduce using rule 61 (location -> array_slice .)
=======
    (22) identifier -> ID .

    LBRACKET        reduce using rule 22 (identifier -> ID .)
    ARROW           reduce using rule 22 (identifier -> ID .)
    TIMES           reduce using rule 22 (identifier -> ID .)
    DIVIDE          reduce using rule 22 (identifier -> ID .)
    MODULO          reduce using rule 22 (identifier -> ID .)
    PLUS            reduce using rule 22 (identifier -> ID .)
    MINUS           reduce using rule 22 (identifier -> ID .)
    CONCAT          reduce using rule 22 (identifier -> ID .)
    AND             reduce using rule 22 (identifier -> ID .)
    OR              reduce using rule 22 (identifier -> ID .)
    EQUAL           reduce using rule 22 (identifier -> ID .)
    NOTEQ           reduce using rule 22 (identifier -> ID .)
    GREATER         reduce using rule 22 (identifier -> ID .)
    GTEQUAL         reduce using rule 22 (identifier -> ID .)
    LESS            reduce using rule 22 (identifier -> ID .)
    LTEQUAL         reduce using rule 22 (identifier -> ID .)
    IN              reduce using rule 22 (identifier -> ID .)
    THEN            reduce using rule 22 (identifier -> ID .)
    LPAREN          reduce using rule 22 (identifier -> ID .)
    COLON           reduce using rule 22 (identifier -> ID .)
    COMMA           reduce using rule 22 (identifier -> ID .)
    RBRACKET        reduce using rule 22 (identifier -> ID .)
    SEMI            reduce using rule 22 (identifier -> ID .)
    RPAREN          reduce using rule 22 (identifier -> ID .)
    ELSE            reduce using rule 22 (identifier -> ID .)
    ELSIF           reduce using rule 22 (identifier -> ID .)
    FI              reduce using rule 22 (identifier -> ID .)
    REF             reduce using rule 22 (identifier -> ID .)
    ID              reduce using rule 22 (identifier -> ID .)
    INT             reduce using rule 22 (identifier -> ID .)
    BOOL            reduce using rule 22 (identifier -> ID .)
    CHAR            reduce using rule 22 (identifier -> ID .)
    CHARS           reduce using rule 22 (identifier -> ID .)
    ARRAY           reduce using rule 22 (identifier -> ID .)
    ASSIGN          reduce using rule 22 (identifier -> ID .)
    LOC             reduce using rule 22 (identifier -> ID .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 16

<<<<<<< HEAD
    (14) declaration_statement -> DCL . declaration_list SEMI
    (15) declaration_list -> . declaration
    (16) declaration_list -> . declaration COMMA declaration_list
    (17) declaration -> . identifier_list mode initialization
    (18) declaration -> . identifier_list mode
    (20) identifier_list -> . identifier
    (21) identifier_list -> . identifier COMMA identifier_list
    (22) identifier -> . ID

    ID              shift and go to state 21

    declaration                    shift and go to state 78
    declaration_list               shift and go to state 79
    identifier_list                shift and go to state 80
    identifier                     shift and go to state 57

state 17

    (136) bracketed_action -> if_action .

    ELSE            reduce using rule 136 (bracketed_action -> if_action .)
    ELSIF           reduce using rule 136 (bracketed_action -> if_action .)
    DCL             reduce using rule 136 (bracketed_action -> if_action .)
    SYN             reduce using rule 136 (bracketed_action -> if_action .)
    TYPE            reduce using rule 136 (bracketed_action -> if_action .)
    ID              reduce using rule 136 (bracketed_action -> if_action .)
    IF              reduce using rule 136 (bracketed_action -> if_action .)
    $end            reduce using rule 136 (bracketed_action -> if_action .)
    FI              reduce using rule 136 (bracketed_action -> if_action .)
=======
    (20) identifier_list -> identifier .
    (21) identifier_list -> identifier . COMMA identifier_list

    ASSIGN          reduce using rule 20 (identifier_list -> identifier .)
    REF             reduce using rule 20 (identifier_list -> identifier .)
    ID              reduce using rule 20 (identifier_list -> identifier .)
    INT             reduce using rule 20 (identifier_list -> identifier .)
    BOOL            reduce using rule 20 (identifier_list -> identifier .)
    CHAR            reduce using rule 20 (identifier_list -> identifier .)
    CHARS           reduce using rule 20 (identifier_list -> identifier .)
    ARRAY           reduce using rule 20 (identifier_list -> identifier .)
    COMMA           shift and go to state 31


state 17

    (26) mode_definition -> identifier_list . ASSIGN mode

    ASSIGN          shift and go to state 32
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 18

<<<<<<< HEAD
    (2) statement_list -> statement . statement_nullable
    (3) statement_nullable -> . statement statement_nullable
    (4) statement_nullable -> . empty
    (5) statement -> . declaration_statement
    (6) statement -> . synonym_statement
    (7) statement -> . newmode_statement
    (8) statement -> . action_statement
    (152) empty -> .
    (14) declaration_statement -> . DCL declaration_list SEMI
    (9) synonym_statement -> . SYN synonym_list SEMI
    (23) newmode_statement -> . TYPE newmode_list SEMI
    (132) action_statement -> . identifier COLON action
    (133) action_statement -> . action
    (22) identifier -> . ID
    (134) action -> . bracketed_action
    (135) action -> . assignment_action
    (136) bracketed_action -> . if_action
    (137) assignment_action -> . array_location assigning_operator expression
    (143) if_action -> . IF expression then_clause else_clause FI
    (144) if_action -> . IF expression then_clause
    (72) array_location -> . location
    (56) location -> . identifier
    (57) location -> . dereferenced_reference
    (58) location -> . string_element
    (59) location -> . string_slice
    (60) location -> . array_element
    (61) location -> . array_slice
    (62) dereferenced_reference -> . array_location ARROW
    (63) string_element -> . identifier LBRACKET start_element LBRACKET
    (65) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (68) array_element -> . array_location LBRACKET expression_list RBRACKET
    (71) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET

    $end            reduce using rule 152 (empty -> .)
    DCL             shift and go to state 16
    SYN             shift and go to state 9
    TYPE            shift and go to state 14
    ID              shift and go to state 21
    IF              shift and go to state 4

    location                       shift and go to state 6
    string_element                 shift and go to state 1
    action_statement               shift and go to state 2
    string_slice                   shift and go to state 3
    array_slice                    shift and go to state 15
    statement_nullable             shift and go to state 81
    empty                          shift and go to state 82
    if_action                      shift and go to state 17
    bracketed_action               shift and go to state 22
    statement                      shift and go to state 83
    array_location                 shift and go to state 13
    array_element                  shift and go to state 7
    action                         shift and go to state 8
    newmode_statement              shift and go to state 5
    declaration_statement          shift and go to state 10
    assignment_action              shift and go to state 11
    synonym_statement              shift and go to state 12
    dereferenced_reference         shift and go to state 20
    identifier                     shift and go to state 24

state 19

    (0) S' -> program .

=======
    (14) declaration_statement -> DCL declaration_list . SEMI

    SEMI            shift and go to state 33


state 19

    (15) declaration_list -> declaration .
    (16) declaration_list -> declaration . COMMA declaration_list

    SEMI            reduce using rule 15 (declaration_list -> declaration .)
    COMMA           shift and go to state 34
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 20

<<<<<<< HEAD
    (57) location -> dereferenced_reference .

    ARROW           reduce using rule 57 (location -> dereferenced_reference .)
    LBRACKET        reduce using rule 57 (location -> dereferenced_reference .)
    TIMES           reduce using rule 57 (location -> dereferenced_reference .)
    DIVIDE          reduce using rule 57 (location -> dereferenced_reference .)
    MODULO          reduce using rule 57 (location -> dereferenced_reference .)
    PLUS            reduce using rule 57 (location -> dereferenced_reference .)
    MINUS           reduce using rule 57 (location -> dereferenced_reference .)
    CONCAT          reduce using rule 57 (location -> dereferenced_reference .)
    AND             reduce using rule 57 (location -> dereferenced_reference .)
    OR              reduce using rule 57 (location -> dereferenced_reference .)
    EQUAL           reduce using rule 57 (location -> dereferenced_reference .)
    NOTEQ           reduce using rule 57 (location -> dereferenced_reference .)
    GREATER         reduce using rule 57 (location -> dereferenced_reference .)
    GTEQUAL         reduce using rule 57 (location -> dereferenced_reference .)
    LESS            reduce using rule 57 (location -> dereferenced_reference .)
    LTEQUAL         reduce using rule 57 (location -> dereferenced_reference .)
    IN              reduce using rule 57 (location -> dereferenced_reference .)
    COLON           reduce using rule 57 (location -> dereferenced_reference .)
    COMMA           reduce using rule 57 (location -> dereferenced_reference .)
    SEMI            reduce using rule 57 (location -> dereferenced_reference .)
    THEN            reduce using rule 57 (location -> dereferenced_reference .)
    FI              reduce using rule 57 (location -> dereferenced_reference .)
    RPAREN          reduce using rule 57 (location -> dereferenced_reference .)
    DCL             reduce using rule 57 (location -> dereferenced_reference .)
    SYN             reduce using rule 57 (location -> dereferenced_reference .)
    TYPE            reduce using rule 57 (location -> dereferenced_reference .)
    ID              reduce using rule 57 (location -> dereferenced_reference .)
    IF              reduce using rule 57 (location -> dereferenced_reference .)
    $end            reduce using rule 57 (location -> dereferenced_reference .)
    ELSE            reduce using rule 57 (location -> dereferenced_reference .)
    ELSIF           reduce using rule 57 (location -> dereferenced_reference .)
    RBRACKET        reduce using rule 57 (location -> dereferenced_reference .)
    ASSIGN          reduce using rule 57 (location -> dereferenced_reference .)
=======
    (17) declaration -> identifier_list . mode initialization
    (18) declaration -> identifier_list . mode
    (36) mode -> . mode_name
    (37) mode -> . discrete_mode
    (38) mode -> . reference_mode
    (39) mode -> . composite_mode
    (40) mode_name -> . identifier
    (41) discrete_mode -> . integer_mode
    (42) discrete_mode -> . boolean_mode
    (43) discrete_mode -> . character_mode
    (44) discrete_mode -> . discrete_range_mode
    (54) reference_mode -> . REF mode
    (55) composite_mode -> . string_mode
    (56) composite_mode -> . array_mode
    (22) identifier -> . ID
    (46) integer_mode -> . INT
    (47) boolean_mode -> . BOOL
    (48) character_mode -> . CHAR
    (49) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (50) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (57) string_mode -> . CHARS LBRACKET string_length RBRACKET
    (59) array_mode -> . ARRAY LBRACKET index_mode_list RBRACKET element_mode
    (45) discrete_mode_name -> . identifier
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

    REF             shift and go to state 38
    ID              shift and go to state 15
    INT             shift and go to state 39
    BOOL            shift and go to state 53
    CHAR            shift and go to state 51
    CHARS           shift and go to state 43
    ARRAY           shift and go to state 52

    discrete_range_mode            shift and go to state 45
    string_mode                    shift and go to state 44
    identifier                     shift and go to state 36
    composite_mode                 shift and go to state 46
    character_mode                 shift and go to state 47
    discrete_mode_name             shift and go to state 48
    mode                           shift and go to state 49
    boolean_mode                   shift and go to state 50
    mode_name                      shift and go to state 41
    reference_mode                 shift and go to state 35
    array_mode                     shift and go to state 42
    integer_mode                   shift and go to state 40
    discrete_mode                  shift and go to state 37

state 21

<<<<<<< HEAD
    (22) identifier -> ID .

    COLON           reduce using rule 22 (identifier -> ID .)
    LBRACKET        reduce using rule 22 (identifier -> ID .)
    ARROW           reduce using rule 22 (identifier -> ID .)
    ASSIGN          reduce using rule 22 (identifier -> ID .)
    PLUS            reduce using rule 22 (identifier -> ID .)
    MINUS           reduce using rule 22 (identifier -> ID .)
    TIMES           reduce using rule 22 (identifier -> ID .)
    DIVIDE          reduce using rule 22 (identifier -> ID .)
    MODULO          reduce using rule 22 (identifier -> ID .)
    CONCAT          reduce using rule 22 (identifier -> ID .)
    COMMA           reduce using rule 22 (identifier -> ID .)
    SEMI            reduce using rule 22 (identifier -> ID .)
    LPAREN          reduce using rule 22 (identifier -> ID .)
    AND             reduce using rule 22 (identifier -> ID .)
    OR              reduce using rule 22 (identifier -> ID .)
    EQUAL           reduce using rule 22 (identifier -> ID .)
    NOTEQ           reduce using rule 22 (identifier -> ID .)
    GREATER         reduce using rule 22 (identifier -> ID .)
    GTEQUAL         reduce using rule 22 (identifier -> ID .)
    LESS            reduce using rule 22 (identifier -> ID .)
    LTEQUAL         reduce using rule 22 (identifier -> ID .)
    IN              reduce using rule 22 (identifier -> ID .)
    RBRACKET        reduce using rule 22 (identifier -> ID .)
    THEN            reduce using rule 22 (identifier -> ID .)
    RPAREN          reduce using rule 22 (identifier -> ID .)
    DCL             reduce using rule 22 (identifier -> ID .)
    SYN             reduce using rule 22 (identifier -> ID .)
    TYPE            reduce using rule 22 (identifier -> ID .)
    ID              reduce using rule 22 (identifier -> ID .)
    IF              reduce using rule 22 (identifier -> ID .)
    $end            reduce using rule 22 (identifier -> ID .)
    ELSE            reduce using rule 22 (identifier -> ID .)
    ELSIF           reduce using rule 22 (identifier -> ID .)
    FI              reduce using rule 22 (identifier -> ID .)
    REF             reduce using rule 22 (identifier -> ID .)
    INT             reduce using rule 22 (identifier -> ID .)
    BOOL            reduce using rule 22 (identifier -> ID .)
    CHAR            reduce using rule 22 (identifier -> ID .)
    CHARS           reduce using rule 22 (identifier -> ID .)
    ARRAY           reduce using rule 22 (identifier -> ID .)
=======
    (4) statement_nullable -> empty .

    $end            reduce using rule 4 (statement_nullable -> empty .)
    END             reduce using rule 4 (statement_nullable -> empty .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 22

<<<<<<< HEAD
    (134) action -> bracketed_action .

    ELSE            reduce using rule 134 (action -> bracketed_action .)
    ELSIF           reduce using rule 134 (action -> bracketed_action .)
    DCL             reduce using rule 134 (action -> bracketed_action .)
    SYN             reduce using rule 134 (action -> bracketed_action .)
    TYPE            reduce using rule 134 (action -> bracketed_action .)
    ID              reduce using rule 134 (action -> bracketed_action .)
    IF              reduce using rule 134 (action -> bracketed_action .)
    $end            reduce using rule 134 (action -> bracketed_action .)
    FI              reduce using rule 134 (action -> bracketed_action .)

=======
    (3) statement_nullable -> statement . statement_nullable
    (3) statement_nullable -> . statement statement_nullable
    (4) statement_nullable -> . empty
    (5) statement -> . declaration_statement
    (6) statement -> . synonym_statement
    (7) statement -> . newmode_statement
    (8) statement -> . procedure_statement
    (135) empty -> .
    (14) declaration_statement -> . DCL declaration_list SEMI
    (9) synonym_statement -> . SYN synonym_list SEMI
    (23) newmode_statement -> . TYPE newmode_list SEMI
    (27) procedure_statement -> . ID COLON procedure_definition

    $end            reduce using rule 135 (empty -> .)
    END             reduce using rule 135 (empty -> .)
    DCL             shift and go to state 7
    SYN             shift and go to state 11
    TYPE            shift and go to state 4
    ID              shift and go to state 2

    declaration_statement          shift and go to state 1
    newmode_statement              shift and go to state 8
    synonym_statement              shift and go to state 6
    procedure_statement            shift and go to state 5
    statement_nullable             shift and go to state 54
    statement                      shift and go to state 22
    empty                          shift and go to state 21
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

state 23

    (1) program -> statement_list .

    $end            reduce using rule 1 (program -> statement_list .)


state 24

<<<<<<< HEAD
    (132) action_statement -> identifier . COLON action
    (56) location -> identifier .
    (63) string_element -> identifier . LBRACKET start_element LBRACKET
    (65) string_slice -> identifier . LBRACKET left_element COLON right_element RBRACKET
=======
    (10) synonym_list -> synonym_definition .
    (11) synonym_list -> synonym_definition . COMMA synonym_list

    SEMI            reduce using rule 10 (synonym_list -> synonym_definition .)
    COMMA           shift and go to state 55

>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

  ! shift/reduce conflict for LBRACKET resolved as shift
    COLON           shift and go to state 84
    ARROW           reduce using rule 56 (location -> identifier .)
    ASSIGN          reduce using rule 56 (location -> identifier .)
    PLUS            reduce using rule 56 (location -> identifier .)
    MINUS           reduce using rule 56 (location -> identifier .)
    TIMES           reduce using rule 56 (location -> identifier .)
    DIVIDE          reduce using rule 56 (location -> identifier .)
    MODULO          reduce using rule 56 (location -> identifier .)
    CONCAT          reduce using rule 56 (location -> identifier .)
    LBRACKET        shift and go to state 85

  ! LBRACKET        [ reduce using rule 56 (location -> identifier .) ]

<<<<<<< HEAD

state 25

    (82) operand0 -> operand1 .
    (85) operand1 -> operand1 . operator2 operand2
    (101) operator2 -> . arithmetic_additive_operator
    (102) operator2 -> . string_concatenation_operator
    (103) arithmetic_additive_operator -> . PLUS
    (104) arithmetic_additive_operator -> . MINUS
    (105) string_concatenation_operator -> . CONCAT

    AND             reduce using rule 82 (operand0 -> operand1 .)
    OR              reduce using rule 82 (operand0 -> operand1 .)
    EQUAL           reduce using rule 82 (operand0 -> operand1 .)
    NOTEQ           reduce using rule 82 (operand0 -> operand1 .)
    GREATER         reduce using rule 82 (operand0 -> operand1 .)
    GTEQUAL         reduce using rule 82 (operand0 -> operand1 .)
    LESS            reduce using rule 82 (operand0 -> operand1 .)
    LTEQUAL         reduce using rule 82 (operand0 -> operand1 .)
    IN              reduce using rule 82 (operand0 -> operand1 .)
    LBRACKET        reduce using rule 82 (operand0 -> operand1 .)
    COLON           reduce using rule 82 (operand0 -> operand1 .)
    RPAREN          reduce using rule 82 (operand0 -> operand1 .)
    COMMA           reduce using rule 82 (operand0 -> operand1 .)
    RBRACKET        reduce using rule 82 (operand0 -> operand1 .)
    FI              reduce using rule 82 (operand0 -> operand1 .)
    SEMI            reduce using rule 82 (operand0 -> operand1 .)
    DCL             reduce using rule 82 (operand0 -> operand1 .)
    SYN             reduce using rule 82 (operand0 -> operand1 .)
    TYPE            reduce using rule 82 (operand0 -> operand1 .)
    ID              reduce using rule 82 (operand0 -> operand1 .)
    IF              reduce using rule 82 (operand0 -> operand1 .)
    $end            reduce using rule 82 (operand0 -> operand1 .)
    ELSE            reduce using rule 82 (operand0 -> operand1 .)
    ELSIF           reduce using rule 82 (operand0 -> operand1 .)
    THEN            reduce using rule 82 (operand0 -> operand1 .)
    PLUS            shift and go to state 64
    MINUS           shift and go to state 74
    CONCAT          shift and go to state 68

    arithmetic_additive_operator   shift and go to state 86
    string_concatenation_operator  shift and go to state 87
    operator2                      shift and go to state 88

state 26

    (143) if_action -> IF expression . then_clause else_clause FI
    (144) if_action -> IF expression . then_clause
    (145) then_clause -> . THEN action_statement_list

    THEN            shift and go to state 90

    then_clause                    shift and go to state 89

state 27

    (130) empty_literal -> NULL .

    LBRACKET        reduce using rule 130 (empty_literal -> NULL .)
    TIMES           reduce using rule 130 (empty_literal -> NULL .)
    DIVIDE          reduce using rule 130 (empty_literal -> NULL .)
    MODULO          reduce using rule 130 (empty_literal -> NULL .)
    PLUS            reduce using rule 130 (empty_literal -> NULL .)
    MINUS           reduce using rule 130 (empty_literal -> NULL .)
    CONCAT          reduce using rule 130 (empty_literal -> NULL .)
    AND             reduce using rule 130 (empty_literal -> NULL .)
    OR              reduce using rule 130 (empty_literal -> NULL .)
    EQUAL           reduce using rule 130 (empty_literal -> NULL .)
    NOTEQ           reduce using rule 130 (empty_literal -> NULL .)
    GREATER         reduce using rule 130 (empty_literal -> NULL .)
    GTEQUAL         reduce using rule 130 (empty_literal -> NULL .)
    LESS            reduce using rule 130 (empty_literal -> NULL .)
    LTEQUAL         reduce using rule 130 (empty_literal -> NULL .)
    IN              reduce using rule 130 (empty_literal -> NULL .)
    DCL             reduce using rule 130 (empty_literal -> NULL .)
    SYN             reduce using rule 130 (empty_literal -> NULL .)
    TYPE            reduce using rule 130 (empty_literal -> NULL .)
    ID              reduce using rule 130 (empty_literal -> NULL .)
    IF              reduce using rule 130 (empty_literal -> NULL .)
    $end            reduce using rule 130 (empty_literal -> NULL .)
    ELSE            reduce using rule 130 (empty_literal -> NULL .)
    ELSIF           reduce using rule 130 (empty_literal -> NULL .)
    FI              reduce using rule 130 (empty_literal -> NULL .)
    COMMA           reduce using rule 130 (empty_literal -> NULL .)
    RBRACKET        reduce using rule 130 (empty_literal -> NULL .)
    COLON           reduce using rule 130 (empty_literal -> NULL .)
    THEN            reduce using rule 130 (empty_literal -> NULL .)
    RPAREN          reduce using rule 130 (empty_literal -> NULL .)
    SEMI            reduce using rule 130 (empty_literal -> NULL .)
=======
    (9) synonym_statement -> SYN synonym_list . SEMI

    SEMI            shift and go to state 56


state 26

    (12) synonym_definition -> identifier_list . mode ASSIGN expression
    (13) synonym_definition -> identifier_list . ASSIGN expression
    (36) mode -> . mode_name
    (37) mode -> . discrete_mode
    (38) mode -> . reference_mode
    (39) mode -> . composite_mode
    (40) mode_name -> . identifier
    (41) discrete_mode -> . integer_mode
    (42) discrete_mode -> . boolean_mode
    (43) discrete_mode -> . character_mode
    (44) discrete_mode -> . discrete_range_mode
    (54) reference_mode -> . REF mode
    (55) composite_mode -> . string_mode
    (56) composite_mode -> . array_mode
    (22) identifier -> . ID
    (46) integer_mode -> . INT
    (47) boolean_mode -> . BOOL
    (48) character_mode -> . CHAR
    (49) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (50) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (57) string_mode -> . CHARS LBRACKET string_length RBRACKET
    (59) array_mode -> . ARRAY LBRACKET index_mode_list RBRACKET element_mode
    (45) discrete_mode_name -> . identifier

    ASSIGN          shift and go to state 57
    REF             shift and go to state 38
    ID              shift and go to state 15
    INT             shift and go to state 39
    BOOL            shift and go to state 53
    CHAR            shift and go to state 51
    CHARS           shift and go to state 43
    ARRAY           shift and go to state 52

    discrete_range_mode            shift and go to state 45
    identifier                     shift and go to state 36
    composite_mode                 shift and go to state 46
    character_mode                 shift and go to state 47
    array_mode                     shift and go to state 42
    discrete_mode_name             shift and go to state 48
    mode                           shift and go to state 58
    boolean_mode                   shift and go to state 50
    mode_name                      shift and go to state 41
    reference_mode                 shift and go to state 35
    integer_mode                   shift and go to state 40
    string_mode                    shift and go to state 44
    discrete_mode                  shift and go to state 37

state 27

    (28) procedure_definition -> PROC . LPAREN formal_parameter_list RPAREN result_spec SEMI statement_nullable END SEMI
    (29) procedure_definition -> PROC . LPAREN formal_parameter_list RPAREN SEMI statement_nullable END SEMI

    LPAREN          shift and go to state 59
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 28

<<<<<<< HEAD
    (74) expression -> conditional_expression .

    THEN            reduce using rule 74 (expression -> conditional_expression .)
    DCL             reduce using rule 74 (expression -> conditional_expression .)
    SYN             reduce using rule 74 (expression -> conditional_expression .)
    TYPE            reduce using rule 74 (expression -> conditional_expression .)
    ID              reduce using rule 74 (expression -> conditional_expression .)
    IF              reduce using rule 74 (expression -> conditional_expression .)
    $end            reduce using rule 74 (expression -> conditional_expression .)
    ELSE            reduce using rule 74 (expression -> conditional_expression .)
    ELSIF           reduce using rule 74 (expression -> conditional_expression .)
    FI              reduce using rule 74 (expression -> conditional_expression .)
    COLON           reduce using rule 74 (expression -> conditional_expression .)
    COMMA           reduce using rule 74 (expression -> conditional_expression .)
    RBRACKET        reduce using rule 74 (expression -> conditional_expression .)
    SEMI            reduce using rule 74 (expression -> conditional_expression .)
    LBRACKET        reduce using rule 74 (expression -> conditional_expression .)
    RPAREN          reduce using rule 74 (expression -> conditional_expression .)
=======
    (27) procedure_statement -> ID COLON procedure_definition .

    DCL             reduce using rule 27 (procedure_statement -> ID COLON procedure_definition .)
    SYN             reduce using rule 27 (procedure_statement -> ID COLON procedure_definition .)
    TYPE            reduce using rule 27 (procedure_statement -> ID COLON procedure_definition .)
    ID              reduce using rule 27 (procedure_statement -> ID COLON procedure_definition .)
    $end            reduce using rule 27 (procedure_statement -> ID COLON procedure_definition .)
    END             reduce using rule 27 (procedure_statement -> ID COLON procedure_definition .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 29

<<<<<<< HEAD
    (91) operand4 -> referenced_location .

    TIMES           reduce using rule 91 (operand4 -> referenced_location .)
    DIVIDE          reduce using rule 91 (operand4 -> referenced_location .)
    MODULO          reduce using rule 91 (operand4 -> referenced_location .)
    PLUS            reduce using rule 91 (operand4 -> referenced_location .)
    MINUS           reduce using rule 91 (operand4 -> referenced_location .)
    CONCAT          reduce using rule 91 (operand4 -> referenced_location .)
    AND             reduce using rule 91 (operand4 -> referenced_location .)
    OR              reduce using rule 91 (operand4 -> referenced_location .)
    EQUAL           reduce using rule 91 (operand4 -> referenced_location .)
    NOTEQ           reduce using rule 91 (operand4 -> referenced_location .)
    GREATER         reduce using rule 91 (operand4 -> referenced_location .)
    GTEQUAL         reduce using rule 91 (operand4 -> referenced_location .)
    LESS            reduce using rule 91 (operand4 -> referenced_location .)
    LTEQUAL         reduce using rule 91 (operand4 -> referenced_location .)
    IN              reduce using rule 91 (operand4 -> referenced_location .)
    RBRACKET        reduce using rule 91 (operand4 -> referenced_location .)
    RPAREN          reduce using rule 91 (operand4 -> referenced_location .)
    THEN            reduce using rule 91 (operand4 -> referenced_location .)
    DCL             reduce using rule 91 (operand4 -> referenced_location .)
    SYN             reduce using rule 91 (operand4 -> referenced_location .)
    TYPE            reduce using rule 91 (operand4 -> referenced_location .)
    ID              reduce using rule 91 (operand4 -> referenced_location .)
    IF              reduce using rule 91 (operand4 -> referenced_location .)
    $end            reduce using rule 91 (operand4 -> referenced_location .)
    ELSE            reduce using rule 91 (operand4 -> referenced_location .)
    ELSIF           reduce using rule 91 (operand4 -> referenced_location .)
    FI              reduce using rule 91 (operand4 -> referenced_location .)
    COMMA           reduce using rule 91 (operand4 -> referenced_location .)
    COLON           reduce using rule 91 (operand4 -> referenced_location .)
    LBRACKET        reduce using rule 91 (operand4 -> referenced_location .)
    SEMI            reduce using rule 91 (operand4 -> referenced_location .)
=======
    (23) newmode_statement -> TYPE newmode_list SEMI .

    DCL             reduce using rule 23 (newmode_statement -> TYPE newmode_list SEMI .)
    SYN             reduce using rule 23 (newmode_statement -> TYPE newmode_list SEMI .)
    TYPE            reduce using rule 23 (newmode_statement -> TYPE newmode_list SEMI .)
    ID              reduce using rule 23 (newmode_statement -> TYPE newmode_list SEMI .)
    $end            reduce using rule 23 (newmode_statement -> TYPE newmode_list SEMI .)
    END             reduce using rule 23 (newmode_statement -> TYPE newmode_list SEMI .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 30

<<<<<<< HEAD
    (118) primitive_value -> parenthesized_expression .

    LBRACKET        reduce using rule 118 (primitive_value -> parenthesized_expression .)
    TIMES           reduce using rule 118 (primitive_value -> parenthesized_expression .)
    DIVIDE          reduce using rule 118 (primitive_value -> parenthesized_expression .)
    MODULO          reduce using rule 118 (primitive_value -> parenthesized_expression .)
    PLUS            reduce using rule 118 (primitive_value -> parenthesized_expression .)
    MINUS           reduce using rule 118 (primitive_value -> parenthesized_expression .)
    CONCAT          reduce using rule 118 (primitive_value -> parenthesized_expression .)
    AND             reduce using rule 118 (primitive_value -> parenthesized_expression .)
    OR              reduce using rule 118 (primitive_value -> parenthesized_expression .)
    EQUAL           reduce using rule 118 (primitive_value -> parenthesized_expression .)
    NOTEQ           reduce using rule 118 (primitive_value -> parenthesized_expression .)
    GREATER         reduce using rule 118 (primitive_value -> parenthesized_expression .)
    GTEQUAL         reduce using rule 118 (primitive_value -> parenthesized_expression .)
    LESS            reduce using rule 118 (primitive_value -> parenthesized_expression .)
    LTEQUAL         reduce using rule 118 (primitive_value -> parenthesized_expression .)
    IN              reduce using rule 118 (primitive_value -> parenthesized_expression .)
    COMMA           reduce using rule 118 (primitive_value -> parenthesized_expression .)
    SEMI            reduce using rule 118 (primitive_value -> parenthesized_expression .)
    THEN            reduce using rule 118 (primitive_value -> parenthesized_expression .)
    COLON           reduce using rule 118 (primitive_value -> parenthesized_expression .)
    RBRACKET        reduce using rule 118 (primitive_value -> parenthesized_expression .)
    RPAREN          reduce using rule 118 (primitive_value -> parenthesized_expression .)
    DCL             reduce using rule 118 (primitive_value -> parenthesized_expression .)
    SYN             reduce using rule 118 (primitive_value -> parenthesized_expression .)
    TYPE            reduce using rule 118 (primitive_value -> parenthesized_expression .)
    ID              reduce using rule 118 (primitive_value -> parenthesized_expression .)
    IF              reduce using rule 118 (primitive_value -> parenthesized_expression .)
    $end            reduce using rule 118 (primitive_value -> parenthesized_expression .)
    ELSE            reduce using rule 118 (primitive_value -> parenthesized_expression .)
    ELSIF           reduce using rule 118 (primitive_value -> parenthesized_expression .)
    FI              reduce using rule 118 (primitive_value -> parenthesized_expression .)
=======
    (25) newmode_list -> mode_definition COMMA . newmode_list
    (24) newmode_list -> . mode_definition
    (25) newmode_list -> . mode_definition COMMA newmode_list
    (26) mode_definition -> . identifier_list ASSIGN mode
    (20) identifier_list -> . identifier
    (21) identifier_list -> . identifier COMMA identifier_list
    (22) identifier -> . ID

    ID              shift and go to state 15
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

    identifier                     shift and go to state 16
    newmode_list                   shift and go to state 60
    mode_definition                shift and go to state 14
    identifier_list                shift and go to state 17

state 31

<<<<<<< HEAD
    (76) conditional_expression -> IF . expression then_expression else_expression FI
    (77) conditional_expression -> IF . expression then_expression elsif_expression else_expression FI
    (73) expression -> . operand0
    (74) expression -> . conditional_expression
    (82) operand0 -> . operand1
    (83) operand0 -> . operand0 operator1 operand1
    (76) conditional_expression -> . IF expression then_expression else_expression FI
    (77) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (84) operand1 -> . operand2
    (85) operand1 -> . operand1 operator2 operand2
    (86) operand2 -> . operand3
    (87) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (88) operand3 -> . monadic_operator operand4
    (89) operand3 -> . operand4
    (96) monadic_operator -> . MINUS
    (97) monadic_operator -> . NOT
    (90) operand4 -> . array_location
    (91) operand4 -> . referenced_location
    (92) operand4 -> . primitive_value
    (72) array_location -> . location
    (98) referenced_location -> . ARROW array_location
    (115) primitive_value -> . literal
    (116) primitive_value -> . value_array_element
    (117) primitive_value -> . value_array_slice
    (118) primitive_value -> . parenthesized_expression
    (56) location -> . identifier
    (57) location -> . dereferenced_reference
    (58) location -> . string_element
    (59) location -> . string_slice
    (60) location -> . array_element
    (61) location -> . array_slice
    (119) literal -> . integer_literal
    (120) literal -> . boolean_literal
    (121) literal -> . character_literal
    (122) literal -> . empty_literal
    (123) literal -> . character_string_literal
    (124) value_array_element -> . primitive_value LBRACKET expression_list RBRACKET
    (125) value_array_slice -> . primitive_value LBRACKET expression COLON expression RBRACKET
    (75) parenthesized_expression -> . LPAREN expression RPAREN
    (22) identifier -> . ID
    (62) dereferenced_reference -> . array_location ARROW
    (63) string_element -> . identifier LBRACKET start_element LBRACKET
    (65) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (68) array_element -> . array_location LBRACKET expression_list RBRACKET
    (71) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (126) integer_literal -> . ICONST
    (127) boolean_literal -> . TRUE
    (128) boolean_literal -> . FALSE
    (129) character_literal -> . CCONST
    (130) empty_literal -> . NULL
    (131) character_string_literal -> . SCONST

    IF              shift and go to state 31
    MINUS           shift and go to state 36
    NOT             shift and go to state 35
    ARROW           shift and go to state 45
    LPAREN          shift and go to state 44
    ID              shift and go to state 21
    ICONST          shift and go to state 40
    TRUE            shift and go to state 55
    FALSE           shift and go to state 53
    CCONST          shift and go to state 34
    NULL            shift and go to state 27
    SCONST          shift and go to state 52

    location                       shift and go to state 6
    monadic_operator               shift and go to state 47
    operand2                       shift and go to state 49
    value_array_element            shift and go to state 48
    operand1                       shift and go to state 25
    expression                     shift and go to state 91
    conditional_expression         shift and go to state 28
    referenced_location            shift and go to state 29
    parenthesized_expression       shift and go to state 30
    array_slice                    shift and go to state 15
    integer_literal                shift and go to state 32
    empty_literal                  shift and go to state 50
    array_element                  shift and go to state 7
    operand3                       shift and go to state 33
    string_slice                   shift and go to state 3
    string_element                 shift and go to state 1
    boolean_literal                shift and go to state 51
    array_location                 shift and go to state 46
    literal                        shift and go to state 37
    operand0                       shift and go to state 38
    primitive_value                shift and go to state 39
    character_literal              shift and go to state 41
    value_array_slice              shift and go to state 42
    operand4                       shift and go to state 54
    character_string_literal       shift and go to state 43
    dereferenced_reference         shift and go to state 20
    identifier                     shift and go to state 56

state 32

    (119) literal -> integer_literal .

    LBRACKET        reduce using rule 119 (literal -> integer_literal .)
    TIMES           reduce using rule 119 (literal -> integer_literal .)
    DIVIDE          reduce using rule 119 (literal -> integer_literal .)
    MODULO          reduce using rule 119 (literal -> integer_literal .)
    PLUS            reduce using rule 119 (literal -> integer_literal .)
    MINUS           reduce using rule 119 (literal -> integer_literal .)
    CONCAT          reduce using rule 119 (literal -> integer_literal .)
    AND             reduce using rule 119 (literal -> integer_literal .)
    OR              reduce using rule 119 (literal -> integer_literal .)
    EQUAL           reduce using rule 119 (literal -> integer_literal .)
    NOTEQ           reduce using rule 119 (literal -> integer_literal .)
    GREATER         reduce using rule 119 (literal -> integer_literal .)
    GTEQUAL         reduce using rule 119 (literal -> integer_literal .)
    LESS            reduce using rule 119 (literal -> integer_literal .)
    LTEQUAL         reduce using rule 119 (literal -> integer_literal .)
    IN              reduce using rule 119 (literal -> integer_literal .)
    FI              reduce using rule 119 (literal -> integer_literal .)
    THEN            reduce using rule 119 (literal -> integer_literal .)
    RPAREN          reduce using rule 119 (literal -> integer_literal .)
    DCL             reduce using rule 119 (literal -> integer_literal .)
    SYN             reduce using rule 119 (literal -> integer_literal .)
    TYPE            reduce using rule 119 (literal -> integer_literal .)
    ID              reduce using rule 119 (literal -> integer_literal .)
    IF              reduce using rule 119 (literal -> integer_literal .)
    $end            reduce using rule 119 (literal -> integer_literal .)
    ELSE            reduce using rule 119 (literal -> integer_literal .)
    ELSIF           reduce using rule 119 (literal -> integer_literal .)
    COMMA           reduce using rule 119 (literal -> integer_literal .)
    RBRACKET        reduce using rule 119 (literal -> integer_literal .)
    COLON           reduce using rule 119 (literal -> integer_literal .)
    SEMI            reduce using rule 119 (literal -> integer_literal .)


state 33

    (86) operand2 -> operand3 .

    TIMES           reduce using rule 86 (operand2 -> operand3 .)
    DIVIDE          reduce using rule 86 (operand2 -> operand3 .)
    MODULO          reduce using rule 86 (operand2 -> operand3 .)
    PLUS            reduce using rule 86 (operand2 -> operand3 .)
    MINUS           reduce using rule 86 (operand2 -> operand3 .)
    CONCAT          reduce using rule 86 (operand2 -> operand3 .)
    AND             reduce using rule 86 (operand2 -> operand3 .)
    OR              reduce using rule 86 (operand2 -> operand3 .)
    EQUAL           reduce using rule 86 (operand2 -> operand3 .)
    NOTEQ           reduce using rule 86 (operand2 -> operand3 .)
    GREATER         reduce using rule 86 (operand2 -> operand3 .)
    GTEQUAL         reduce using rule 86 (operand2 -> operand3 .)
    LESS            reduce using rule 86 (operand2 -> operand3 .)
    LTEQUAL         reduce using rule 86 (operand2 -> operand3 .)
    IN              reduce using rule 86 (operand2 -> operand3 .)
    THEN            reduce using rule 86 (operand2 -> operand3 .)
    RPAREN          reduce using rule 86 (operand2 -> operand3 .)
    DCL             reduce using rule 86 (operand2 -> operand3 .)
    SYN             reduce using rule 86 (operand2 -> operand3 .)
    TYPE            reduce using rule 86 (operand2 -> operand3 .)
    ID              reduce using rule 86 (operand2 -> operand3 .)
    IF              reduce using rule 86 (operand2 -> operand3 .)
    $end            reduce using rule 86 (operand2 -> operand3 .)
    ELSE            reduce using rule 86 (operand2 -> operand3 .)
    ELSIF           reduce using rule 86 (operand2 -> operand3 .)
    FI              reduce using rule 86 (operand2 -> operand3 .)
    COMMA           reduce using rule 86 (operand2 -> operand3 .)
    RBRACKET        reduce using rule 86 (operand2 -> operand3 .)
    COLON           reduce using rule 86 (operand2 -> operand3 .)
    LBRACKET        reduce using rule 86 (operand2 -> operand3 .)
    SEMI            reduce using rule 86 (operand2 -> operand3 .)
=======
    (21) identifier_list -> identifier COMMA . identifier_list
    (20) identifier_list -> . identifier
    (21) identifier_list -> . identifier COMMA identifier_list
    (22) identifier -> . ID

    ID              shift and go to state 15

    identifier_list                shift and go to state 61
    identifier                     shift and go to state 16

state 32

    (26) mode_definition -> identifier_list ASSIGN . mode
    (36) mode -> . mode_name
    (37) mode -> . discrete_mode
    (38) mode -> . reference_mode
    (39) mode -> . composite_mode
    (40) mode_name -> . identifier
    (41) discrete_mode -> . integer_mode
    (42) discrete_mode -> . boolean_mode
    (43) discrete_mode -> . character_mode
    (44) discrete_mode -> . discrete_range_mode
    (54) reference_mode -> . REF mode
    (55) composite_mode -> . string_mode
    (56) composite_mode -> . array_mode
    (22) identifier -> . ID
    (46) integer_mode -> . INT
    (47) boolean_mode -> . BOOL
    (48) character_mode -> . CHAR
    (49) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (50) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (57) string_mode -> . CHARS LBRACKET string_length RBRACKET
    (59) array_mode -> . ARRAY LBRACKET index_mode_list RBRACKET element_mode
    (45) discrete_mode_name -> . identifier

    REF             shift and go to state 38
    ID              shift and go to state 15
    INT             shift and go to state 39
    BOOL            shift and go to state 53
    CHAR            shift and go to state 51
    CHARS           shift and go to state 43
    ARRAY           shift and go to state 52

    discrete_range_mode            shift and go to state 45
    identifier                     shift and go to state 36
    composite_mode                 shift and go to state 46
    character_mode                 shift and go to state 47
    discrete_mode_name             shift and go to state 48
    mode                           shift and go to state 62
    boolean_mode                   shift and go to state 50
    mode_name                      shift and go to state 41
    reference_mode                 shift and go to state 35
    array_mode                     shift and go to state 42
    integer_mode                   shift and go to state 40
    string_mode                    shift and go to state 44
    discrete_mode                  shift and go to state 37

state 33

    (14) declaration_statement -> DCL declaration_list SEMI .

    DCL             reduce using rule 14 (declaration_statement -> DCL declaration_list SEMI .)
    SYN             reduce using rule 14 (declaration_statement -> DCL declaration_list SEMI .)
    TYPE            reduce using rule 14 (declaration_statement -> DCL declaration_list SEMI .)
    ID              reduce using rule 14 (declaration_statement -> DCL declaration_list SEMI .)
    END             reduce using rule 14 (declaration_statement -> DCL declaration_list SEMI .)
    $end            reduce using rule 14 (declaration_statement -> DCL declaration_list SEMI .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 34

<<<<<<< HEAD
    (129) character_literal -> CCONST .

    LBRACKET        reduce using rule 129 (character_literal -> CCONST .)
    TIMES           reduce using rule 129 (character_literal -> CCONST .)
    DIVIDE          reduce using rule 129 (character_literal -> CCONST .)
    MODULO          reduce using rule 129 (character_literal -> CCONST .)
    PLUS            reduce using rule 129 (character_literal -> CCONST .)
    MINUS           reduce using rule 129 (character_literal -> CCONST .)
    CONCAT          reduce using rule 129 (character_literal -> CCONST .)
    AND             reduce using rule 129 (character_literal -> CCONST .)
    OR              reduce using rule 129 (character_literal -> CCONST .)
    EQUAL           reduce using rule 129 (character_literal -> CCONST .)
    NOTEQ           reduce using rule 129 (character_literal -> CCONST .)
    GREATER         reduce using rule 129 (character_literal -> CCONST .)
    GTEQUAL         reduce using rule 129 (character_literal -> CCONST .)
    LESS            reduce using rule 129 (character_literal -> CCONST .)
    LTEQUAL         reduce using rule 129 (character_literal -> CCONST .)
    IN              reduce using rule 129 (character_literal -> CCONST .)
    RBRACKET        reduce using rule 129 (character_literal -> CCONST .)
    COLON           reduce using rule 129 (character_literal -> CCONST .)
    THEN            reduce using rule 129 (character_literal -> CCONST .)
    RPAREN          reduce using rule 129 (character_literal -> CCONST .)
    DCL             reduce using rule 129 (character_literal -> CCONST .)
    SYN             reduce using rule 129 (character_literal -> CCONST .)
    TYPE            reduce using rule 129 (character_literal -> CCONST .)
    ID              reduce using rule 129 (character_literal -> CCONST .)
    IF              reduce using rule 129 (character_literal -> CCONST .)
    $end            reduce using rule 129 (character_literal -> CCONST .)
    ELSE            reduce using rule 129 (character_literal -> CCONST .)
    ELSIF           reduce using rule 129 (character_literal -> CCONST .)
    FI              reduce using rule 129 (character_literal -> CCONST .)
    COMMA           reduce using rule 129 (character_literal -> CCONST .)
    SEMI            reduce using rule 129 (character_literal -> CCONST .)
=======
    (16) declaration_list -> declaration COMMA . declaration_list
    (15) declaration_list -> . declaration
    (16) declaration_list -> . declaration COMMA declaration_list
    (17) declaration -> . identifier_list mode initialization
    (18) declaration -> . identifier_list mode
    (20) identifier_list -> . identifier
    (21) identifier_list -> . identifier COMMA identifier_list
    (22) identifier -> . ID

    ID              shift and go to state 15
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

    declaration_list               shift and go to state 63
    identifier                     shift and go to state 16
    declaration                    shift and go to state 19
    identifier_list                shift and go to state 20

state 35

<<<<<<< HEAD
    (97) monadic_operator -> NOT .

    ARROW           reduce using rule 97 (monadic_operator -> NOT .)
    LPAREN          reduce using rule 97 (monadic_operator -> NOT .)
    ID              reduce using rule 97 (monadic_operator -> NOT .)
    ICONST          reduce using rule 97 (monadic_operator -> NOT .)
    TRUE            reduce using rule 97 (monadic_operator -> NOT .)
    FALSE           reduce using rule 97 (monadic_operator -> NOT .)
    CCONST          reduce using rule 97 (monadic_operator -> NOT .)
    NULL            reduce using rule 97 (monadic_operator -> NOT .)
    SCONST          reduce using rule 97 (monadic_operator -> NOT .)
=======
    (38) mode -> reference_mode .

    LOC             reduce using rule 38 (mode -> reference_mode .)
    RPAREN          reduce using rule 38 (mode -> reference_mode .)
    ASSIGN          reduce using rule 38 (mode -> reference_mode .)
    COMMA           reduce using rule 38 (mode -> reference_mode .)
    SEMI            reduce using rule 38 (mode -> reference_mode .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 36

<<<<<<< HEAD
    (96) monadic_operator -> MINUS .

    ARROW           reduce using rule 96 (monadic_operator -> MINUS .)
    LPAREN          reduce using rule 96 (monadic_operator -> MINUS .)
    ID              reduce using rule 96 (monadic_operator -> MINUS .)
    ICONST          reduce using rule 96 (monadic_operator -> MINUS .)
    TRUE            reduce using rule 96 (monadic_operator -> MINUS .)
    FALSE           reduce using rule 96 (monadic_operator -> MINUS .)
    CCONST          reduce using rule 96 (monadic_operator -> MINUS .)
    NULL            reduce using rule 96 (monadic_operator -> MINUS .)
    SCONST          reduce using rule 96 (monadic_operator -> MINUS .)
=======
    (40) mode_name -> identifier .
    (45) discrete_mode_name -> identifier .

    ASSIGN          reduce using rule 40 (mode_name -> identifier .)
    COMMA           reduce using rule 40 (mode_name -> identifier .)
    SEMI            reduce using rule 40 (mode_name -> identifier .)
    LOC             reduce using rule 40 (mode_name -> identifier .)
    RPAREN          reduce using rule 40 (mode_name -> identifier .)
    LPAREN          reduce using rule 45 (discrete_mode_name -> identifier .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 37

<<<<<<< HEAD
    (115) primitive_value -> literal .

    LBRACKET        reduce using rule 115 (primitive_value -> literal .)
    TIMES           reduce using rule 115 (primitive_value -> literal .)
    DIVIDE          reduce using rule 115 (primitive_value -> literal .)
    MODULO          reduce using rule 115 (primitive_value -> literal .)
    PLUS            reduce using rule 115 (primitive_value -> literal .)
    MINUS           reduce using rule 115 (primitive_value -> literal .)
    CONCAT          reduce using rule 115 (primitive_value -> literal .)
    AND             reduce using rule 115 (primitive_value -> literal .)
    OR              reduce using rule 115 (primitive_value -> literal .)
    EQUAL           reduce using rule 115 (primitive_value -> literal .)
    NOTEQ           reduce using rule 115 (primitive_value -> literal .)
    GREATER         reduce using rule 115 (primitive_value -> literal .)
    GTEQUAL         reduce using rule 115 (primitive_value -> literal .)
    LESS            reduce using rule 115 (primitive_value -> literal .)
    LTEQUAL         reduce using rule 115 (primitive_value -> literal .)
    IN              reduce using rule 115 (primitive_value -> literal .)
    COMMA           reduce using rule 115 (primitive_value -> literal .)
    SEMI            reduce using rule 115 (primitive_value -> literal .)
    THEN            reduce using rule 115 (primitive_value -> literal .)
    COLON           reduce using rule 115 (primitive_value -> literal .)
    RBRACKET        reduce using rule 115 (primitive_value -> literal .)
    RPAREN          reduce using rule 115 (primitive_value -> literal .)
    DCL             reduce using rule 115 (primitive_value -> literal .)
    SYN             reduce using rule 115 (primitive_value -> literal .)
    TYPE            reduce using rule 115 (primitive_value -> literal .)
    ID              reduce using rule 115 (primitive_value -> literal .)
    IF              reduce using rule 115 (primitive_value -> literal .)
    $end            reduce using rule 115 (primitive_value -> literal .)
    ELSE            reduce using rule 115 (primitive_value -> literal .)
    ELSIF           reduce using rule 115 (primitive_value -> literal .)
    FI              reduce using rule 115 (primitive_value -> literal .)
=======
    (37) mode -> discrete_mode .
    (50) discrete_range_mode -> discrete_mode . LPAREN literal_range RPAREN

    LOC             reduce using rule 37 (mode -> discrete_mode .)
    RPAREN          reduce using rule 37 (mode -> discrete_mode .)
    ASSIGN          reduce using rule 37 (mode -> discrete_mode .)
    COMMA           reduce using rule 37 (mode -> discrete_mode .)
    SEMI            reduce using rule 37 (mode -> discrete_mode .)
    LPAREN          shift and go to state 64
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 38

<<<<<<< HEAD
    (73) expression -> operand0 .
    (83) operand0 -> operand0 . operator1 operand1
    (99) operator1 -> . relational_operator
    (100) operator1 -> . membership_operator
    (106) relational_operator -> . AND
    (107) relational_operator -> . OR
    (108) relational_operator -> . EQUAL
    (109) relational_operator -> . NOTEQ
    (110) relational_operator -> . GREATER
    (111) relational_operator -> . GTEQUAL
    (112) relational_operator -> . LESS
    (113) relational_operator -> . LTEQUAL
    (114) membership_operator -> . IN

    THEN            reduce using rule 73 (expression -> operand0 .)
    DCL             reduce using rule 73 (expression -> operand0 .)
    SYN             reduce using rule 73 (expression -> operand0 .)
    TYPE            reduce using rule 73 (expression -> operand0 .)
    ID              reduce using rule 73 (expression -> operand0 .)
    IF              reduce using rule 73 (expression -> operand0 .)
    $end            reduce using rule 73 (expression -> operand0 .)
    ELSE            reduce using rule 73 (expression -> operand0 .)
    ELSIF           reduce using rule 73 (expression -> operand0 .)
    FI              reduce using rule 73 (expression -> operand0 .)
    COLON           reduce using rule 73 (expression -> operand0 .)
    COMMA           reduce using rule 73 (expression -> operand0 .)
    RBRACKET        reduce using rule 73 (expression -> operand0 .)
    SEMI            reduce using rule 73 (expression -> operand0 .)
    LBRACKET        reduce using rule 73 (expression -> operand0 .)
    RPAREN          reduce using rule 73 (expression -> operand0 .)
    AND             shift and go to state 96
    OR              shift and go to state 100
    EQUAL           shift and go to state 103
    NOTEQ           shift and go to state 97
    GREATER         shift and go to state 102
    GTEQUAL         shift and go to state 98
    LESS            shift and go to state 93
    LTEQUAL         shift and go to state 95
    IN              shift and go to state 101

    relational_operator            shift and go to state 94
    membership_operator            shift and go to state 99
    operator1                      shift and go to state 92

state 39

    (92) operand4 -> primitive_value .
    (124) value_array_element -> primitive_value . LBRACKET expression_list RBRACKET
    (125) value_array_slice -> primitive_value . LBRACKET expression COLON expression RBRACKET

  ! shift/reduce conflict for LBRACKET resolved as shift
    TIMES           reduce using rule 92 (operand4 -> primitive_value .)
    DIVIDE          reduce using rule 92 (operand4 -> primitive_value .)
    MODULO          reduce using rule 92 (operand4 -> primitive_value .)
    PLUS            reduce using rule 92 (operand4 -> primitive_value .)
    MINUS           reduce using rule 92 (operand4 -> primitive_value .)
    CONCAT          reduce using rule 92 (operand4 -> primitive_value .)
    AND             reduce using rule 92 (operand4 -> primitive_value .)
    OR              reduce using rule 92 (operand4 -> primitive_value .)
    EQUAL           reduce using rule 92 (operand4 -> primitive_value .)
    NOTEQ           reduce using rule 92 (operand4 -> primitive_value .)
    GREATER         reduce using rule 92 (operand4 -> primitive_value .)
    GTEQUAL         reduce using rule 92 (operand4 -> primitive_value .)
    LESS            reduce using rule 92 (operand4 -> primitive_value .)
    LTEQUAL         reduce using rule 92 (operand4 -> primitive_value .)
    IN              reduce using rule 92 (operand4 -> primitive_value .)
    RBRACKET        reduce using rule 92 (operand4 -> primitive_value .)
    RPAREN          reduce using rule 92 (operand4 -> primitive_value .)
    THEN            reduce using rule 92 (operand4 -> primitive_value .)
    DCL             reduce using rule 92 (operand4 -> primitive_value .)
    SYN             reduce using rule 92 (operand4 -> primitive_value .)
    TYPE            reduce using rule 92 (operand4 -> primitive_value .)
    ID              reduce using rule 92 (operand4 -> primitive_value .)
    IF              reduce using rule 92 (operand4 -> primitive_value .)
    $end            reduce using rule 92 (operand4 -> primitive_value .)
    ELSE            reduce using rule 92 (operand4 -> primitive_value .)
    ELSIF           reduce using rule 92 (operand4 -> primitive_value .)
    FI              reduce using rule 92 (operand4 -> primitive_value .)
    COMMA           reduce using rule 92 (operand4 -> primitive_value .)
    COLON           reduce using rule 92 (operand4 -> primitive_value .)
    SEMI            reduce using rule 92 (operand4 -> primitive_value .)
    LBRACKET        shift and go to state 104

  ! LBRACKET        [ reduce using rule 92 (operand4 -> primitive_value .) ]
=======
    (54) reference_mode -> REF . mode
    (36) mode -> . mode_name
    (37) mode -> . discrete_mode
    (38) mode -> . reference_mode
    (39) mode -> . composite_mode
    (40) mode_name -> . identifier
    (41) discrete_mode -> . integer_mode
    (42) discrete_mode -> . boolean_mode
    (43) discrete_mode -> . character_mode
    (44) discrete_mode -> . discrete_range_mode
    (54) reference_mode -> . REF mode
    (55) composite_mode -> . string_mode
    (56) composite_mode -> . array_mode
    (22) identifier -> . ID
    (46) integer_mode -> . INT
    (47) boolean_mode -> . BOOL
    (48) character_mode -> . CHAR
    (49) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (50) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (57) string_mode -> . CHARS LBRACKET string_length RBRACKET
    (59) array_mode -> . ARRAY LBRACKET index_mode_list RBRACKET element_mode
    (45) discrete_mode_name -> . identifier

    REF             shift and go to state 38
    ID              shift and go to state 15
    INT             shift and go to state 39
    BOOL            shift and go to state 53
    CHAR            shift and go to state 51
    CHARS           shift and go to state 43
    ARRAY           shift and go to state 52

    discrete_range_mode            shift and go to state 45
    identifier                     shift and go to state 36
    composite_mode                 shift and go to state 46
    discrete_mode                  shift and go to state 37
    discrete_mode_name             shift and go to state 48
    mode                           shift and go to state 65
    boolean_mode                   shift and go to state 50
    mode_name                      shift and go to state 41
    reference_mode                 shift and go to state 35
    array_mode                     shift and go to state 42
    integer_mode                   shift and go to state 40
    string_mode                    shift and go to state 44
    character_mode                 shift and go to state 47

state 39

    (46) integer_mode -> INT .

    LPAREN          reduce using rule 46 (integer_mode -> INT .)
    COMMA           reduce using rule 46 (integer_mode -> INT .)
    SEMI            reduce using rule 46 (integer_mode -> INT .)
    LOC             reduce using rule 46 (integer_mode -> INT .)
    RPAREN          reduce using rule 46 (integer_mode -> INT .)
    RBRACKET        reduce using rule 46 (integer_mode -> INT .)
    ASSIGN          reduce using rule 46 (integer_mode -> INT .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 40

<<<<<<< HEAD
    (126) integer_literal -> ICONST .

    LBRACKET        reduce using rule 126 (integer_literal -> ICONST .)
    TIMES           reduce using rule 126 (integer_literal -> ICONST .)
    DIVIDE          reduce using rule 126 (integer_literal -> ICONST .)
    MODULO          reduce using rule 126 (integer_literal -> ICONST .)
    PLUS            reduce using rule 126 (integer_literal -> ICONST .)
    MINUS           reduce using rule 126 (integer_literal -> ICONST .)
    CONCAT          reduce using rule 126 (integer_literal -> ICONST .)
    AND             reduce using rule 126 (integer_literal -> ICONST .)
    OR              reduce using rule 126 (integer_literal -> ICONST .)
    EQUAL           reduce using rule 126 (integer_literal -> ICONST .)
    NOTEQ           reduce using rule 126 (integer_literal -> ICONST .)
    GREATER         reduce using rule 126 (integer_literal -> ICONST .)
    GTEQUAL         reduce using rule 126 (integer_literal -> ICONST .)
    LESS            reduce using rule 126 (integer_literal -> ICONST .)
    LTEQUAL         reduce using rule 126 (integer_literal -> ICONST .)
    IN              reduce using rule 126 (integer_literal -> ICONST .)
    RPAREN          reduce using rule 126 (integer_literal -> ICONST .)
    COMMA           reduce using rule 126 (integer_literal -> ICONST .)
    RBRACKET        reduce using rule 126 (integer_literal -> ICONST .)
    COLON           reduce using rule 126 (integer_literal -> ICONST .)
    THEN            reduce using rule 126 (integer_literal -> ICONST .)
    DCL             reduce using rule 126 (integer_literal -> ICONST .)
    SYN             reduce using rule 126 (integer_literal -> ICONST .)
    TYPE            reduce using rule 126 (integer_literal -> ICONST .)
    ID              reduce using rule 126 (integer_literal -> ICONST .)
    IF              reduce using rule 126 (integer_literal -> ICONST .)
    $end            reduce using rule 126 (integer_literal -> ICONST .)
    ELSE            reduce using rule 126 (integer_literal -> ICONST .)
    ELSIF           reduce using rule 126 (integer_literal -> ICONST .)
    FI              reduce using rule 126 (integer_literal -> ICONST .)
    SEMI            reduce using rule 126 (integer_literal -> ICONST .)
=======
    (41) discrete_mode -> integer_mode .

    LPAREN          reduce using rule 41 (discrete_mode -> integer_mode .)
    ASSIGN          reduce using rule 41 (discrete_mode -> integer_mode .)
    COMMA           reduce using rule 41 (discrete_mode -> integer_mode .)
    SEMI            reduce using rule 41 (discrete_mode -> integer_mode .)
    RBRACKET        reduce using rule 41 (discrete_mode -> integer_mode .)
    LOC             reduce using rule 41 (discrete_mode -> integer_mode .)
    RPAREN          reduce using rule 41 (discrete_mode -> integer_mode .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 41

<<<<<<< HEAD
    (121) literal -> character_literal .

    LBRACKET        reduce using rule 121 (literal -> character_literal .)
    TIMES           reduce using rule 121 (literal -> character_literal .)
    DIVIDE          reduce using rule 121 (literal -> character_literal .)
    MODULO          reduce using rule 121 (literal -> character_literal .)
    PLUS            reduce using rule 121 (literal -> character_literal .)
    MINUS           reduce using rule 121 (literal -> character_literal .)
    CONCAT          reduce using rule 121 (literal -> character_literal .)
    AND             reduce using rule 121 (literal -> character_literal .)
    OR              reduce using rule 121 (literal -> character_literal .)
    EQUAL           reduce using rule 121 (literal -> character_literal .)
    NOTEQ           reduce using rule 121 (literal -> character_literal .)
    GREATER         reduce using rule 121 (literal -> character_literal .)
    GTEQUAL         reduce using rule 121 (literal -> character_literal .)
    LESS            reduce using rule 121 (literal -> character_literal .)
    LTEQUAL         reduce using rule 121 (literal -> character_literal .)
    IN              reduce using rule 121 (literal -> character_literal .)
    FI              reduce using rule 121 (literal -> character_literal .)
    THEN            reduce using rule 121 (literal -> character_literal .)
    RPAREN          reduce using rule 121 (literal -> character_literal .)
    DCL             reduce using rule 121 (literal -> character_literal .)
    SYN             reduce using rule 121 (literal -> character_literal .)
    TYPE            reduce using rule 121 (literal -> character_literal .)
    ID              reduce using rule 121 (literal -> character_literal .)
    IF              reduce using rule 121 (literal -> character_literal .)
    $end            reduce using rule 121 (literal -> character_literal .)
    ELSE            reduce using rule 121 (literal -> character_literal .)
    ELSIF           reduce using rule 121 (literal -> character_literal .)
    COMMA           reduce using rule 121 (literal -> character_literal .)
    RBRACKET        reduce using rule 121 (literal -> character_literal .)
    COLON           reduce using rule 121 (literal -> character_literal .)
    SEMI            reduce using rule 121 (literal -> character_literal .)
=======
    (36) mode -> mode_name .

    LOC             reduce using rule 36 (mode -> mode_name .)
    RPAREN          reduce using rule 36 (mode -> mode_name .)
    ASSIGN          reduce using rule 36 (mode -> mode_name .)
    COMMA           reduce using rule 36 (mode -> mode_name .)
    SEMI            reduce using rule 36 (mode -> mode_name .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 42

<<<<<<< HEAD
    (117) primitive_value -> value_array_slice .

    LBRACKET        reduce using rule 117 (primitive_value -> value_array_slice .)
    TIMES           reduce using rule 117 (primitive_value -> value_array_slice .)
    DIVIDE          reduce using rule 117 (primitive_value -> value_array_slice .)
    MODULO          reduce using rule 117 (primitive_value -> value_array_slice .)
    PLUS            reduce using rule 117 (primitive_value -> value_array_slice .)
    MINUS           reduce using rule 117 (primitive_value -> value_array_slice .)
    CONCAT          reduce using rule 117 (primitive_value -> value_array_slice .)
    AND             reduce using rule 117 (primitive_value -> value_array_slice .)
    OR              reduce using rule 117 (primitive_value -> value_array_slice .)
    EQUAL           reduce using rule 117 (primitive_value -> value_array_slice .)
    NOTEQ           reduce using rule 117 (primitive_value -> value_array_slice .)
    GREATER         reduce using rule 117 (primitive_value -> value_array_slice .)
    GTEQUAL         reduce using rule 117 (primitive_value -> value_array_slice .)
    LESS            reduce using rule 117 (primitive_value -> value_array_slice .)
    LTEQUAL         reduce using rule 117 (primitive_value -> value_array_slice .)
    IN              reduce using rule 117 (primitive_value -> value_array_slice .)
    COMMA           reduce using rule 117 (primitive_value -> value_array_slice .)
    SEMI            reduce using rule 117 (primitive_value -> value_array_slice .)
    THEN            reduce using rule 117 (primitive_value -> value_array_slice .)
    COLON           reduce using rule 117 (primitive_value -> value_array_slice .)
    RBRACKET        reduce using rule 117 (primitive_value -> value_array_slice .)
    RPAREN          reduce using rule 117 (primitive_value -> value_array_slice .)
    DCL             reduce using rule 117 (primitive_value -> value_array_slice .)
    SYN             reduce using rule 117 (primitive_value -> value_array_slice .)
    TYPE            reduce using rule 117 (primitive_value -> value_array_slice .)
    ID              reduce using rule 117 (primitive_value -> value_array_slice .)
    IF              reduce using rule 117 (primitive_value -> value_array_slice .)
    $end            reduce using rule 117 (primitive_value -> value_array_slice .)
    ELSE            reduce using rule 117 (primitive_value -> value_array_slice .)
    ELSIF           reduce using rule 117 (primitive_value -> value_array_slice .)
    FI              reduce using rule 117 (primitive_value -> value_array_slice .)
=======
    (56) composite_mode -> array_mode .

    ASSIGN          reduce using rule 56 (composite_mode -> array_mode .)
    COMMA           reduce using rule 56 (composite_mode -> array_mode .)
    SEMI            reduce using rule 56 (composite_mode -> array_mode .)
    LOC             reduce using rule 56 (composite_mode -> array_mode .)
    RPAREN          reduce using rule 56 (composite_mode -> array_mode .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 43

<<<<<<< HEAD
    (123) literal -> character_string_literal .

    LBRACKET        reduce using rule 123 (literal -> character_string_literal .)
    TIMES           reduce using rule 123 (literal -> character_string_literal .)
    DIVIDE          reduce using rule 123 (literal -> character_string_literal .)
    MODULO          reduce using rule 123 (literal -> character_string_literal .)
    PLUS            reduce using rule 123 (literal -> character_string_literal .)
    MINUS           reduce using rule 123 (literal -> character_string_literal .)
    CONCAT          reduce using rule 123 (literal -> character_string_literal .)
    AND             reduce using rule 123 (literal -> character_string_literal .)
    OR              reduce using rule 123 (literal -> character_string_literal .)
    EQUAL           reduce using rule 123 (literal -> character_string_literal .)
    NOTEQ           reduce using rule 123 (literal -> character_string_literal .)
    GREATER         reduce using rule 123 (literal -> character_string_literal .)
    GTEQUAL         reduce using rule 123 (literal -> character_string_literal .)
    LESS            reduce using rule 123 (literal -> character_string_literal .)
    LTEQUAL         reduce using rule 123 (literal -> character_string_literal .)
    IN              reduce using rule 123 (literal -> character_string_literal .)
    FI              reduce using rule 123 (literal -> character_string_literal .)
    THEN            reduce using rule 123 (literal -> character_string_literal .)
    RPAREN          reduce using rule 123 (literal -> character_string_literal .)
    DCL             reduce using rule 123 (literal -> character_string_literal .)
    SYN             reduce using rule 123 (literal -> character_string_literal .)
    TYPE            reduce using rule 123 (literal -> character_string_literal .)
    ID              reduce using rule 123 (literal -> character_string_literal .)
    IF              reduce using rule 123 (literal -> character_string_literal .)
    $end            reduce using rule 123 (literal -> character_string_literal .)
    ELSE            reduce using rule 123 (literal -> character_string_literal .)
    ELSIF           reduce using rule 123 (literal -> character_string_literal .)
    COMMA           reduce using rule 123 (literal -> character_string_literal .)
    RBRACKET        reduce using rule 123 (literal -> character_string_literal .)
    COLON           reduce using rule 123 (literal -> character_string_literal .)
    SEMI            reduce using rule 123 (literal -> character_string_literal .)
=======
    (57) string_mode -> CHARS . LBRACKET string_length RBRACKET

    LBRACKET        shift and go to state 66
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 44

<<<<<<< HEAD
    (75) parenthesized_expression -> LPAREN . expression RPAREN
    (73) expression -> . operand0
    (74) expression -> . conditional_expression
    (82) operand0 -> . operand1
    (83) operand0 -> . operand0 operator1 operand1
    (76) conditional_expression -> . IF expression then_expression else_expression FI
    (77) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (84) operand1 -> . operand2
    (85) operand1 -> . operand1 operator2 operand2
    (86) operand2 -> . operand3
    (87) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (88) operand3 -> . monadic_operator operand4
    (89) operand3 -> . operand4
    (96) monadic_operator -> . MINUS
    (97) monadic_operator -> . NOT
    (90) operand4 -> . array_location
    (91) operand4 -> . referenced_location
    (92) operand4 -> . primitive_value
    (72) array_location -> . location
    (98) referenced_location -> . ARROW array_location
    (115) primitive_value -> . literal
    (116) primitive_value -> . value_array_element
    (117) primitive_value -> . value_array_slice
    (118) primitive_value -> . parenthesized_expression
    (56) location -> . identifier
    (57) location -> . dereferenced_reference
    (58) location -> . string_element
    (59) location -> . string_slice
    (60) location -> . array_element
    (61) location -> . array_slice
    (119) literal -> . integer_literal
    (120) literal -> . boolean_literal
    (121) literal -> . character_literal
    (122) literal -> . empty_literal
    (123) literal -> . character_string_literal
    (124) value_array_element -> . primitive_value LBRACKET expression_list RBRACKET
    (125) value_array_slice -> . primitive_value LBRACKET expression COLON expression RBRACKET
    (75) parenthesized_expression -> . LPAREN expression RPAREN
    (22) identifier -> . ID
    (62) dereferenced_reference -> . array_location ARROW
    (63) string_element -> . identifier LBRACKET start_element LBRACKET
    (65) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (68) array_element -> . array_location LBRACKET expression_list RBRACKET
    (71) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (126) integer_literal -> . ICONST
    (127) boolean_literal -> . TRUE
    (128) boolean_literal -> . FALSE
    (129) character_literal -> . CCONST
    (130) empty_literal -> . NULL
    (131) character_string_literal -> . SCONST

    IF              shift and go to state 31
    MINUS           shift and go to state 36
    NOT             shift and go to state 35
    ARROW           shift and go to state 45
    LPAREN          shift and go to state 44
    ID              shift and go to state 21
    ICONST          shift and go to state 40
    TRUE            shift and go to state 55
    FALSE           shift and go to state 53
    CCONST          shift and go to state 34
    NULL            shift and go to state 27
    SCONST          shift and go to state 52

    location                       shift and go to state 6
    monadic_operator               shift and go to state 47
    operand2                       shift and go to state 49
    value_array_element            shift and go to state 48
    operand1                       shift and go to state 25
    expression                     shift and go to state 105
    conditional_expression         shift and go to state 28
    referenced_location            shift and go to state 29
    parenthesized_expression       shift and go to state 30
    array_slice                    shift and go to state 15
    integer_literal                shift and go to state 32
    empty_literal                  shift and go to state 50
    array_element                  shift and go to state 7
    operand3                       shift and go to state 33
    string_slice                   shift and go to state 3
    string_element                 shift and go to state 1
    boolean_literal                shift and go to state 51
    array_location                 shift and go to state 46
    literal                        shift and go to state 37
    operand0                       shift and go to state 38
    primitive_value                shift and go to state 39
    character_literal              shift and go to state 41
    value_array_slice              shift and go to state 42
    operand4                       shift and go to state 54
    character_string_literal       shift and go to state 43
    dereferenced_reference         shift and go to state 20
    identifier                     shift and go to state 56

state 45

    (98) referenced_location -> ARROW . array_location
    (72) array_location -> . location
    (56) location -> . identifier
    (57) location -> . dereferenced_reference
    (58) location -> . string_element
    (59) location -> . string_slice
    (60) location -> . array_element
    (61) location -> . array_slice
    (22) identifier -> . ID
    (62) dereferenced_reference -> . array_location ARROW
    (63) string_element -> . identifier LBRACKET start_element LBRACKET
    (65) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (68) array_element -> . array_location LBRACKET expression_list RBRACKET
    (71) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET

    ID              shift and go to state 21

    array_location                 shift and go to state 106
    location                       shift and go to state 6
    array_element                  shift and go to state 7
    string_element                 shift and go to state 1
    string_slice                   shift and go to state 3
    array_slice                    shift and go to state 15
    dereferenced_reference         shift and go to state 20
    identifier                     shift and go to state 56

state 46

    (90) operand4 -> array_location .
    (62) dereferenced_reference -> array_location . ARROW
    (68) array_element -> array_location . LBRACKET expression_list RBRACKET
    (71) array_slice -> array_location . LBRACKET lower_bound COLON upper_bound RBRACKET

  ! shift/reduce conflict for LBRACKET resolved as shift
    TIMES           reduce using rule 90 (operand4 -> array_location .)
    DIVIDE          reduce using rule 90 (operand4 -> array_location .)
    MODULO          reduce using rule 90 (operand4 -> array_location .)
    PLUS            reduce using rule 90 (operand4 -> array_location .)
    MINUS           reduce using rule 90 (operand4 -> array_location .)
    CONCAT          reduce using rule 90 (operand4 -> array_location .)
    AND             reduce using rule 90 (operand4 -> array_location .)
    OR              reduce using rule 90 (operand4 -> array_location .)
    EQUAL           reduce using rule 90 (operand4 -> array_location .)
    NOTEQ           reduce using rule 90 (operand4 -> array_location .)
    GREATER         reduce using rule 90 (operand4 -> array_location .)
    GTEQUAL         reduce using rule 90 (operand4 -> array_location .)
    LESS            reduce using rule 90 (operand4 -> array_location .)
    LTEQUAL         reduce using rule 90 (operand4 -> array_location .)
    IN              reduce using rule 90 (operand4 -> array_location .)
    RBRACKET        reduce using rule 90 (operand4 -> array_location .)
    RPAREN          reduce using rule 90 (operand4 -> array_location .)
    THEN            reduce using rule 90 (operand4 -> array_location .)
    DCL             reduce using rule 90 (operand4 -> array_location .)
    SYN             reduce using rule 90 (operand4 -> array_location .)
    TYPE            reduce using rule 90 (operand4 -> array_location .)
    ID              reduce using rule 90 (operand4 -> array_location .)
    IF              reduce using rule 90 (operand4 -> array_location .)
    $end            reduce using rule 90 (operand4 -> array_location .)
    ELSE            reduce using rule 90 (operand4 -> array_location .)
    ELSIF           reduce using rule 90 (operand4 -> array_location .)
    FI              reduce using rule 90 (operand4 -> array_location .)
    COMMA           reduce using rule 90 (operand4 -> array_location .)
    COLON           reduce using rule 90 (operand4 -> array_location .)
    SEMI            reduce using rule 90 (operand4 -> array_location .)
    ARROW           shift and go to state 61
    LBRACKET        shift and go to state 71

  ! LBRACKET        [ reduce using rule 90 (operand4 -> array_location .) ]
=======
    (55) composite_mode -> string_mode .

    ASSIGN          reduce using rule 55 (composite_mode -> string_mode .)
    COMMA           reduce using rule 55 (composite_mode -> string_mode .)
    SEMI            reduce using rule 55 (composite_mode -> string_mode .)
    LOC             reduce using rule 55 (composite_mode -> string_mode .)
    RPAREN          reduce using rule 55 (composite_mode -> string_mode .)


state 45

    (44) discrete_mode -> discrete_range_mode .

    LPAREN          reduce using rule 44 (discrete_mode -> discrete_range_mode .)
    ASSIGN          reduce using rule 44 (discrete_mode -> discrete_range_mode .)
    COMMA           reduce using rule 44 (discrete_mode -> discrete_range_mode .)
    SEMI            reduce using rule 44 (discrete_mode -> discrete_range_mode .)
    RBRACKET        reduce using rule 44 (discrete_mode -> discrete_range_mode .)
    LOC             reduce using rule 44 (discrete_mode -> discrete_range_mode .)
    RPAREN          reduce using rule 44 (discrete_mode -> discrete_range_mode .)


state 46

    (39) mode -> composite_mode .

    LOC             reduce using rule 39 (mode -> composite_mode .)
    RPAREN          reduce using rule 39 (mode -> composite_mode .)
    ASSIGN          reduce using rule 39 (mode -> composite_mode .)
    COMMA           reduce using rule 39 (mode -> composite_mode .)
    SEMI            reduce using rule 39 (mode -> composite_mode .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 47

<<<<<<< HEAD
    (88) operand3 -> monadic_operator . operand4
    (90) operand4 -> . array_location
    (91) operand4 -> . referenced_location
    (92) operand4 -> . primitive_value
    (72) array_location -> . location
    (98) referenced_location -> . ARROW array_location
    (115) primitive_value -> . literal
    (116) primitive_value -> . value_array_element
    (117) primitive_value -> . value_array_slice
    (118) primitive_value -> . parenthesized_expression
    (56) location -> . identifier
    (57) location -> . dereferenced_reference
    (58) location -> . string_element
    (59) location -> . string_slice
    (60) location -> . array_element
    (61) location -> . array_slice
    (119) literal -> . integer_literal
    (120) literal -> . boolean_literal
    (121) literal -> . character_literal
    (122) literal -> . empty_literal
    (123) literal -> . character_string_literal
    (124) value_array_element -> . primitive_value LBRACKET expression_list RBRACKET
    (125) value_array_slice -> . primitive_value LBRACKET expression COLON expression RBRACKET
    (75) parenthesized_expression -> . LPAREN expression RPAREN
    (22) identifier -> . ID
    (62) dereferenced_reference -> . array_location ARROW
    (63) string_element -> . identifier LBRACKET start_element LBRACKET
    (65) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (68) array_element -> . array_location LBRACKET expression_list RBRACKET
    (71) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (126) integer_literal -> . ICONST
    (127) boolean_literal -> . TRUE
    (128) boolean_literal -> . FALSE
    (129) character_literal -> . CCONST
    (130) empty_literal -> . NULL
    (131) character_string_literal -> . SCONST

    ARROW           shift and go to state 45
    LPAREN          shift and go to state 44
    ID              shift and go to state 21
    ICONST          shift and go to state 40
    TRUE            shift and go to state 55
    FALSE           shift and go to state 53
    CCONST          shift and go to state 34
    NULL            shift and go to state 27
    SCONST          shift and go to state 52

    location                       shift and go to state 6
    value_array_element            shift and go to state 48
    string_slice                   shift and go to state 3
    referenced_location            shift and go to state 29
    array_slice                    shift and go to state 15
    parenthesized_expression       shift and go to state 30
    integer_literal                shift and go to state 32
    empty_literal                  shift and go to state 50
    string_element                 shift and go to state 1
    boolean_literal                shift and go to state 51
    array_location                 shift and go to state 46
    literal                        shift and go to state 37
    array_element                  shift and go to state 7
    primitive_value                shift and go to state 39
    character_literal              shift and go to state 41
    value_array_slice              shift and go to state 42
    operand4                       shift and go to state 107
    character_string_literal       shift and go to state 43
    dereferenced_reference         shift and go to state 20
    identifier                     shift and go to state 56

state 48

    (116) primitive_value -> value_array_element .

    LBRACKET        reduce using rule 116 (primitive_value -> value_array_element .)
    TIMES           reduce using rule 116 (primitive_value -> value_array_element .)
    DIVIDE          reduce using rule 116 (primitive_value -> value_array_element .)
    MODULO          reduce using rule 116 (primitive_value -> value_array_element .)
    PLUS            reduce using rule 116 (primitive_value -> value_array_element .)
    MINUS           reduce using rule 116 (primitive_value -> value_array_element .)
    CONCAT          reduce using rule 116 (primitive_value -> value_array_element .)
    AND             reduce using rule 116 (primitive_value -> value_array_element .)
    OR              reduce using rule 116 (primitive_value -> value_array_element .)
    EQUAL           reduce using rule 116 (primitive_value -> value_array_element .)
    NOTEQ           reduce using rule 116 (primitive_value -> value_array_element .)
    GREATER         reduce using rule 116 (primitive_value -> value_array_element .)
    GTEQUAL         reduce using rule 116 (primitive_value -> value_array_element .)
    LESS            reduce using rule 116 (primitive_value -> value_array_element .)
    LTEQUAL         reduce using rule 116 (primitive_value -> value_array_element .)
    IN              reduce using rule 116 (primitive_value -> value_array_element .)
    COMMA           reduce using rule 116 (primitive_value -> value_array_element .)
    SEMI            reduce using rule 116 (primitive_value -> value_array_element .)
    THEN            reduce using rule 116 (primitive_value -> value_array_element .)
    COLON           reduce using rule 116 (primitive_value -> value_array_element .)
    RBRACKET        reduce using rule 116 (primitive_value -> value_array_element .)
    RPAREN          reduce using rule 116 (primitive_value -> value_array_element .)
    DCL             reduce using rule 116 (primitive_value -> value_array_element .)
    SYN             reduce using rule 116 (primitive_value -> value_array_element .)
    TYPE            reduce using rule 116 (primitive_value -> value_array_element .)
    ID              reduce using rule 116 (primitive_value -> value_array_element .)
    IF              reduce using rule 116 (primitive_value -> value_array_element .)
    $end            reduce using rule 116 (primitive_value -> value_array_element .)
    ELSE            reduce using rule 116 (primitive_value -> value_array_element .)
    ELSIF           reduce using rule 116 (primitive_value -> value_array_element .)
    FI              reduce using rule 116 (primitive_value -> value_array_element .)
=======
    (43) discrete_mode -> character_mode .

    LPAREN          reduce using rule 43 (discrete_mode -> character_mode .)
    ASSIGN          reduce using rule 43 (discrete_mode -> character_mode .)
    COMMA           reduce using rule 43 (discrete_mode -> character_mode .)
    SEMI            reduce using rule 43 (discrete_mode -> character_mode .)
    RBRACKET        reduce using rule 43 (discrete_mode -> character_mode .)
    LOC             reduce using rule 43 (discrete_mode -> character_mode .)
    RPAREN          reduce using rule 43 (discrete_mode -> character_mode .)


state 48

    (49) discrete_range_mode -> discrete_mode_name . LPAREN literal_range RPAREN

    LPAREN          shift and go to state 67
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 49

<<<<<<< HEAD
    (84) operand1 -> operand2 .
    (87) operand2 -> operand2 . arithmetic_multiplicative_operator operand3
    (93) arithmetic_multiplicative_operator -> . TIMES
    (94) arithmetic_multiplicative_operator -> . DIVIDE
    (95) arithmetic_multiplicative_operator -> . MODULO

    PLUS            reduce using rule 84 (operand1 -> operand2 .)
    MINUS           reduce using rule 84 (operand1 -> operand2 .)
    CONCAT          reduce using rule 84 (operand1 -> operand2 .)
    AND             reduce using rule 84 (operand1 -> operand2 .)
    OR              reduce using rule 84 (operand1 -> operand2 .)
    EQUAL           reduce using rule 84 (operand1 -> operand2 .)
    NOTEQ           reduce using rule 84 (operand1 -> operand2 .)
    GREATER         reduce using rule 84 (operand1 -> operand2 .)
    GTEQUAL         reduce using rule 84 (operand1 -> operand2 .)
    LESS            reduce using rule 84 (operand1 -> operand2 .)
    LTEQUAL         reduce using rule 84 (operand1 -> operand2 .)
    IN              reduce using rule 84 (operand1 -> operand2 .)
    COLON           reduce using rule 84 (operand1 -> operand2 .)
    COMMA           reduce using rule 84 (operand1 -> operand2 .)
    SEMI            reduce using rule 84 (operand1 -> operand2 .)
    THEN            reduce using rule 84 (operand1 -> operand2 .)
    RBRACKET        reduce using rule 84 (operand1 -> operand2 .)
    FI              reduce using rule 84 (operand1 -> operand2 .)
    LBRACKET        reduce using rule 84 (operand1 -> operand2 .)
    ELSE            reduce using rule 84 (operand1 -> operand2 .)
    ELSIF           reduce using rule 84 (operand1 -> operand2 .)
    DCL             reduce using rule 84 (operand1 -> operand2 .)
    SYN             reduce using rule 84 (operand1 -> operand2 .)
    TYPE            reduce using rule 84 (operand1 -> operand2 .)
    ID              reduce using rule 84 (operand1 -> operand2 .)
    IF              reduce using rule 84 (operand1 -> operand2 .)
    $end            reduce using rule 84 (operand1 -> operand2 .)
    RPAREN          reduce using rule 84 (operand1 -> operand2 .)
    TIMES           shift and go to state 73
    DIVIDE          shift and go to state 70
    MODULO          shift and go to state 72

    arithmetic_multiplicative_operator shift and go to state 108

state 50

    (122) literal -> empty_literal .

    LBRACKET        reduce using rule 122 (literal -> empty_literal .)
    TIMES           reduce using rule 122 (literal -> empty_literal .)
    DIVIDE          reduce using rule 122 (literal -> empty_literal .)
    MODULO          reduce using rule 122 (literal -> empty_literal .)
    PLUS            reduce using rule 122 (literal -> empty_literal .)
    MINUS           reduce using rule 122 (literal -> empty_literal .)
    CONCAT          reduce using rule 122 (literal -> empty_literal .)
    AND             reduce using rule 122 (literal -> empty_literal .)
    OR              reduce using rule 122 (literal -> empty_literal .)
    EQUAL           reduce using rule 122 (literal -> empty_literal .)
    NOTEQ           reduce using rule 122 (literal -> empty_literal .)
    GREATER         reduce using rule 122 (literal -> empty_literal .)
    GTEQUAL         reduce using rule 122 (literal -> empty_literal .)
    LESS            reduce using rule 122 (literal -> empty_literal .)
    LTEQUAL         reduce using rule 122 (literal -> empty_literal .)
    IN              reduce using rule 122 (literal -> empty_literal .)
    FI              reduce using rule 122 (literal -> empty_literal .)
    THEN            reduce using rule 122 (literal -> empty_literal .)
    RPAREN          reduce using rule 122 (literal -> empty_literal .)
    DCL             reduce using rule 122 (literal -> empty_literal .)
    SYN             reduce using rule 122 (literal -> empty_literal .)
    TYPE            reduce using rule 122 (literal -> empty_literal .)
    ID              reduce using rule 122 (literal -> empty_literal .)
    IF              reduce using rule 122 (literal -> empty_literal .)
    $end            reduce using rule 122 (literal -> empty_literal .)
    ELSE            reduce using rule 122 (literal -> empty_literal .)
    ELSIF           reduce using rule 122 (literal -> empty_literal .)
    COMMA           reduce using rule 122 (literal -> empty_literal .)
    RBRACKET        reduce using rule 122 (literal -> empty_literal .)
    COLON           reduce using rule 122 (literal -> empty_literal .)
    SEMI            reduce using rule 122 (literal -> empty_literal .)
=======
    (17) declaration -> identifier_list mode . initialization
    (18) declaration -> identifier_list mode .
    (19) initialization -> . ASSIGN expression

    COMMA           reduce using rule 18 (declaration -> identifier_list mode .)
    SEMI            reduce using rule 18 (declaration -> identifier_list mode .)
    ASSIGN          shift and go to state 68

    initialization                 shift and go to state 69

state 50

    (42) discrete_mode -> boolean_mode .

    LPAREN          reduce using rule 42 (discrete_mode -> boolean_mode .)
    ASSIGN          reduce using rule 42 (discrete_mode -> boolean_mode .)
    COMMA           reduce using rule 42 (discrete_mode -> boolean_mode .)
    SEMI            reduce using rule 42 (discrete_mode -> boolean_mode .)
    RBRACKET        reduce using rule 42 (discrete_mode -> boolean_mode .)
    LOC             reduce using rule 42 (discrete_mode -> boolean_mode .)
    RPAREN          reduce using rule 42 (discrete_mode -> boolean_mode .)

>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


<<<<<<< HEAD
state 51

    (120) literal -> boolean_literal .

    LBRACKET        reduce using rule 120 (literal -> boolean_literal .)
    TIMES           reduce using rule 120 (literal -> boolean_literal .)
    DIVIDE          reduce using rule 120 (literal -> boolean_literal .)
    MODULO          reduce using rule 120 (literal -> boolean_literal .)
    PLUS            reduce using rule 120 (literal -> boolean_literal .)
    MINUS           reduce using rule 120 (literal -> boolean_literal .)
    CONCAT          reduce using rule 120 (literal -> boolean_literal .)
    AND             reduce using rule 120 (literal -> boolean_literal .)
    OR              reduce using rule 120 (literal -> boolean_literal .)
    EQUAL           reduce using rule 120 (literal -> boolean_literal .)
    NOTEQ           reduce using rule 120 (literal -> boolean_literal .)
    GREATER         reduce using rule 120 (literal -> boolean_literal .)
    GTEQUAL         reduce using rule 120 (literal -> boolean_literal .)
    LESS            reduce using rule 120 (literal -> boolean_literal .)
    LTEQUAL         reduce using rule 120 (literal -> boolean_literal .)
    IN              reduce using rule 120 (literal -> boolean_literal .)
    FI              reduce using rule 120 (literal -> boolean_literal .)
    THEN            reduce using rule 120 (literal -> boolean_literal .)
    RPAREN          reduce using rule 120 (literal -> boolean_literal .)
    DCL             reduce using rule 120 (literal -> boolean_literal .)
    SYN             reduce using rule 120 (literal -> boolean_literal .)
    TYPE            reduce using rule 120 (literal -> boolean_literal .)
    ID              reduce using rule 120 (literal -> boolean_literal .)
    IF              reduce using rule 120 (literal -> boolean_literal .)
    $end            reduce using rule 120 (literal -> boolean_literal .)
    ELSE            reduce using rule 120 (literal -> boolean_literal .)
    ELSIF           reduce using rule 120 (literal -> boolean_literal .)
    COMMA           reduce using rule 120 (literal -> boolean_literal .)
    RBRACKET        reduce using rule 120 (literal -> boolean_literal .)
    COLON           reduce using rule 120 (literal -> boolean_literal .)
    SEMI            reduce using rule 120 (literal -> boolean_literal .)
=======
    (48) character_mode -> CHAR .

    LPAREN          reduce using rule 48 (character_mode -> CHAR .)
    LOC             reduce using rule 48 (character_mode -> CHAR .)
    COMMA           reduce using rule 48 (character_mode -> CHAR .)
    RPAREN          reduce using rule 48 (character_mode -> CHAR .)
    RBRACKET        reduce using rule 48 (character_mode -> CHAR .)
    ASSIGN          reduce using rule 48 (character_mode -> CHAR .)
    SEMI            reduce using rule 48 (character_mode -> CHAR .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 52

<<<<<<< HEAD
    (131) character_string_literal -> SCONST .

    LBRACKET        reduce using rule 131 (character_string_literal -> SCONST .)
    TIMES           reduce using rule 131 (character_string_literal -> SCONST .)
    DIVIDE          reduce using rule 131 (character_string_literal -> SCONST .)
    MODULO          reduce using rule 131 (character_string_literal -> SCONST .)
    PLUS            reduce using rule 131 (character_string_literal -> SCONST .)
    MINUS           reduce using rule 131 (character_string_literal -> SCONST .)
    CONCAT          reduce using rule 131 (character_string_literal -> SCONST .)
    AND             reduce using rule 131 (character_string_literal -> SCONST .)
    OR              reduce using rule 131 (character_string_literal -> SCONST .)
    EQUAL           reduce using rule 131 (character_string_literal -> SCONST .)
    NOTEQ           reduce using rule 131 (character_string_literal -> SCONST .)
    GREATER         reduce using rule 131 (character_string_literal -> SCONST .)
    GTEQUAL         reduce using rule 131 (character_string_literal -> SCONST .)
    LESS            reduce using rule 131 (character_string_literal -> SCONST .)
    LTEQUAL         reduce using rule 131 (character_string_literal -> SCONST .)
    IN              reduce using rule 131 (character_string_literal -> SCONST .)
    THEN            reduce using rule 131 (character_string_literal -> SCONST .)
    RPAREN          reduce using rule 131 (character_string_literal -> SCONST .)
    DCL             reduce using rule 131 (character_string_literal -> SCONST .)
    SYN             reduce using rule 131 (character_string_literal -> SCONST .)
    TYPE            reduce using rule 131 (character_string_literal -> SCONST .)
    ID              reduce using rule 131 (character_string_literal -> SCONST .)
    IF              reduce using rule 131 (character_string_literal -> SCONST .)
    $end            reduce using rule 131 (character_string_literal -> SCONST .)
    ELSE            reduce using rule 131 (character_string_literal -> SCONST .)
    ELSIF           reduce using rule 131 (character_string_literal -> SCONST .)
    FI              reduce using rule 131 (character_string_literal -> SCONST .)
    COMMA           reduce using rule 131 (character_string_literal -> SCONST .)
    RBRACKET        reduce using rule 131 (character_string_literal -> SCONST .)
    COLON           reduce using rule 131 (character_string_literal -> SCONST .)
    SEMI            reduce using rule 131 (character_string_literal -> SCONST .)
=======
    (59) array_mode -> ARRAY . LBRACKET index_mode_list RBRACKET element_mode

    LBRACKET        shift and go to state 70
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 53

<<<<<<< HEAD
    (128) boolean_literal -> FALSE .

    LBRACKET        reduce using rule 128 (boolean_literal -> FALSE .)
    TIMES           reduce using rule 128 (boolean_literal -> FALSE .)
    DIVIDE          reduce using rule 128 (boolean_literal -> FALSE .)
    MODULO          reduce using rule 128 (boolean_literal -> FALSE .)
    PLUS            reduce using rule 128 (boolean_literal -> FALSE .)
    MINUS           reduce using rule 128 (boolean_literal -> FALSE .)
    CONCAT          reduce using rule 128 (boolean_literal -> FALSE .)
    AND             reduce using rule 128 (boolean_literal -> FALSE .)
    OR              reduce using rule 128 (boolean_literal -> FALSE .)
    EQUAL           reduce using rule 128 (boolean_literal -> FALSE .)
    NOTEQ           reduce using rule 128 (boolean_literal -> FALSE .)
    GREATER         reduce using rule 128 (boolean_literal -> FALSE .)
    GTEQUAL         reduce using rule 128 (boolean_literal -> FALSE .)
    LESS            reduce using rule 128 (boolean_literal -> FALSE .)
    LTEQUAL         reduce using rule 128 (boolean_literal -> FALSE .)
    IN              reduce using rule 128 (boolean_literal -> FALSE .)
    COLON           reduce using rule 128 (boolean_literal -> FALSE .)
    THEN            reduce using rule 128 (boolean_literal -> FALSE .)
    FI              reduce using rule 128 (boolean_literal -> FALSE .)
    RPAREN          reduce using rule 128 (boolean_literal -> FALSE .)
    DCL             reduce using rule 128 (boolean_literal -> FALSE .)
    SYN             reduce using rule 128 (boolean_literal -> FALSE .)
    TYPE            reduce using rule 128 (boolean_literal -> FALSE .)
    ID              reduce using rule 128 (boolean_literal -> FALSE .)
    IF              reduce using rule 128 (boolean_literal -> FALSE .)
    $end            reduce using rule 128 (boolean_literal -> FALSE .)
    ELSE            reduce using rule 128 (boolean_literal -> FALSE .)
    ELSIF           reduce using rule 128 (boolean_literal -> FALSE .)
    COMMA           reduce using rule 128 (boolean_literal -> FALSE .)
    RBRACKET        reduce using rule 128 (boolean_literal -> FALSE .)
    SEMI            reduce using rule 128 (boolean_literal -> FALSE .)
=======
    (47) boolean_mode -> BOOL .

    LPAREN          reduce using rule 47 (boolean_mode -> BOOL .)
    COMMA           reduce using rule 47 (boolean_mode -> BOOL .)
    RBRACKET        reduce using rule 47 (boolean_mode -> BOOL .)
    ASSIGN          reduce using rule 47 (boolean_mode -> BOOL .)
    SEMI            reduce using rule 47 (boolean_mode -> BOOL .)
    LOC             reduce using rule 47 (boolean_mode -> BOOL .)
    RPAREN          reduce using rule 47 (boolean_mode -> BOOL .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 54

<<<<<<< HEAD
    (89) operand3 -> operand4 .

    TIMES           reduce using rule 89 (operand3 -> operand4 .)
    DIVIDE          reduce using rule 89 (operand3 -> operand4 .)
    MODULO          reduce using rule 89 (operand3 -> operand4 .)
    PLUS            reduce using rule 89 (operand3 -> operand4 .)
    MINUS           reduce using rule 89 (operand3 -> operand4 .)
    CONCAT          reduce using rule 89 (operand3 -> operand4 .)
    AND             reduce using rule 89 (operand3 -> operand4 .)
    OR              reduce using rule 89 (operand3 -> operand4 .)
    EQUAL           reduce using rule 89 (operand3 -> operand4 .)
    NOTEQ           reduce using rule 89 (operand3 -> operand4 .)
    GREATER         reduce using rule 89 (operand3 -> operand4 .)
    GTEQUAL         reduce using rule 89 (operand3 -> operand4 .)
    LESS            reduce using rule 89 (operand3 -> operand4 .)
    LTEQUAL         reduce using rule 89 (operand3 -> operand4 .)
    IN              reduce using rule 89 (operand3 -> operand4 .)
    COMMA           reduce using rule 89 (operand3 -> operand4 .)
    RBRACKET        reduce using rule 89 (operand3 -> operand4 .)
    THEN            reduce using rule 89 (operand3 -> operand4 .)
    SEMI            reduce using rule 89 (operand3 -> operand4 .)
    LBRACKET        reduce using rule 89 (operand3 -> operand4 .)
    COLON           reduce using rule 89 (operand3 -> operand4 .)
    RPAREN          reduce using rule 89 (operand3 -> operand4 .)
    DCL             reduce using rule 89 (operand3 -> operand4 .)
    SYN             reduce using rule 89 (operand3 -> operand4 .)
    TYPE            reduce using rule 89 (operand3 -> operand4 .)
    ID              reduce using rule 89 (operand3 -> operand4 .)
    IF              reduce using rule 89 (operand3 -> operand4 .)
    $end            reduce using rule 89 (operand3 -> operand4 .)
    ELSE            reduce using rule 89 (operand3 -> operand4 .)
    ELSIF           reduce using rule 89 (operand3 -> operand4 .)
    FI              reduce using rule 89 (operand3 -> operand4 .)
=======
    (3) statement_nullable -> statement statement_nullable .

    $end            reduce using rule 3 (statement_nullable -> statement statement_nullable .)
    END             reduce using rule 3 (statement_nullable -> statement statement_nullable .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 55

<<<<<<< HEAD
    (127) boolean_literal -> TRUE .

    LBRACKET        reduce using rule 127 (boolean_literal -> TRUE .)
    TIMES           reduce using rule 127 (boolean_literal -> TRUE .)
    DIVIDE          reduce using rule 127 (boolean_literal -> TRUE .)
    MODULO          reduce using rule 127 (boolean_literal -> TRUE .)
    PLUS            reduce using rule 127 (boolean_literal -> TRUE .)
    MINUS           reduce using rule 127 (boolean_literal -> TRUE .)
    CONCAT          reduce using rule 127 (boolean_literal -> TRUE .)
    AND             reduce using rule 127 (boolean_literal -> TRUE .)
    OR              reduce using rule 127 (boolean_literal -> TRUE .)
    EQUAL           reduce using rule 127 (boolean_literal -> TRUE .)
    NOTEQ           reduce using rule 127 (boolean_literal -> TRUE .)
    GREATER         reduce using rule 127 (boolean_literal -> TRUE .)
    GTEQUAL         reduce using rule 127 (boolean_literal -> TRUE .)
    LESS            reduce using rule 127 (boolean_literal -> TRUE .)
    LTEQUAL         reduce using rule 127 (boolean_literal -> TRUE .)
    IN              reduce using rule 127 (boolean_literal -> TRUE .)
    COLON           reduce using rule 127 (boolean_literal -> TRUE .)
    THEN            reduce using rule 127 (boolean_literal -> TRUE .)
    FI              reduce using rule 127 (boolean_literal -> TRUE .)
    RPAREN          reduce using rule 127 (boolean_literal -> TRUE .)
    DCL             reduce using rule 127 (boolean_literal -> TRUE .)
    SYN             reduce using rule 127 (boolean_literal -> TRUE .)
    TYPE            reduce using rule 127 (boolean_literal -> TRUE .)
    ID              reduce using rule 127 (boolean_literal -> TRUE .)
    IF              reduce using rule 127 (boolean_literal -> TRUE .)
    $end            reduce using rule 127 (boolean_literal -> TRUE .)
    ELSE            reduce using rule 127 (boolean_literal -> TRUE .)
    ELSIF           reduce using rule 127 (boolean_literal -> TRUE .)
    COMMA           reduce using rule 127 (boolean_literal -> TRUE .)
    RBRACKET        reduce using rule 127 (boolean_literal -> TRUE .)
    SEMI            reduce using rule 127 (boolean_literal -> TRUE .)
=======
    (11) synonym_list -> synonym_definition COMMA . synonym_list
    (10) synonym_list -> . synonym_definition
    (11) synonym_list -> . synonym_definition COMMA synonym_list
    (12) synonym_definition -> . identifier_list mode ASSIGN expression
    (13) synonym_definition -> . identifier_list ASSIGN expression
    (20) identifier_list -> . identifier
    (21) identifier_list -> . identifier COMMA identifier_list
    (22) identifier -> . ID

    ID              shift and go to state 15
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

    synonym_definition             shift and go to state 24
    identifier                     shift and go to state 16
    synonym_list                   shift and go to state 71
    identifier_list                shift and go to state 26

state 56

<<<<<<< HEAD
    (56) location -> identifier .
    (63) string_element -> identifier . LBRACKET start_element LBRACKET
    (65) string_slice -> identifier . LBRACKET left_element COLON right_element RBRACKET

  ! shift/reduce conflict for LBRACKET resolved as shift
    ARROW           reduce using rule 56 (location -> identifier .)
    TIMES           reduce using rule 56 (location -> identifier .)
    DIVIDE          reduce using rule 56 (location -> identifier .)
    MODULO          reduce using rule 56 (location -> identifier .)
    PLUS            reduce using rule 56 (location -> identifier .)
    MINUS           reduce using rule 56 (location -> identifier .)
    CONCAT          reduce using rule 56 (location -> identifier .)
    AND             reduce using rule 56 (location -> identifier .)
    OR              reduce using rule 56 (location -> identifier .)
    EQUAL           reduce using rule 56 (location -> identifier .)
    NOTEQ           reduce using rule 56 (location -> identifier .)
    GREATER         reduce using rule 56 (location -> identifier .)
    GTEQUAL         reduce using rule 56 (location -> identifier .)
    LESS            reduce using rule 56 (location -> identifier .)
    LTEQUAL         reduce using rule 56 (location -> identifier .)
    IN              reduce using rule 56 (location -> identifier .)
    COLON           reduce using rule 56 (location -> identifier .)
    COMMA           reduce using rule 56 (location -> identifier .)
    SEMI            reduce using rule 56 (location -> identifier .)
    THEN            reduce using rule 56 (location -> identifier .)
    FI              reduce using rule 56 (location -> identifier .)
    RPAREN          reduce using rule 56 (location -> identifier .)
    DCL             reduce using rule 56 (location -> identifier .)
    SYN             reduce using rule 56 (location -> identifier .)
    TYPE            reduce using rule 56 (location -> identifier .)
    ID              reduce using rule 56 (location -> identifier .)
    IF              reduce using rule 56 (location -> identifier .)
    $end            reduce using rule 56 (location -> identifier .)
    ELSE            reduce using rule 56 (location -> identifier .)
    ELSIF           reduce using rule 56 (location -> identifier .)
    RBRACKET        reduce using rule 56 (location -> identifier .)
    ASSIGN          reduce using rule 56 (location -> identifier .)
    LBRACKET        shift and go to state 85

  ! LBRACKET        [ reduce using rule 56 (location -> identifier .) ]
=======
    (9) synonym_statement -> SYN synonym_list SEMI .

    DCL             reduce using rule 9 (synonym_statement -> SYN synonym_list SEMI .)
    SYN             reduce using rule 9 (synonym_statement -> SYN synonym_list SEMI .)
    TYPE            reduce using rule 9 (synonym_statement -> SYN synonym_list SEMI .)
    ID              reduce using rule 9 (synonym_statement -> SYN synonym_list SEMI .)
    $end            reduce using rule 9 (synonym_statement -> SYN synonym_list SEMI .)
    END             reduce using rule 9 (synonym_statement -> SYN synonym_list SEMI .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 57

<<<<<<< HEAD
    (20) identifier_list -> identifier .
    (21) identifier_list -> identifier . COMMA identifier_list

    ASSIGN          reduce using rule 20 (identifier_list -> identifier .)
    REF             reduce using rule 20 (identifier_list -> identifier .)
    ID              reduce using rule 20 (identifier_list -> identifier .)
    INT             reduce using rule 20 (identifier_list -> identifier .)
    BOOL            reduce using rule 20 (identifier_list -> identifier .)
    CHAR            reduce using rule 20 (identifier_list -> identifier .)
    CHARS           reduce using rule 20 (identifier_list -> identifier .)
    ARRAY           reduce using rule 20 (identifier_list -> identifier .)
    COMMA           shift and go to state 109


state 58

    (10) synonym_list -> synonym_definition .
    (11) synonym_list -> synonym_definition . COMMA synonym_list

    SEMI            reduce using rule 10 (synonym_list -> synonym_definition .)
    COMMA           shift and go to state 110
=======
    (13) synonym_definition -> identifier_list ASSIGN . expression
    (82) expression -> . operand0
    (83) expression -> . conditional_expression
    (90) operand0 -> . operand1
    (91) operand0 -> . operand0 operator1 operand1
    (84) conditional_expression -> . IF expression then_expression else_expression FI
    (85) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (92) operand1 -> . operand2
    (93) operand1 -> . operand1 operator2 operand2
    (94) operand2 -> . operand3
    (95) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (96) operand3 -> . monadic_operator operand4
    (97) operand3 -> . operand4
    (104) monadic_operator -> . MINUS
    (105) monadic_operator -> . NOT
    (98) operand4 -> . array_location
    (99) operand4 -> . referenced_location
    (100) operand4 -> . primitive_value
    (81) array_location -> . location
    (106) referenced_location -> . ARROW array_location
    (123) primitive_value -> . literal
    (65) location -> . identifier
    (66) location -> . dereferenced_reference
    (67) location -> . string_element
    (68) location -> . string_slice
    (69) location -> . array_element
    (70) location -> . array_slice
    (124) literal -> . integer_literal
    (125) literal -> . boolean_literal
    (126) literal -> . character_literal
    (127) literal -> . empty_literal
    (128) literal -> . character_string_literal
    (22) identifier -> . ID
    (71) dereferenced_reference -> . array_location ARROW
    (72) string_element -> . identifier LBRACKET start_element LBRACKET
    (74) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (77) array_element -> . array_location LBRACKET expression_list RBRACKET
    (80) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (129) integer_literal -> . ICONST
    (130) boolean_literal -> . TRUE
    (131) boolean_literal -> . FALSE
    (132) character_literal -> . CCONST
    (133) empty_literal -> . NULL
    (134) character_string_literal -> . SCONST

    IF              shift and go to state 99
    MINUS           shift and go to state 90
    NOT             shift and go to state 96
    ARROW           shift and go to state 72
    ID              shift and go to state 15
    ICONST          shift and go to state 89
    TRUE            shift and go to state 87
    FALSE           shift and go to state 80
    CCONST          shift and go to state 91
    NULL            shift and go to state 97
    SCONST          shift and go to state 95

    monadic_operator               shift and go to state 93
    character_literal              shift and go to state 85
    character_string_literal       shift and go to state 94
    identifier                     shift and go to state 84
    array_location                 shift and go to state 73
    literal                        shift and go to state 74
    dereferenced_reference         shift and go to state 75
    operand3                       shift and go to state 76
    integer_literal                shift and go to state 77
    array_slice                    shift and go to state 83
    primitive_value                shift and go to state 78
    referenced_location            shift and go to state 79
    string_slice                   shift and go to state 98
    string_element                 shift and go to state 81
    location                       shift and go to state 82
    conditional_expression         shift and go to state 100
    operand2                       shift and go to state 103
    empty_literal                  shift and go to state 101
    operand1                       shift and go to state 86
    operand4                       shift and go to state 102
    expression                     shift and go to state 88
    boolean_literal                shift and go to state 104
    operand0                       shift and go to state 105
    array_element                  shift and go to state 92

state 58

    (12) synonym_definition -> identifier_list mode . ASSIGN expression

    ASSIGN          shift and go to state 106
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 59

<<<<<<< HEAD
    (12) synonym_definition -> identifier_list . mode ASSIGN expression
    (13) synonym_definition -> identifier_list . ASSIGN expression
    (27) mode -> . mode_name
    (28) mode -> . discrete_mode
    (29) mode -> . reference_mode
    (30) mode -> . composite_mode
    (31) mode_name -> . identifier
    (32) discrete_mode -> . integer_mode
    (33) discrete_mode -> . boolean_mode
    (34) discrete_mode -> . character_mode
    (35) discrete_mode -> . discrete_range_mode
    (45) reference_mode -> . REF mode
    (46) composite_mode -> . string_mode
    (47) composite_mode -> . array_mode
    (22) identifier -> . ID
    (37) integer_mode -> . INT
    (38) boolean_mode -> . BOOL
    (39) character_mode -> . CHAR
    (40) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (41) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (48) string_mode -> . CHARS LBRACKET string_length RBRACKET
    (50) array_mode -> . ARRAY LBRACKET index_mode_list RBRACKET element_mode
    (36) discrete_mode_name -> . identifier

    ASSIGN          shift and go to state 126
    REF             shift and go to state 118
    ID              shift and go to state 21
    INT             shift and go to state 119
    BOOL            shift and go to state 130
    CHAR            shift and go to state 112
    CHARS           shift and go to state 125
    ARRAY           shift and go to state 121

    string_mode                    shift and go to state 111
    mode                           shift and go to state 113
    reference_mode                 shift and go to state 114
    boolean_mode                   shift and go to state 122
    composite_mode                 shift and go to state 123
    integer_mode                   shift and go to state 117
    character_mode                 shift and go to state 124
    mode_name                      shift and go to state 120
    array_mode                     shift and go to state 115
    discrete_range_mode            shift and go to state 127
    discrete_mode                  shift and go to state 128
    discrete_mode_name             shift and go to state 116
    identifier                     shift and go to state 129

state 60

    (9) synonym_statement -> SYN synonym_list . SEMI

    SEMI            shift and go to state 131
=======
    (28) procedure_definition -> PROC LPAREN . formal_parameter_list RPAREN result_spec SEMI statement_nullable END SEMI
    (29) procedure_definition -> PROC LPAREN . formal_parameter_list RPAREN SEMI statement_nullable END SEMI
    (30) formal_parameter_list -> . formal_parameter
    (31) formal_parameter_list -> . formal_parameter COMMA formal_parameter
    (32) formal_parameter -> . identifier_list mode LOC
    (33) formal_parameter -> . identifier_list mode
    (20) identifier_list -> . identifier
    (21) identifier_list -> . identifier COMMA identifier_list
    (22) identifier -> . ID

    ID              shift and go to state 15

    formal_parameter               shift and go to state 107
    identifier                     shift and go to state 16
    formal_parameter_list          shift and go to state 108
    identifier_list                shift and go to state 109

state 60

    (25) newmode_list -> mode_definition COMMA newmode_list .

    SEMI            reduce using rule 25 (newmode_list -> mode_definition COMMA newmode_list .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 61

<<<<<<< HEAD
    (62) dereferenced_reference -> array_location ARROW .

    ARROW           reduce using rule 62 (dereferenced_reference -> array_location ARROW .)
    LBRACKET        reduce using rule 62 (dereferenced_reference -> array_location ARROW .)
    ASSIGN          reduce using rule 62 (dereferenced_reference -> array_location ARROW .)
    PLUS            reduce using rule 62 (dereferenced_reference -> array_location ARROW .)
    MINUS           reduce using rule 62 (dereferenced_reference -> array_location ARROW .)
    TIMES           reduce using rule 62 (dereferenced_reference -> array_location ARROW .)
    DIVIDE          reduce using rule 62 (dereferenced_reference -> array_location ARROW .)
    MODULO          reduce using rule 62 (dereferenced_reference -> array_location ARROW .)
    CONCAT          reduce using rule 62 (dereferenced_reference -> array_location ARROW .)
    AND             reduce using rule 62 (dereferenced_reference -> array_location ARROW .)
    OR              reduce using rule 62 (dereferenced_reference -> array_location ARROW .)
    EQUAL           reduce using rule 62 (dereferenced_reference -> array_location ARROW .)
    NOTEQ           reduce using rule 62 (dereferenced_reference -> array_location ARROW .)
    GREATER         reduce using rule 62 (dereferenced_reference -> array_location ARROW .)
    GTEQUAL         reduce using rule 62 (dereferenced_reference -> array_location ARROW .)
    LESS            reduce using rule 62 (dereferenced_reference -> array_location ARROW .)
    LTEQUAL         reduce using rule 62 (dereferenced_reference -> array_location ARROW .)
    IN              reduce using rule 62 (dereferenced_reference -> array_location ARROW .)
    ELSE            reduce using rule 62 (dereferenced_reference -> array_location ARROW .)
    ELSIF           reduce using rule 62 (dereferenced_reference -> array_location ARROW .)
    COLON           reduce using rule 62 (dereferenced_reference -> array_location ARROW .)
    THEN            reduce using rule 62 (dereferenced_reference -> array_location ARROW .)
    RPAREN          reduce using rule 62 (dereferenced_reference -> array_location ARROW .)
    DCL             reduce using rule 62 (dereferenced_reference -> array_location ARROW .)
    SYN             reduce using rule 62 (dereferenced_reference -> array_location ARROW .)
    TYPE            reduce using rule 62 (dereferenced_reference -> array_location ARROW .)
    ID              reduce using rule 62 (dereferenced_reference -> array_location ARROW .)
    IF              reduce using rule 62 (dereferenced_reference -> array_location ARROW .)
    $end            reduce using rule 62 (dereferenced_reference -> array_location ARROW .)
    FI              reduce using rule 62 (dereferenced_reference -> array_location ARROW .)
    COMMA           reduce using rule 62 (dereferenced_reference -> array_location ARROW .)
    RBRACKET        reduce using rule 62 (dereferenced_reference -> array_location ARROW .)
    SEMI            reduce using rule 62 (dereferenced_reference -> array_location ARROW .)
=======
    (21) identifier_list -> identifier COMMA identifier_list .

    ASSIGN          reduce using rule 21 (identifier_list -> identifier COMMA identifier_list .)
    REF             reduce using rule 21 (identifier_list -> identifier COMMA identifier_list .)
    ID              reduce using rule 21 (identifier_list -> identifier COMMA identifier_list .)
    INT             reduce using rule 21 (identifier_list -> identifier COMMA identifier_list .)
    BOOL            reduce using rule 21 (identifier_list -> identifier COMMA identifier_list .)
    CHAR            reduce using rule 21 (identifier_list -> identifier COMMA identifier_list .)
    CHARS           reduce using rule 21 (identifier_list -> identifier COMMA identifier_list .)
    ARRAY           reduce using rule 21 (identifier_list -> identifier COMMA identifier_list .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 62

<<<<<<< HEAD
    (141) closed_dyadic_operator -> arithmetic_multiplicative_operator .

    ASSIGN          reduce using rule 141 (closed_dyadic_operator -> arithmetic_multiplicative_operator .)
=======
    (26) mode_definition -> identifier_list ASSIGN mode .

    COMMA           reduce using rule 26 (mode_definition -> identifier_list ASSIGN mode .)
    SEMI            reduce using rule 26 (mode_definition -> identifier_list ASSIGN mode .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 63

<<<<<<< HEAD
    (139) assigning_operator -> ASSIGN .

    IF              reduce using rule 139 (assigning_operator -> ASSIGN .)
    MINUS           reduce using rule 139 (assigning_operator -> ASSIGN .)
    NOT             reduce using rule 139 (assigning_operator -> ASSIGN .)
    ARROW           reduce using rule 139 (assigning_operator -> ASSIGN .)
    LPAREN          reduce using rule 139 (assigning_operator -> ASSIGN .)
    ID              reduce using rule 139 (assigning_operator -> ASSIGN .)
    ICONST          reduce using rule 139 (assigning_operator -> ASSIGN .)
    TRUE            reduce using rule 139 (assigning_operator -> ASSIGN .)
    FALSE           reduce using rule 139 (assigning_operator -> ASSIGN .)
    CCONST          reduce using rule 139 (assigning_operator -> ASSIGN .)
    NULL            reduce using rule 139 (assigning_operator -> ASSIGN .)
    SCONST          reduce using rule 139 (assigning_operator -> ASSIGN .)

=======
    (16) declaration_list -> declaration COMMA declaration_list .
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

    SEMI            reduce using rule 16 (declaration_list -> declaration COMMA declaration_list .)

<<<<<<< HEAD
    (103) arithmetic_additive_operator -> PLUS .

    ASSIGN          reduce using rule 103 (arithmetic_additive_operator -> PLUS .)
    MINUS           reduce using rule 103 (arithmetic_additive_operator -> PLUS .)
    NOT             reduce using rule 103 (arithmetic_additive_operator -> PLUS .)
    ARROW           reduce using rule 103 (arithmetic_additive_operator -> PLUS .)
    LPAREN          reduce using rule 103 (arithmetic_additive_operator -> PLUS .)
    ID              reduce using rule 103 (arithmetic_additive_operator -> PLUS .)
    ICONST          reduce using rule 103 (arithmetic_additive_operator -> PLUS .)
    TRUE            reduce using rule 103 (arithmetic_additive_operator -> PLUS .)
    FALSE           reduce using rule 103 (arithmetic_additive_operator -> PLUS .)
    CCONST          reduce using rule 103 (arithmetic_additive_operator -> PLUS .)
    NULL            reduce using rule 103 (arithmetic_additive_operator -> PLUS .)
    SCONST          reduce using rule 103 (arithmetic_additive_operator -> PLUS .)
=======

state 64
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

    (50) discrete_range_mode -> discrete_mode LPAREN . literal_range RPAREN
    (51) literal_range -> . lower_bound COLON upper_bound
    (52) lower_bound -> . expression
    (82) expression -> . operand0
    (83) expression -> . conditional_expression
    (90) operand0 -> . operand1
    (91) operand0 -> . operand0 operator1 operand1
    (84) conditional_expression -> . IF expression then_expression else_expression FI
    (85) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (92) operand1 -> . operand2
    (93) operand1 -> . operand1 operator2 operand2
    (94) operand2 -> . operand3
    (95) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (96) operand3 -> . monadic_operator operand4
    (97) operand3 -> . operand4
    (104) monadic_operator -> . MINUS
    (105) monadic_operator -> . NOT
    (98) operand4 -> . array_location
    (99) operand4 -> . referenced_location
    (100) operand4 -> . primitive_value
    (81) array_location -> . location
    (106) referenced_location -> . ARROW array_location
    (123) primitive_value -> . literal
    (65) location -> . identifier
    (66) location -> . dereferenced_reference
    (67) location -> . string_element
    (68) location -> . string_slice
    (69) location -> . array_element
    (70) location -> . array_slice
    (124) literal -> . integer_literal
    (125) literal -> . boolean_literal
    (126) literal -> . character_literal
    (127) literal -> . empty_literal
    (128) literal -> . character_string_literal
    (22) identifier -> . ID
    (71) dereferenced_reference -> . array_location ARROW
    (72) string_element -> . identifier LBRACKET start_element LBRACKET
    (74) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (77) array_element -> . array_location LBRACKET expression_list RBRACKET
    (80) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (129) integer_literal -> . ICONST
    (130) boolean_literal -> . TRUE
    (131) boolean_literal -> . FALSE
    (132) character_literal -> . CCONST
    (133) empty_literal -> . NULL
    (134) character_string_literal -> . SCONST

    IF              shift and go to state 99
    MINUS           shift and go to state 90
    NOT             shift and go to state 96
    ARROW           shift and go to state 72
    ID              shift and go to state 15
    ICONST          shift and go to state 89
    TRUE            shift and go to state 87
    FALSE           shift and go to state 80
    CCONST          shift and go to state 91
    NULL            shift and go to state 97
    SCONST          shift and go to state 95

    monadic_operator               shift and go to state 93
    character_literal              shift and go to state 85
    character_string_literal       shift and go to state 94
    identifier                     shift and go to state 84
    array_location                 shift and go to state 73
    literal                        shift and go to state 74
    dereferenced_reference         shift and go to state 75
    lower_bound                    shift and go to state 112
    operand3                       shift and go to state 76
    integer_literal                shift and go to state 77
    array_slice                    shift and go to state 83
    primitive_value                shift and go to state 78
    referenced_location            shift and go to state 79
    literal_range                  shift and go to state 110
    string_slice                   shift and go to state 98
    string_element                 shift and go to state 81
    location                       shift and go to state 82
    conditional_expression         shift and go to state 100
    operand2                       shift and go to state 103
    empty_literal                  shift and go to state 101
    operand1                       shift and go to state 86
    operand4                       shift and go to state 102
    expression                     shift and go to state 111
    boolean_literal                shift and go to state 104
    operand0                       shift and go to state 105
    array_element                  shift and go to state 92

state 65

<<<<<<< HEAD
    (142) closed_dyadic_operator -> string_concatenation_operator .

    ASSIGN          reduce using rule 142 (closed_dyadic_operator -> string_concatenation_operator .)
=======
    (54) reference_mode -> REF mode .

    ASSIGN          reduce using rule 54 (reference_mode -> REF mode .)
    COMMA           reduce using rule 54 (reference_mode -> REF mode .)
    SEMI            reduce using rule 54 (reference_mode -> REF mode .)
    LOC             reduce using rule 54 (reference_mode -> REF mode .)
    RPAREN          reduce using rule 54 (reference_mode -> REF mode .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 66

<<<<<<< HEAD
    (138) assigning_operator -> closed_dyadic_operator . ASSIGN

    ASSIGN          shift and go to state 132
=======
    (57) string_mode -> CHARS LBRACKET . string_length RBRACKET
    (58) string_length -> . integer_literal
    (129) integer_literal -> . ICONST
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

    ICONST          shift and go to state 89

    integer_literal                shift and go to state 113
    string_length                  shift and go to state 114

<<<<<<< HEAD
    (140) closed_dyadic_operator -> arithmetic_additive_operator .

    ASSIGN          reduce using rule 140 (closed_dyadic_operator -> arithmetic_additive_operator .)
=======
state 67
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

    (49) discrete_range_mode -> discrete_mode_name LPAREN . literal_range RPAREN
    (51) literal_range -> . lower_bound COLON upper_bound
    (52) lower_bound -> . expression
    (82) expression -> . operand0
    (83) expression -> . conditional_expression
    (90) operand0 -> . operand1
    (91) operand0 -> . operand0 operator1 operand1
    (84) conditional_expression -> . IF expression then_expression else_expression FI
    (85) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (92) operand1 -> . operand2
    (93) operand1 -> . operand1 operator2 operand2
    (94) operand2 -> . operand3
    (95) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (96) operand3 -> . monadic_operator operand4
    (97) operand3 -> . operand4
    (104) monadic_operator -> . MINUS
    (105) monadic_operator -> . NOT
    (98) operand4 -> . array_location
    (99) operand4 -> . referenced_location
    (100) operand4 -> . primitive_value
    (81) array_location -> . location
    (106) referenced_location -> . ARROW array_location
    (123) primitive_value -> . literal
    (65) location -> . identifier
    (66) location -> . dereferenced_reference
    (67) location -> . string_element
    (68) location -> . string_slice
    (69) location -> . array_element
    (70) location -> . array_slice
    (124) literal -> . integer_literal
    (125) literal -> . boolean_literal
    (126) literal -> . character_literal
    (127) literal -> . empty_literal
    (128) literal -> . character_string_literal
    (22) identifier -> . ID
    (71) dereferenced_reference -> . array_location ARROW
    (72) string_element -> . identifier LBRACKET start_element LBRACKET
    (74) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (77) array_element -> . array_location LBRACKET expression_list RBRACKET
    (80) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (129) integer_literal -> . ICONST
    (130) boolean_literal -> . TRUE
    (131) boolean_literal -> . FALSE
    (132) character_literal -> . CCONST
    (133) empty_literal -> . NULL
    (134) character_string_literal -> . SCONST

    IF              shift and go to state 99
    MINUS           shift and go to state 90
    NOT             shift and go to state 96
    ARROW           shift and go to state 72
    ID              shift and go to state 15
    ICONST          shift and go to state 89
    TRUE            shift and go to state 87
    FALSE           shift and go to state 80
    CCONST          shift and go to state 91
    NULL            shift and go to state 97
    SCONST          shift and go to state 95

    monadic_operator               shift and go to state 93
    character_literal              shift and go to state 85
    character_string_literal       shift and go to state 94
    identifier                     shift and go to state 84
    array_location                 shift and go to state 73
    literal                        shift and go to state 74
    dereferenced_reference         shift and go to state 75
    lower_bound                    shift and go to state 112
    operand3                       shift and go to state 76
    integer_literal                shift and go to state 77
    array_slice                    shift and go to state 83
    primitive_value                shift and go to state 78
    referenced_location            shift and go to state 79
    literal_range                  shift and go to state 115
    string_slice                   shift and go to state 98
    string_element                 shift and go to state 81
    location                       shift and go to state 82
    conditional_expression         shift and go to state 100
    operand2                       shift and go to state 103
    empty_literal                  shift and go to state 101
    operand1                       shift and go to state 86
    operand4                       shift and go to state 102
    expression                     shift and go to state 111
    boolean_literal                shift and go to state 104
    operand0                       shift and go to state 105
    array_element                  shift and go to state 92

state 68

<<<<<<< HEAD
    (105) string_concatenation_operator -> CONCAT .

    MINUS           reduce using rule 105 (string_concatenation_operator -> CONCAT .)
    NOT             reduce using rule 105 (string_concatenation_operator -> CONCAT .)
    ARROW           reduce using rule 105 (string_concatenation_operator -> CONCAT .)
    LPAREN          reduce using rule 105 (string_concatenation_operator -> CONCAT .)
    ID              reduce using rule 105 (string_concatenation_operator -> CONCAT .)
    ICONST          reduce using rule 105 (string_concatenation_operator -> CONCAT .)
    TRUE            reduce using rule 105 (string_concatenation_operator -> CONCAT .)
    FALSE           reduce using rule 105 (string_concatenation_operator -> CONCAT .)
    CCONST          reduce using rule 105 (string_concatenation_operator -> CONCAT .)
    NULL            reduce using rule 105 (string_concatenation_operator -> CONCAT .)
    SCONST          reduce using rule 105 (string_concatenation_operator -> CONCAT .)
    ASSIGN          reduce using rule 105 (string_concatenation_operator -> CONCAT .)
=======
    (19) initialization -> ASSIGN . expression
    (82) expression -> . operand0
    (83) expression -> . conditional_expression
    (90) operand0 -> . operand1
    (91) operand0 -> . operand0 operator1 operand1
    (84) conditional_expression -> . IF expression then_expression else_expression FI
    (85) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (92) operand1 -> . operand2
    (93) operand1 -> . operand1 operator2 operand2
    (94) operand2 -> . operand3
    (95) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (96) operand3 -> . monadic_operator operand4
    (97) operand3 -> . operand4
    (104) monadic_operator -> . MINUS
    (105) monadic_operator -> . NOT
    (98) operand4 -> . array_location
    (99) operand4 -> . referenced_location
    (100) operand4 -> . primitive_value
    (81) array_location -> . location
    (106) referenced_location -> . ARROW array_location
    (123) primitive_value -> . literal
    (65) location -> . identifier
    (66) location -> . dereferenced_reference
    (67) location -> . string_element
    (68) location -> . string_slice
    (69) location -> . array_element
    (70) location -> . array_slice
    (124) literal -> . integer_literal
    (125) literal -> . boolean_literal
    (126) literal -> . character_literal
    (127) literal -> . empty_literal
    (128) literal -> . character_string_literal
    (22) identifier -> . ID
    (71) dereferenced_reference -> . array_location ARROW
    (72) string_element -> . identifier LBRACKET start_element LBRACKET
    (74) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (77) array_element -> . array_location LBRACKET expression_list RBRACKET
    (80) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (129) integer_literal -> . ICONST
    (130) boolean_literal -> . TRUE
    (131) boolean_literal -> . FALSE
    (132) character_literal -> . CCONST
    (133) empty_literal -> . NULL
    (134) character_string_literal -> . SCONST

    IF              shift and go to state 99
    MINUS           shift and go to state 90
    NOT             shift and go to state 96
    ARROW           shift and go to state 72
    ID              shift and go to state 15
    ICONST          shift and go to state 89
    TRUE            shift and go to state 87
    FALSE           shift and go to state 80
    CCONST          shift and go to state 91
    NULL            shift and go to state 97
    SCONST          shift and go to state 95

    monadic_operator               shift and go to state 93
    character_literal              shift and go to state 85
    character_string_literal       shift and go to state 94
    identifier                     shift and go to state 84
    array_location                 shift and go to state 73
    literal                        shift and go to state 74
    dereferenced_reference         shift and go to state 75
    operand3                       shift and go to state 76
    integer_literal                shift and go to state 77
    array_slice                    shift and go to state 83
    primitive_value                shift and go to state 78
    referenced_location            shift and go to state 79
    string_slice                   shift and go to state 98
    string_element                 shift and go to state 81
    location                       shift and go to state 82
    conditional_expression         shift and go to state 100
    operand2                       shift and go to state 103
    empty_literal                  shift and go to state 101
    operand1                       shift and go to state 86
    operand4                       shift and go to state 102
    expression                     shift and go to state 116
    boolean_literal                shift and go to state 104
    operand0                       shift and go to state 105
    array_element                  shift and go to state 92

state 69
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

    (17) declaration -> identifier_list mode initialization .

    COMMA           reduce using rule 17 (declaration -> identifier_list mode initialization .)
    SEMI            reduce using rule 17 (declaration -> identifier_list mode initialization .)

<<<<<<< HEAD
    (137) assignment_action -> array_location assigning_operator . expression
    (73) expression -> . operand0
    (74) expression -> . conditional_expression
    (82) operand0 -> . operand1
    (83) operand0 -> . operand0 operator1 operand1
    (76) conditional_expression -> . IF expression then_expression else_expression FI
    (77) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (84) operand1 -> . operand2
    (85) operand1 -> . operand1 operator2 operand2
    (86) operand2 -> . operand3
    (87) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (88) operand3 -> . monadic_operator operand4
    (89) operand3 -> . operand4
    (96) monadic_operator -> . MINUS
    (97) monadic_operator -> . NOT
    (90) operand4 -> . array_location
    (91) operand4 -> . referenced_location
    (92) operand4 -> . primitive_value
    (72) array_location -> . location
    (98) referenced_location -> . ARROW array_location
    (115) primitive_value -> . literal
    (116) primitive_value -> . value_array_element
    (117) primitive_value -> . value_array_slice
    (118) primitive_value -> . parenthesized_expression
    (56) location -> . identifier
    (57) location -> . dereferenced_reference
    (58) location -> . string_element
    (59) location -> . string_slice
    (60) location -> . array_element
    (61) location -> . array_slice
    (119) literal -> . integer_literal
    (120) literal -> . boolean_literal
    (121) literal -> . character_literal
    (122) literal -> . empty_literal
    (123) literal -> . character_string_literal
    (124) value_array_element -> . primitive_value LBRACKET expression_list RBRACKET
    (125) value_array_slice -> . primitive_value LBRACKET expression COLON expression RBRACKET
    (75) parenthesized_expression -> . LPAREN expression RPAREN
    (22) identifier -> . ID
    (62) dereferenced_reference -> . array_location ARROW
    (63) string_element -> . identifier LBRACKET start_element LBRACKET
    (65) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (68) array_element -> . array_location LBRACKET expression_list RBRACKET
    (71) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (126) integer_literal -> . ICONST
    (127) boolean_literal -> . TRUE
    (128) boolean_literal -> . FALSE
    (129) character_literal -> . CCONST
    (130) empty_literal -> . NULL
    (131) character_string_literal -> . SCONST

    IF              shift and go to state 31
    MINUS           shift and go to state 36
    NOT             shift and go to state 35
    ARROW           shift and go to state 45
    LPAREN          shift and go to state 44
    ID              shift and go to state 21
    ICONST          shift and go to state 40
    TRUE            shift and go to state 55
    FALSE           shift and go to state 53
    CCONST          shift and go to state 34
    NULL            shift and go to state 27
    SCONST          shift and go to state 52

    location                       shift and go to state 6
    monadic_operator               shift and go to state 47
    operand2                       shift and go to state 49
    value_array_element            shift and go to state 48
    operand1                       shift and go to state 25
    expression                     shift and go to state 133
    character_literal              shift and go to state 41
    conditional_expression         shift and go to state 28
    referenced_location            shift and go to state 29
    parenthesized_expression       shift and go to state 30
    array_slice                    shift and go to state 15
    integer_literal                shift and go to state 32
    empty_literal                  shift and go to state 50
    operand3                       shift and go to state 33
    string_slice                   shift and go to state 3
    string_element                 shift and go to state 1
    boolean_literal                shift and go to state 51
    array_location                 shift and go to state 46
    literal                        shift and go to state 37
    operand0                       shift and go to state 38
    primitive_value                shift and go to state 39
    array_element                  shift and go to state 7
    value_array_slice              shift and go to state 42
    operand4                       shift and go to state 54
    character_string_literal       shift and go to state 43
    dereferenced_reference         shift and go to state 20
    identifier                     shift and go to state 56

state 70

    (94) arithmetic_multiplicative_operator -> DIVIDE .

    MINUS           reduce using rule 94 (arithmetic_multiplicative_operator -> DIVIDE .)
    NOT             reduce using rule 94 (arithmetic_multiplicative_operator -> DIVIDE .)
    ARROW           reduce using rule 94 (arithmetic_multiplicative_operator -> DIVIDE .)
    LPAREN          reduce using rule 94 (arithmetic_multiplicative_operator -> DIVIDE .)
    ID              reduce using rule 94 (arithmetic_multiplicative_operator -> DIVIDE .)
    ICONST          reduce using rule 94 (arithmetic_multiplicative_operator -> DIVIDE .)
    TRUE            reduce using rule 94 (arithmetic_multiplicative_operator -> DIVIDE .)
    FALSE           reduce using rule 94 (arithmetic_multiplicative_operator -> DIVIDE .)
    CCONST          reduce using rule 94 (arithmetic_multiplicative_operator -> DIVIDE .)
    NULL            reduce using rule 94 (arithmetic_multiplicative_operator -> DIVIDE .)
    SCONST          reduce using rule 94 (arithmetic_multiplicative_operator -> DIVIDE .)
    ASSIGN          reduce using rule 94 (arithmetic_multiplicative_operator -> DIVIDE .)
=======

state 70

    (59) array_mode -> ARRAY LBRACKET . index_mode_list RBRACKET element_mode
    (60) index_mode_list -> . index_mode
    (61) index_mode_list -> . index_mode COMMA index_mode_list
    (62) index_mode -> . discrete_mode
    (63) index_mode -> . literal_range
    (41) discrete_mode -> . integer_mode
    (42) discrete_mode -> . boolean_mode
    (43) discrete_mode -> . character_mode
    (44) discrete_mode -> . discrete_range_mode
    (51) literal_range -> . lower_bound COLON upper_bound
    (46) integer_mode -> . INT
    (47) boolean_mode -> . BOOL
    (48) character_mode -> . CHAR
    (49) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (50) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (52) lower_bound -> . expression
    (45) discrete_mode_name -> . identifier
    (82) expression -> . operand0
    (83) expression -> . conditional_expression
    (22) identifier -> . ID
    (90) operand0 -> . operand1
    (91) operand0 -> . operand0 operator1 operand1
    (84) conditional_expression -> . IF expression then_expression else_expression FI
    (85) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (92) operand1 -> . operand2
    (93) operand1 -> . operand1 operator2 operand2
    (94) operand2 -> . operand3
    (95) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (96) operand3 -> . monadic_operator operand4
    (97) operand3 -> . operand4
    (104) monadic_operator -> . MINUS
    (105) monadic_operator -> . NOT
    (98) operand4 -> . array_location
    (99) operand4 -> . referenced_location
    (100) operand4 -> . primitive_value
    (81) array_location -> . location
    (106) referenced_location -> . ARROW array_location
    (123) primitive_value -> . literal
    (65) location -> . identifier
    (66) location -> . dereferenced_reference
    (67) location -> . string_element
    (68) location -> . string_slice
    (69) location -> . array_element
    (70) location -> . array_slice
    (124) literal -> . integer_literal
    (125) literal -> . boolean_literal
    (126) literal -> . character_literal
    (127) literal -> . empty_literal
    (128) literal -> . character_string_literal
    (71) dereferenced_reference -> . array_location ARROW
    (72) string_element -> . identifier LBRACKET start_element LBRACKET
    (74) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (77) array_element -> . array_location LBRACKET expression_list RBRACKET
    (80) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (129) integer_literal -> . ICONST
    (130) boolean_literal -> . TRUE
    (131) boolean_literal -> . FALSE
    (132) character_literal -> . CCONST
    (133) empty_literal -> . NULL
    (134) character_string_literal -> . SCONST

    INT             shift and go to state 39
    BOOL            shift and go to state 53
    CHAR            shift and go to state 51
    ID              shift and go to state 15
    IF              shift and go to state 99
    MINUS           shift and go to state 90
    NOT             shift and go to state 96
    ARROW           shift and go to state 72
    ICONST          shift and go to state 89
    TRUE            shift and go to state 87
    FALSE           shift and go to state 80
    CCONST          shift and go to state 91
    NULL            shift and go to state 97
    SCONST          shift and go to state 95

    literal                        shift and go to state 74
    literal_range                  shift and go to state 119
    dereferenced_reference         shift and go to state 75
    operand3                       shift and go to state 76
    integer_literal                shift and go to state 77
    primitive_value                shift and go to state 78
    referenced_location            shift and go to state 79
    string_element                 shift and go to state 81
    location                       shift and go to state 82
    discrete_range_mode            shift and go to state 45
    array_slice                    shift and go to state 83
    operand2                       shift and go to state 103
    character_mode                 shift and go to state 47
    character_literal              shift and go to state 85
    operand1                       shift and go to state 86
    boolean_mode                   shift and go to state 50
    integer_mode                   shift and go to state 40
    index_mode_list                shift and go to state 120
    array_element                  shift and go to state 92
    monadic_operator               shift and go to state 93
    character_string_literal       shift and go to state 94
    identifier                     shift and go to state 117
    discrete_mode                  shift and go to state 118
    expression                     shift and go to state 111
    lower_bound                    shift and go to state 112
    string_slice                   shift and go to state 98
    conditional_expression         shift and go to state 100
    array_location                 shift and go to state 73
    discrete_mode_name             shift and go to state 48
    empty_literal                  shift and go to state 101
    operand4                       shift and go to state 102
    boolean_literal                shift and go to state 104
    operand0                       shift and go to state 105
    index_mode                     shift and go to state 121
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


<<<<<<< HEAD
state 71

    (68) array_element -> array_location LBRACKET . expression_list RBRACKET
    (71) array_slice -> array_location LBRACKET . lower_bound COLON upper_bound RBRACKET
    (69) expression_list -> . expression
    (70) expression_list -> . expression COMMA expression_list
    (43) lower_bound -> . expression
    (73) expression -> . operand0
    (74) expression -> . conditional_expression
    (82) operand0 -> . operand1
    (83) operand0 -> . operand0 operator1 operand1
    (76) conditional_expression -> . IF expression then_expression else_expression FI
    (77) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (84) operand1 -> . operand2
    (85) operand1 -> . operand1 operator2 operand2
    (86) operand2 -> . operand3
    (87) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (88) operand3 -> . monadic_operator operand4
    (89) operand3 -> . operand4
    (96) monadic_operator -> . MINUS
    (97) monadic_operator -> . NOT
    (90) operand4 -> . array_location
    (91) operand4 -> . referenced_location
    (92) operand4 -> . primitive_value
    (72) array_location -> . location
    (98) referenced_location -> . ARROW array_location
    (115) primitive_value -> . literal
    (116) primitive_value -> . value_array_element
    (117) primitive_value -> . value_array_slice
    (118) primitive_value -> . parenthesized_expression
    (56) location -> . identifier
    (57) location -> . dereferenced_reference
    (58) location -> . string_element
    (59) location -> . string_slice
    (60) location -> . array_element
    (61) location -> . array_slice
    (119) literal -> . integer_literal
    (120) literal -> . boolean_literal
    (121) literal -> . character_literal
    (122) literal -> . empty_literal
    (123) literal -> . character_string_literal
    (124) value_array_element -> . primitive_value LBRACKET expression_list RBRACKET
    (125) value_array_slice -> . primitive_value LBRACKET expression COLON expression RBRACKET
    (75) parenthesized_expression -> . LPAREN expression RPAREN
    (22) identifier -> . ID
    (62) dereferenced_reference -> . array_location ARROW
    (63) string_element -> . identifier LBRACKET start_element LBRACKET
    (65) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (68) array_element -> . array_location LBRACKET expression_list RBRACKET
    (71) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (126) integer_literal -> . ICONST
    (127) boolean_literal -> . TRUE
    (128) boolean_literal -> . FALSE
    (129) character_literal -> . CCONST
    (130) empty_literal -> . NULL
    (131) character_string_literal -> . SCONST

    IF              shift and go to state 31
    MINUS           shift and go to state 36
    NOT             shift and go to state 35
    ARROW           shift and go to state 45
    LPAREN          shift and go to state 44
    ID              shift and go to state 21
    ICONST          shift and go to state 40
    TRUE            shift and go to state 55
    FALSE           shift and go to state 53
    CCONST          shift and go to state 34
    NULL            shift and go to state 27
    SCONST          shift and go to state 52

    location                       shift and go to state 6
    monadic_operator               shift and go to state 47
    operand2                       shift and go to state 49
    value_array_element            shift and go to state 48
    operand1                       shift and go to state 25
    expression                     shift and go to state 134
    conditional_expression         shift and go to state 28
    referenced_location            shift and go to state 29
    expression_list                shift and go to state 135
    parenthesized_expression       shift and go to state 30
    integer_literal                shift and go to state 32
    empty_literal                  shift and go to state 50
    array_element                  shift and go to state 7
    operand3                       shift and go to state 33
    string_slice                   shift and go to state 3
    boolean_literal                shift and go to state 51
    array_location                 shift and go to state 46
    literal                        shift and go to state 37
    operand0                       shift and go to state 38
    primitive_value                shift and go to state 39
    array_slice                    shift and go to state 15
    character_literal              shift and go to state 41
    value_array_slice              shift and go to state 42
    operand4                       shift and go to state 54
    string_element                 shift and go to state 1
    lower_bound                    shift and go to state 136
    character_string_literal       shift and go to state 43
    dereferenced_reference         shift and go to state 20
    identifier                     shift and go to state 56
=======
    (11) synonym_list -> synonym_definition COMMA synonym_list .

    SEMI            reduce using rule 11 (synonym_list -> synonym_definition COMMA synonym_list .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


<<<<<<< HEAD
    (95) arithmetic_multiplicative_operator -> MODULO .

    MINUS           reduce using rule 95 (arithmetic_multiplicative_operator -> MODULO .)
    NOT             reduce using rule 95 (arithmetic_multiplicative_operator -> MODULO .)
    ARROW           reduce using rule 95 (arithmetic_multiplicative_operator -> MODULO .)
    LPAREN          reduce using rule 95 (arithmetic_multiplicative_operator -> MODULO .)
    ID              reduce using rule 95 (arithmetic_multiplicative_operator -> MODULO .)
    ICONST          reduce using rule 95 (arithmetic_multiplicative_operator -> MODULO .)
    TRUE            reduce using rule 95 (arithmetic_multiplicative_operator -> MODULO .)
    FALSE           reduce using rule 95 (arithmetic_multiplicative_operator -> MODULO .)
    CCONST          reduce using rule 95 (arithmetic_multiplicative_operator -> MODULO .)
    NULL            reduce using rule 95 (arithmetic_multiplicative_operator -> MODULO .)
    SCONST          reduce using rule 95 (arithmetic_multiplicative_operator -> MODULO .)
    ASSIGN          reduce using rule 95 (arithmetic_multiplicative_operator -> MODULO .)
=======
state 72
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

    (106) referenced_location -> ARROW . array_location
    (81) array_location -> . location
    (65) location -> . identifier
    (66) location -> . dereferenced_reference
    (67) location -> . string_element
    (68) location -> . string_slice
    (69) location -> . array_element
    (70) location -> . array_slice
    (22) identifier -> . ID
    (71) dereferenced_reference -> . array_location ARROW
    (72) string_element -> . identifier LBRACKET start_element LBRACKET
    (74) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (77) array_element -> . array_location LBRACKET expression_list RBRACKET
    (80) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET

    ID              shift and go to state 15

    location                       shift and go to state 82
    identifier                     shift and go to state 84
    array_slice                    shift and go to state 83
    array_location                 shift and go to state 122
    dereferenced_reference         shift and go to state 75
    string_slice                   shift and go to state 98
    string_element                 shift and go to state 81
    array_element                  shift and go to state 92

state 73

<<<<<<< HEAD
    (93) arithmetic_multiplicative_operator -> TIMES .

    MINUS           reduce using rule 93 (arithmetic_multiplicative_operator -> TIMES .)
    NOT             reduce using rule 93 (arithmetic_multiplicative_operator -> TIMES .)
    ARROW           reduce using rule 93 (arithmetic_multiplicative_operator -> TIMES .)
    LPAREN          reduce using rule 93 (arithmetic_multiplicative_operator -> TIMES .)
    ID              reduce using rule 93 (arithmetic_multiplicative_operator -> TIMES .)
    ICONST          reduce using rule 93 (arithmetic_multiplicative_operator -> TIMES .)
    TRUE            reduce using rule 93 (arithmetic_multiplicative_operator -> TIMES .)
    FALSE           reduce using rule 93 (arithmetic_multiplicative_operator -> TIMES .)
    CCONST          reduce using rule 93 (arithmetic_multiplicative_operator -> TIMES .)
    NULL            reduce using rule 93 (arithmetic_multiplicative_operator -> TIMES .)
    SCONST          reduce using rule 93 (arithmetic_multiplicative_operator -> TIMES .)
    ASSIGN          reduce using rule 93 (arithmetic_multiplicative_operator -> TIMES .)
=======
    (98) operand4 -> array_location .
    (71) dereferenced_reference -> array_location . ARROW
    (77) array_element -> array_location . LBRACKET expression_list RBRACKET
    (80) array_slice -> array_location . LBRACKET lower_bound COLON upper_bound RBRACKET

  ! shift/reduce conflict for LBRACKET resolved as shift
    TIMES           reduce using rule 98 (operand4 -> array_location .)
    DIVIDE          reduce using rule 98 (operand4 -> array_location .)
    MODULO          reduce using rule 98 (operand4 -> array_location .)
    PLUS            reduce using rule 98 (operand4 -> array_location .)
    MINUS           reduce using rule 98 (operand4 -> array_location .)
    CONCAT          reduce using rule 98 (operand4 -> array_location .)
    AND             reduce using rule 98 (operand4 -> array_location .)
    OR              reduce using rule 98 (operand4 -> array_location .)
    EQUAL           reduce using rule 98 (operand4 -> array_location .)
    NOTEQ           reduce using rule 98 (operand4 -> array_location .)
    GREATER         reduce using rule 98 (operand4 -> array_location .)
    GTEQUAL         reduce using rule 98 (operand4 -> array_location .)
    LESS            reduce using rule 98 (operand4 -> array_location .)
    LTEQUAL         reduce using rule 98 (operand4 -> array_location .)
    IN              reduce using rule 98 (operand4 -> array_location .)
    COMMA           reduce using rule 98 (operand4 -> array_location .)
    SEMI            reduce using rule 98 (operand4 -> array_location .)
    COLON           reduce using rule 98 (operand4 -> array_location .)
    THEN            reduce using rule 98 (operand4 -> array_location .)
    RBRACKET        reduce using rule 98 (operand4 -> array_location .)
    RPAREN          reduce using rule 98 (operand4 -> array_location .)
    ELSE            reduce using rule 98 (operand4 -> array_location .)
    ELSIF           reduce using rule 98 (operand4 -> array_location .)
    FI              reduce using rule 98 (operand4 -> array_location .)
    ARROW           shift and go to state 123
    LBRACKET        shift and go to state 124

  ! LBRACKET        [ reduce using rule 98 (operand4 -> array_location .) ]
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 74

<<<<<<< HEAD
    (104) arithmetic_additive_operator -> MINUS .

    ASSIGN          reduce using rule 104 (arithmetic_additive_operator -> MINUS .)
    MINUS           reduce using rule 104 (arithmetic_additive_operator -> MINUS .)
    NOT             reduce using rule 104 (arithmetic_additive_operator -> MINUS .)
    ARROW           reduce using rule 104 (arithmetic_additive_operator -> MINUS .)
    LPAREN          reduce using rule 104 (arithmetic_additive_operator -> MINUS .)
    ID              reduce using rule 104 (arithmetic_additive_operator -> MINUS .)
    ICONST          reduce using rule 104 (arithmetic_additive_operator -> MINUS .)
    TRUE            reduce using rule 104 (arithmetic_additive_operator -> MINUS .)
    FALSE           reduce using rule 104 (arithmetic_additive_operator -> MINUS .)
    CCONST          reduce using rule 104 (arithmetic_additive_operator -> MINUS .)
    NULL            reduce using rule 104 (arithmetic_additive_operator -> MINUS .)
    SCONST          reduce using rule 104 (arithmetic_additive_operator -> MINUS .)
=======
    (123) primitive_value -> literal .

    TIMES           reduce using rule 123 (primitive_value -> literal .)
    DIVIDE          reduce using rule 123 (primitive_value -> literal .)
    MODULO          reduce using rule 123 (primitive_value -> literal .)
    PLUS            reduce using rule 123 (primitive_value -> literal .)
    MINUS           reduce using rule 123 (primitive_value -> literal .)
    CONCAT          reduce using rule 123 (primitive_value -> literal .)
    AND             reduce using rule 123 (primitive_value -> literal .)
    OR              reduce using rule 123 (primitive_value -> literal .)
    EQUAL           reduce using rule 123 (primitive_value -> literal .)
    NOTEQ           reduce using rule 123 (primitive_value -> literal .)
    GREATER         reduce using rule 123 (primitive_value -> literal .)
    GTEQUAL         reduce using rule 123 (primitive_value -> literal .)
    LESS            reduce using rule 123 (primitive_value -> literal .)
    LTEQUAL         reduce using rule 123 (primitive_value -> literal .)
    IN              reduce using rule 123 (primitive_value -> literal .)
    COMMA           reduce using rule 123 (primitive_value -> literal .)
    SEMI            reduce using rule 123 (primitive_value -> literal .)
    THEN            reduce using rule 123 (primitive_value -> literal .)
    COLON           reduce using rule 123 (primitive_value -> literal .)
    RBRACKET        reduce using rule 123 (primitive_value -> literal .)
    LBRACKET        reduce using rule 123 (primitive_value -> literal .)
    RPAREN          reduce using rule 123 (primitive_value -> literal .)
    ELSE            reduce using rule 123 (primitive_value -> literal .)
    ELSIF           reduce using rule 123 (primitive_value -> literal .)
    FI              reduce using rule 123 (primitive_value -> literal .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 75

<<<<<<< HEAD
    (23) newmode_statement -> TYPE newmode_list . SEMI

    SEMI            shift and go to state 137
=======
    (66) location -> dereferenced_reference .

    ARROW           reduce using rule 66 (location -> dereferenced_reference .)
    LBRACKET        reduce using rule 66 (location -> dereferenced_reference .)
    TIMES           reduce using rule 66 (location -> dereferenced_reference .)
    DIVIDE          reduce using rule 66 (location -> dereferenced_reference .)
    MODULO          reduce using rule 66 (location -> dereferenced_reference .)
    PLUS            reduce using rule 66 (location -> dereferenced_reference .)
    MINUS           reduce using rule 66 (location -> dereferenced_reference .)
    CONCAT          reduce using rule 66 (location -> dereferenced_reference .)
    AND             reduce using rule 66 (location -> dereferenced_reference .)
    OR              reduce using rule 66 (location -> dereferenced_reference .)
    EQUAL           reduce using rule 66 (location -> dereferenced_reference .)
    NOTEQ           reduce using rule 66 (location -> dereferenced_reference .)
    GREATER         reduce using rule 66 (location -> dereferenced_reference .)
    GTEQUAL         reduce using rule 66 (location -> dereferenced_reference .)
    LESS            reduce using rule 66 (location -> dereferenced_reference .)
    LTEQUAL         reduce using rule 66 (location -> dereferenced_reference .)
    IN              reduce using rule 66 (location -> dereferenced_reference .)
    COMMA           reduce using rule 66 (location -> dereferenced_reference .)
    RBRACKET        reduce using rule 66 (location -> dereferenced_reference .)
    COLON           reduce using rule 66 (location -> dereferenced_reference .)
    SEMI            reduce using rule 66 (location -> dereferenced_reference .)
    THEN            reduce using rule 66 (location -> dereferenced_reference .)
    RPAREN          reduce using rule 66 (location -> dereferenced_reference .)
    ELSE            reduce using rule 66 (location -> dereferenced_reference .)
    ELSIF           reduce using rule 66 (location -> dereferenced_reference .)
    FI              reduce using rule 66 (location -> dereferenced_reference .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 76

<<<<<<< HEAD
    (24) newmode_list -> mode_definition .
    (25) newmode_list -> mode_definition . COMMA newmode_list

    SEMI            reduce using rule 24 (newmode_list -> mode_definition .)
    COMMA           shift and go to state 138
=======
    (94) operand2 -> operand3 .

    TIMES           reduce using rule 94 (operand2 -> operand3 .)
    DIVIDE          reduce using rule 94 (operand2 -> operand3 .)
    MODULO          reduce using rule 94 (operand2 -> operand3 .)
    PLUS            reduce using rule 94 (operand2 -> operand3 .)
    MINUS           reduce using rule 94 (operand2 -> operand3 .)
    CONCAT          reduce using rule 94 (operand2 -> operand3 .)
    AND             reduce using rule 94 (operand2 -> operand3 .)
    OR              reduce using rule 94 (operand2 -> operand3 .)
    EQUAL           reduce using rule 94 (operand2 -> operand3 .)
    NOTEQ           reduce using rule 94 (operand2 -> operand3 .)
    GREATER         reduce using rule 94 (operand2 -> operand3 .)
    GTEQUAL         reduce using rule 94 (operand2 -> operand3 .)
    LESS            reduce using rule 94 (operand2 -> operand3 .)
    LTEQUAL         reduce using rule 94 (operand2 -> operand3 .)
    IN              reduce using rule 94 (operand2 -> operand3 .)
    RBRACKET        reduce using rule 94 (operand2 -> operand3 .)
    ELSE            reduce using rule 94 (operand2 -> operand3 .)
    ELSIF           reduce using rule 94 (operand2 -> operand3 .)
    COMMA           reduce using rule 94 (operand2 -> operand3 .)
    SEMI            reduce using rule 94 (operand2 -> operand3 .)
    COLON           reduce using rule 94 (operand2 -> operand3 .)
    THEN            reduce using rule 94 (operand2 -> operand3 .)
    LBRACKET        reduce using rule 94 (operand2 -> operand3 .)
    RPAREN          reduce using rule 94 (operand2 -> operand3 .)
    FI              reduce using rule 94 (operand2 -> operand3 .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 77

<<<<<<< HEAD
    (26) mode_definition -> identifier_list . ASSIGN mode

    ASSIGN          shift and go to state 139
=======
    (124) literal -> integer_literal .

    TIMES           reduce using rule 124 (literal -> integer_literal .)
    DIVIDE          reduce using rule 124 (literal -> integer_literal .)
    MODULO          reduce using rule 124 (literal -> integer_literal .)
    PLUS            reduce using rule 124 (literal -> integer_literal .)
    MINUS           reduce using rule 124 (literal -> integer_literal .)
    CONCAT          reduce using rule 124 (literal -> integer_literal .)
    AND             reduce using rule 124 (literal -> integer_literal .)
    OR              reduce using rule 124 (literal -> integer_literal .)
    EQUAL           reduce using rule 124 (literal -> integer_literal .)
    NOTEQ           reduce using rule 124 (literal -> integer_literal .)
    GREATER         reduce using rule 124 (literal -> integer_literal .)
    GTEQUAL         reduce using rule 124 (literal -> integer_literal .)
    LESS            reduce using rule 124 (literal -> integer_literal .)
    LTEQUAL         reduce using rule 124 (literal -> integer_literal .)
    IN              reduce using rule 124 (literal -> integer_literal .)
    RBRACKET        reduce using rule 124 (literal -> integer_literal .)
    THEN            reduce using rule 124 (literal -> integer_literal .)
    RPAREN          reduce using rule 124 (literal -> integer_literal .)
    COMMA           reduce using rule 124 (literal -> integer_literal .)
    COLON           reduce using rule 124 (literal -> integer_literal .)
    FI              reduce using rule 124 (literal -> integer_literal .)
    SEMI            reduce using rule 124 (literal -> integer_literal .)
    LBRACKET        reduce using rule 124 (literal -> integer_literal .)
    ELSE            reduce using rule 124 (literal -> integer_literal .)
    ELSIF           reduce using rule 124 (literal -> integer_literal .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 78

<<<<<<< HEAD
    (15) declaration_list -> declaration .
    (16) declaration_list -> declaration . COMMA declaration_list

    SEMI            reduce using rule 15 (declaration_list -> declaration .)
    COMMA           shift and go to state 140
=======
    (100) operand4 -> primitive_value .

    TIMES           reduce using rule 100 (operand4 -> primitive_value .)
    DIVIDE          reduce using rule 100 (operand4 -> primitive_value .)
    MODULO          reduce using rule 100 (operand4 -> primitive_value .)
    PLUS            reduce using rule 100 (operand4 -> primitive_value .)
    MINUS           reduce using rule 100 (operand4 -> primitive_value .)
    CONCAT          reduce using rule 100 (operand4 -> primitive_value .)
    AND             reduce using rule 100 (operand4 -> primitive_value .)
    OR              reduce using rule 100 (operand4 -> primitive_value .)
    EQUAL           reduce using rule 100 (operand4 -> primitive_value .)
    NOTEQ           reduce using rule 100 (operand4 -> primitive_value .)
    GREATER         reduce using rule 100 (operand4 -> primitive_value .)
    GTEQUAL         reduce using rule 100 (operand4 -> primitive_value .)
    LESS            reduce using rule 100 (operand4 -> primitive_value .)
    LTEQUAL         reduce using rule 100 (operand4 -> primitive_value .)
    IN              reduce using rule 100 (operand4 -> primitive_value .)
    COMMA           reduce using rule 100 (operand4 -> primitive_value .)
    SEMI            reduce using rule 100 (operand4 -> primitive_value .)
    LBRACKET        reduce using rule 100 (operand4 -> primitive_value .)
    COLON           reduce using rule 100 (operand4 -> primitive_value .)
    THEN            reduce using rule 100 (operand4 -> primitive_value .)
    RBRACKET        reduce using rule 100 (operand4 -> primitive_value .)
    RPAREN          reduce using rule 100 (operand4 -> primitive_value .)
    ELSE            reduce using rule 100 (operand4 -> primitive_value .)
    ELSIF           reduce using rule 100 (operand4 -> primitive_value .)
    FI              reduce using rule 100 (operand4 -> primitive_value .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 79

<<<<<<< HEAD
    (14) declaration_statement -> DCL declaration_list . SEMI
=======
    (99) operand4 -> referenced_location .

    TIMES           reduce using rule 99 (operand4 -> referenced_location .)
    DIVIDE          reduce using rule 99 (operand4 -> referenced_location .)
    MODULO          reduce using rule 99 (operand4 -> referenced_location .)
    PLUS            reduce using rule 99 (operand4 -> referenced_location .)
    MINUS           reduce using rule 99 (operand4 -> referenced_location .)
    CONCAT          reduce using rule 99 (operand4 -> referenced_location .)
    AND             reduce using rule 99 (operand4 -> referenced_location .)
    OR              reduce using rule 99 (operand4 -> referenced_location .)
    EQUAL           reduce using rule 99 (operand4 -> referenced_location .)
    NOTEQ           reduce using rule 99 (operand4 -> referenced_location .)
    GREATER         reduce using rule 99 (operand4 -> referenced_location .)
    GTEQUAL         reduce using rule 99 (operand4 -> referenced_location .)
    LESS            reduce using rule 99 (operand4 -> referenced_location .)
    LTEQUAL         reduce using rule 99 (operand4 -> referenced_location .)
    IN              reduce using rule 99 (operand4 -> referenced_location .)
    COMMA           reduce using rule 99 (operand4 -> referenced_location .)
    SEMI            reduce using rule 99 (operand4 -> referenced_location .)
    LBRACKET        reduce using rule 99 (operand4 -> referenced_location .)
    COLON           reduce using rule 99 (operand4 -> referenced_location .)
    THEN            reduce using rule 99 (operand4 -> referenced_location .)
    RBRACKET        reduce using rule 99 (operand4 -> referenced_location .)
    RPAREN          reduce using rule 99 (operand4 -> referenced_location .)
    ELSE            reduce using rule 99 (operand4 -> referenced_location .)
    ELSIF           reduce using rule 99 (operand4 -> referenced_location .)
    FI              reduce using rule 99 (operand4 -> referenced_location .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

    SEMI            shift and go to state 141


<<<<<<< HEAD
state 80
=======
    (131) boolean_literal -> FALSE .

    TIMES           reduce using rule 131 (boolean_literal -> FALSE .)
    DIVIDE          reduce using rule 131 (boolean_literal -> FALSE .)
    MODULO          reduce using rule 131 (boolean_literal -> FALSE .)
    PLUS            reduce using rule 131 (boolean_literal -> FALSE .)
    MINUS           reduce using rule 131 (boolean_literal -> FALSE .)
    CONCAT          reduce using rule 131 (boolean_literal -> FALSE .)
    AND             reduce using rule 131 (boolean_literal -> FALSE .)
    OR              reduce using rule 131 (boolean_literal -> FALSE .)
    EQUAL           reduce using rule 131 (boolean_literal -> FALSE .)
    NOTEQ           reduce using rule 131 (boolean_literal -> FALSE .)
    GREATER         reduce using rule 131 (boolean_literal -> FALSE .)
    GTEQUAL         reduce using rule 131 (boolean_literal -> FALSE .)
    LESS            reduce using rule 131 (boolean_literal -> FALSE .)
    LTEQUAL         reduce using rule 131 (boolean_literal -> FALSE .)
    IN              reduce using rule 131 (boolean_literal -> FALSE .)
    RBRACKET        reduce using rule 131 (boolean_literal -> FALSE .)
    COMMA           reduce using rule 131 (boolean_literal -> FALSE .)
    SEMI            reduce using rule 131 (boolean_literal -> FALSE .)
    COLON           reduce using rule 131 (boolean_literal -> FALSE .)
    THEN            reduce using rule 131 (boolean_literal -> FALSE .)
    LBRACKET        reduce using rule 131 (boolean_literal -> FALSE .)
    RPAREN          reduce using rule 131 (boolean_literal -> FALSE .)
    ELSE            reduce using rule 131 (boolean_literal -> FALSE .)
    ELSIF           reduce using rule 131 (boolean_literal -> FALSE .)
    FI              reduce using rule 131 (boolean_literal -> FALSE .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

    (17) declaration -> identifier_list . mode initialization
    (18) declaration -> identifier_list . mode
    (27) mode -> . mode_name
    (28) mode -> . discrete_mode
    (29) mode -> . reference_mode
    (30) mode -> . composite_mode
    (31) mode_name -> . identifier
    (32) discrete_mode -> . integer_mode
    (33) discrete_mode -> . boolean_mode
    (34) discrete_mode -> . character_mode
    (35) discrete_mode -> . discrete_range_mode
    (45) reference_mode -> . REF mode
    (46) composite_mode -> . string_mode
    (47) composite_mode -> . array_mode
    (22) identifier -> . ID
    (37) integer_mode -> . INT
    (38) boolean_mode -> . BOOL
    (39) character_mode -> . CHAR
    (40) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (41) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (48) string_mode -> . CHARS LBRACKET string_length RBRACKET
    (50) array_mode -> . ARRAY LBRACKET index_mode_list RBRACKET element_mode
    (36) discrete_mode_name -> . identifier

    REF             shift and go to state 118
    ID              shift and go to state 21
    INT             shift and go to state 119
    BOOL            shift and go to state 130
    CHAR            shift and go to state 112
    CHARS           shift and go to state 125
    ARRAY           shift and go to state 121

    string_mode                    shift and go to state 111
    mode                           shift and go to state 142
    reference_mode                 shift and go to state 114
    boolean_mode                   shift and go to state 122
    composite_mode                 shift and go to state 123
    integer_mode                   shift and go to state 117
    character_mode                 shift and go to state 124
    mode_name                      shift and go to state 120
    array_mode                     shift and go to state 115
    discrete_range_mode            shift and go to state 127
    discrete_mode                  shift and go to state 128
    discrete_mode_name             shift and go to state 116
    identifier                     shift and go to state 129

state 81

<<<<<<< HEAD
    (2) statement_list -> statement statement_nullable .

    $end            reduce using rule 2 (statement_list -> statement statement_nullable .)
=======
    (67) location -> string_element .

    ARROW           reduce using rule 67 (location -> string_element .)
    LBRACKET        reduce using rule 67 (location -> string_element .)
    TIMES           reduce using rule 67 (location -> string_element .)
    DIVIDE          reduce using rule 67 (location -> string_element .)
    MODULO          reduce using rule 67 (location -> string_element .)
    PLUS            reduce using rule 67 (location -> string_element .)
    MINUS           reduce using rule 67 (location -> string_element .)
    CONCAT          reduce using rule 67 (location -> string_element .)
    AND             reduce using rule 67 (location -> string_element .)
    OR              reduce using rule 67 (location -> string_element .)
    EQUAL           reduce using rule 67 (location -> string_element .)
    NOTEQ           reduce using rule 67 (location -> string_element .)
    GREATER         reduce using rule 67 (location -> string_element .)
    GTEQUAL         reduce using rule 67 (location -> string_element .)
    LESS            reduce using rule 67 (location -> string_element .)
    LTEQUAL         reduce using rule 67 (location -> string_element .)
    IN              reduce using rule 67 (location -> string_element .)
    COMMA           reduce using rule 67 (location -> string_element .)
    RBRACKET        reduce using rule 67 (location -> string_element .)
    COLON           reduce using rule 67 (location -> string_element .)
    SEMI            reduce using rule 67 (location -> string_element .)
    THEN            reduce using rule 67 (location -> string_element .)
    RPAREN          reduce using rule 67 (location -> string_element .)
    ELSE            reduce using rule 67 (location -> string_element .)
    ELSIF           reduce using rule 67 (location -> string_element .)
    FI              reduce using rule 67 (location -> string_element .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 82

<<<<<<< HEAD
    (4) statement_nullable -> empty .
=======
    (81) array_location -> location .

    ARROW           reduce using rule 81 (array_location -> location .)
    LBRACKET        reduce using rule 81 (array_location -> location .)
    TIMES           reduce using rule 81 (array_location -> location .)
    DIVIDE          reduce using rule 81 (array_location -> location .)
    MODULO          reduce using rule 81 (array_location -> location .)
    PLUS            reduce using rule 81 (array_location -> location .)
    MINUS           reduce using rule 81 (array_location -> location .)
    CONCAT          reduce using rule 81 (array_location -> location .)
    AND             reduce using rule 81 (array_location -> location .)
    OR              reduce using rule 81 (array_location -> location .)
    EQUAL           reduce using rule 81 (array_location -> location .)
    NOTEQ           reduce using rule 81 (array_location -> location .)
    GREATER         reduce using rule 81 (array_location -> location .)
    GTEQUAL         reduce using rule 81 (array_location -> location .)
    LESS            reduce using rule 81 (array_location -> location .)
    LTEQUAL         reduce using rule 81 (array_location -> location .)
    IN              reduce using rule 81 (array_location -> location .)
    RBRACKET        reduce using rule 81 (array_location -> location .)
    COMMA           reduce using rule 81 (array_location -> location .)
    SEMI            reduce using rule 81 (array_location -> location .)
    COLON           reduce using rule 81 (array_location -> location .)
    THEN            reduce using rule 81 (array_location -> location .)
    RPAREN          reduce using rule 81 (array_location -> location .)
    ELSE            reduce using rule 81 (array_location -> location .)
    ELSIF           reduce using rule 81 (array_location -> location .)
    FI              reduce using rule 81 (array_location -> location .)

>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

    $end            reduce using rule 4 (statement_nullable -> empty .)

<<<<<<< HEAD
=======
    (70) location -> array_slice .

    ARROW           reduce using rule 70 (location -> array_slice .)
    LBRACKET        reduce using rule 70 (location -> array_slice .)
    TIMES           reduce using rule 70 (location -> array_slice .)
    DIVIDE          reduce using rule 70 (location -> array_slice .)
    MODULO          reduce using rule 70 (location -> array_slice .)
    PLUS            reduce using rule 70 (location -> array_slice .)
    MINUS           reduce using rule 70 (location -> array_slice .)
    CONCAT          reduce using rule 70 (location -> array_slice .)
    AND             reduce using rule 70 (location -> array_slice .)
    OR              reduce using rule 70 (location -> array_slice .)
    EQUAL           reduce using rule 70 (location -> array_slice .)
    NOTEQ           reduce using rule 70 (location -> array_slice .)
    GREATER         reduce using rule 70 (location -> array_slice .)
    GTEQUAL         reduce using rule 70 (location -> array_slice .)
    LESS            reduce using rule 70 (location -> array_slice .)
    LTEQUAL         reduce using rule 70 (location -> array_slice .)
    IN              reduce using rule 70 (location -> array_slice .)
    COMMA           reduce using rule 70 (location -> array_slice .)
    RBRACKET        reduce using rule 70 (location -> array_slice .)
    COLON           reduce using rule 70 (location -> array_slice .)
    SEMI            reduce using rule 70 (location -> array_slice .)
    THEN            reduce using rule 70 (location -> array_slice .)
    RPAREN          reduce using rule 70 (location -> array_slice .)
    ELSE            reduce using rule 70 (location -> array_slice .)
    ELSIF           reduce using rule 70 (location -> array_slice .)
    FI              reduce using rule 70 (location -> array_slice .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

state 83

    (3) statement_nullable -> statement . statement_nullable
    (3) statement_nullable -> . statement statement_nullable
    (4) statement_nullable -> . empty
    (5) statement -> . declaration_statement
    (6) statement -> . synonym_statement
    (7) statement -> . newmode_statement
    (8) statement -> . action_statement
    (152) empty -> .
    (14) declaration_statement -> . DCL declaration_list SEMI
    (9) synonym_statement -> . SYN synonym_list SEMI
    (23) newmode_statement -> . TYPE newmode_list SEMI
    (132) action_statement -> . identifier COLON action
    (133) action_statement -> . action
    (22) identifier -> . ID
    (134) action -> . bracketed_action
    (135) action -> . assignment_action
    (136) bracketed_action -> . if_action
    (137) assignment_action -> . array_location assigning_operator expression
    (143) if_action -> . IF expression then_clause else_clause FI
    (144) if_action -> . IF expression then_clause
    (72) array_location -> . location
    (56) location -> . identifier
    (57) location -> . dereferenced_reference
    (58) location -> . string_element
    (59) location -> . string_slice
    (60) location -> . array_element
    (61) location -> . array_slice
    (62) dereferenced_reference -> . array_location ARROW
    (63) string_element -> . identifier LBRACKET start_element LBRACKET
    (65) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (68) array_element -> . array_location LBRACKET expression_list RBRACKET
    (71) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET

    $end            reduce using rule 152 (empty -> .)
    DCL             shift and go to state 16
    SYN             shift and go to state 9
    TYPE            shift and go to state 14
    ID              shift and go to state 21
    IF              shift and go to state 4

    location                       shift and go to state 6
    string_element                 shift and go to state 1
    action_statement               shift and go to state 2
    string_slice                   shift and go to state 3
    array_slice                    shift and go to state 15
    statement_nullable             shift and go to state 143
    empty                          shift and go to state 82
    if_action                      shift and go to state 17
    bracketed_action               shift and go to state 22
    statement                      shift and go to state 83
    array_location                 shift and go to state 13
    array_element                  shift and go to state 7
    action                         shift and go to state 8
    newmode_statement              shift and go to state 5
    declaration_statement          shift and go to state 10
    assignment_action              shift and go to state 11
    synonym_statement              shift and go to state 12
    dereferenced_reference         shift and go to state 20
    identifier                     shift and go to state 24

<<<<<<< HEAD
state 84

    (132) action_statement -> identifier COLON . action
    (134) action -> . bracketed_action
    (135) action -> . assignment_action
    (136) bracketed_action -> . if_action
    (137) assignment_action -> . array_location assigning_operator expression
    (143) if_action -> . IF expression then_clause else_clause FI
    (144) if_action -> . IF expression then_clause
    (72) array_location -> . location
    (56) location -> . identifier
    (57) location -> . dereferenced_reference
    (58) location -> . string_element
    (59) location -> . string_slice
    (60) location -> . array_element
    (61) location -> . array_slice
    (22) identifier -> . ID
    (62) dereferenced_reference -> . array_location ARROW
    (63) string_element -> . identifier LBRACKET start_element LBRACKET
    (65) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (68) array_element -> . array_location LBRACKET expression_list RBRACKET
    (71) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET

    IF              shift and go to state 4
    ID              shift and go to state 21

    location                       shift and go to state 6
    string_element                 shift and go to state 1
    string_slice                   shift and go to state 3
    array_slice                    shift and go to state 15
    assignment_action              shift and go to state 11
    if_action                      shift and go to state 17
    array_location                 shift and go to state 13
    array_element                  shift and go to state 7
    action                         shift and go to state 144
    bracketed_action               shift and go to state 22
    dereferenced_reference         shift and go to state 20
    identifier                     shift and go to state 56
=======
    (65) location -> identifier .
    (72) string_element -> identifier . LBRACKET start_element LBRACKET
    (74) string_slice -> identifier . LBRACKET left_element COLON right_element RBRACKET
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

  ! shift/reduce conflict for LBRACKET resolved as shift
    ARROW           reduce using rule 65 (location -> identifier .)
    TIMES           reduce using rule 65 (location -> identifier .)
    DIVIDE          reduce using rule 65 (location -> identifier .)
    MODULO          reduce using rule 65 (location -> identifier .)
    PLUS            reduce using rule 65 (location -> identifier .)
    MINUS           reduce using rule 65 (location -> identifier .)
    CONCAT          reduce using rule 65 (location -> identifier .)
    AND             reduce using rule 65 (location -> identifier .)
    OR              reduce using rule 65 (location -> identifier .)
    EQUAL           reduce using rule 65 (location -> identifier .)
    NOTEQ           reduce using rule 65 (location -> identifier .)
    GREATER         reduce using rule 65 (location -> identifier .)
    GTEQUAL         reduce using rule 65 (location -> identifier .)
    LESS            reduce using rule 65 (location -> identifier .)
    LTEQUAL         reduce using rule 65 (location -> identifier .)
    IN              reduce using rule 65 (location -> identifier .)
    COMMA           reduce using rule 65 (location -> identifier .)
    RBRACKET        reduce using rule 65 (location -> identifier .)
    COLON           reduce using rule 65 (location -> identifier .)
    SEMI            reduce using rule 65 (location -> identifier .)
    THEN            reduce using rule 65 (location -> identifier .)
    RPAREN          reduce using rule 65 (location -> identifier .)
    ELSE            reduce using rule 65 (location -> identifier .)
    ELSIF           reduce using rule 65 (location -> identifier .)
    FI              reduce using rule 65 (location -> identifier .)
    LBRACKET        shift and go to state 125

  ! LBRACKET        [ reduce using rule 65 (location -> identifier .) ]

<<<<<<< HEAD
    (63) string_element -> identifier LBRACKET . start_element LBRACKET
    (65) string_slice -> identifier LBRACKET . left_element COLON right_element RBRACKET
    (64) start_element -> . expression
    (66) left_element -> . expression
    (73) expression -> . operand0
    (74) expression -> . conditional_expression
    (82) operand0 -> . operand1
    (83) operand0 -> . operand0 operator1 operand1
    (76) conditional_expression -> . IF expression then_expression else_expression FI
    (77) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (84) operand1 -> . operand2
    (85) operand1 -> . operand1 operator2 operand2
    (86) operand2 -> . operand3
    (87) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (88) operand3 -> . monadic_operator operand4
    (89) operand3 -> . operand4
    (96) monadic_operator -> . MINUS
    (97) monadic_operator -> . NOT
    (90) operand4 -> . array_location
    (91) operand4 -> . referenced_location
    (92) operand4 -> . primitive_value
    (72) array_location -> . location
    (98) referenced_location -> . ARROW array_location
    (115) primitive_value -> . literal
    (116) primitive_value -> . value_array_element
    (117) primitive_value -> . value_array_slice
    (118) primitive_value -> . parenthesized_expression
    (56) location -> . identifier
    (57) location -> . dereferenced_reference
    (58) location -> . string_element
    (59) location -> . string_slice
    (60) location -> . array_element
    (61) location -> . array_slice
    (119) literal -> . integer_literal
    (120) literal -> . boolean_literal
    (121) literal -> . character_literal
    (122) literal -> . empty_literal
    (123) literal -> . character_string_literal
    (124) value_array_element -> . primitive_value LBRACKET expression_list RBRACKET
    (125) value_array_slice -> . primitive_value LBRACKET expression COLON expression RBRACKET
    (75) parenthesized_expression -> . LPAREN expression RPAREN
    (22) identifier -> . ID
    (62) dereferenced_reference -> . array_location ARROW
    (63) string_element -> . identifier LBRACKET start_element LBRACKET
    (65) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (68) array_element -> . array_location LBRACKET expression_list RBRACKET
    (71) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (126) integer_literal -> . ICONST
    (127) boolean_literal -> . TRUE
    (128) boolean_literal -> . FALSE
    (129) character_literal -> . CCONST
    (130) empty_literal -> . NULL
    (131) character_string_literal -> . SCONST

    IF              shift and go to state 31
    MINUS           shift and go to state 36
    NOT             shift and go to state 35
    ARROW           shift and go to state 45
    LPAREN          shift and go to state 44
    ID              shift and go to state 21
    ICONST          shift and go to state 40
    TRUE            shift and go to state 55
    FALSE           shift and go to state 53
    CCONST          shift and go to state 34
    NULL            shift and go to state 27
    SCONST          shift and go to state 52

    location                       shift and go to state 6
    monadic_operator               shift and go to state 47
    conditional_expression         shift and go to state 28
    value_array_element            shift and go to state 48
    operand1                       shift and go to state 25
    expression                     shift and go to state 145
    operand2                       shift and go to state 49
    referenced_location            shift and go to state 29
    parenthesized_expression       shift and go to state 30
    array_slice                    shift and go to state 15
    integer_literal                shift and go to state 32
    empty_literal                  shift and go to state 50
    array_element                  shift and go to state 7
    operand3                       shift and go to state 33
    string_slice                   shift and go to state 3
    string_element                 shift and go to state 1
    boolean_literal                shift and go to state 51
    array_location                 shift and go to state 46
    literal                        shift and go to state 37
    operand0                       shift and go to state 38
    primitive_value                shift and go to state 39
    character_literal              shift and go to state 41
    value_array_slice              shift and go to state 42
    operand4                       shift and go to state 54
    left_element                   shift and go to state 146
    start_element                  shift and go to state 147
    character_string_literal       shift and go to state 43
    dereferenced_reference         shift and go to state 20
    identifier                     shift and go to state 56

state 86

    (101) operator2 -> arithmetic_additive_operator .

    MINUS           reduce using rule 101 (operator2 -> arithmetic_additive_operator .)
    NOT             reduce using rule 101 (operator2 -> arithmetic_additive_operator .)
    ARROW           reduce using rule 101 (operator2 -> arithmetic_additive_operator .)
    LPAREN          reduce using rule 101 (operator2 -> arithmetic_additive_operator .)
    ID              reduce using rule 101 (operator2 -> arithmetic_additive_operator .)
    ICONST          reduce using rule 101 (operator2 -> arithmetic_additive_operator .)
    TRUE            reduce using rule 101 (operator2 -> arithmetic_additive_operator .)
    FALSE           reduce using rule 101 (operator2 -> arithmetic_additive_operator .)
    CCONST          reduce using rule 101 (operator2 -> arithmetic_additive_operator .)
    NULL            reduce using rule 101 (operator2 -> arithmetic_additive_operator .)
    SCONST          reduce using rule 101 (operator2 -> arithmetic_additive_operator .)


state 87

    (102) operator2 -> string_concatenation_operator .
=======

state 85

    (126) literal -> character_literal .

    TIMES           reduce using rule 126 (literal -> character_literal .)
    DIVIDE          reduce using rule 126 (literal -> character_literal .)
    MODULO          reduce using rule 126 (literal -> character_literal .)
    PLUS            reduce using rule 126 (literal -> character_literal .)
    MINUS           reduce using rule 126 (literal -> character_literal .)
    CONCAT          reduce using rule 126 (literal -> character_literal .)
    AND             reduce using rule 126 (literal -> character_literal .)
    OR              reduce using rule 126 (literal -> character_literal .)
    EQUAL           reduce using rule 126 (literal -> character_literal .)
    NOTEQ           reduce using rule 126 (literal -> character_literal .)
    GREATER         reduce using rule 126 (literal -> character_literal .)
    GTEQUAL         reduce using rule 126 (literal -> character_literal .)
    LESS            reduce using rule 126 (literal -> character_literal .)
    LTEQUAL         reduce using rule 126 (literal -> character_literal .)
    IN              reduce using rule 126 (literal -> character_literal .)
    RBRACKET        reduce using rule 126 (literal -> character_literal .)
    THEN            reduce using rule 126 (literal -> character_literal .)
    RPAREN          reduce using rule 126 (literal -> character_literal .)
    COMMA           reduce using rule 126 (literal -> character_literal .)
    COLON           reduce using rule 126 (literal -> character_literal .)
    FI              reduce using rule 126 (literal -> character_literal .)
    SEMI            reduce using rule 126 (literal -> character_literal .)
    LBRACKET        reduce using rule 126 (literal -> character_literal .)
    ELSE            reduce using rule 126 (literal -> character_literal .)
    ELSIF           reduce using rule 126 (literal -> character_literal .)


state 86

    (90) operand0 -> operand1 .
    (93) operand1 -> operand1 . operator2 operand2
    (109) operator2 -> . arithmetic_additive_operator
    (110) operator2 -> . string_concatenation_operator
    (111) arithmetic_additive_operator -> . PLUS
    (112) arithmetic_additive_operator -> . MINUS
    (113) string_concatenation_operator -> . CONCAT

    AND             reduce using rule 90 (operand0 -> operand1 .)
    OR              reduce using rule 90 (operand0 -> operand1 .)
    EQUAL           reduce using rule 90 (operand0 -> operand1 .)
    NOTEQ           reduce using rule 90 (operand0 -> operand1 .)
    GREATER         reduce using rule 90 (operand0 -> operand1 .)
    GTEQUAL         reduce using rule 90 (operand0 -> operand1 .)
    LESS            reduce using rule 90 (operand0 -> operand1 .)
    LTEQUAL         reduce using rule 90 (operand0 -> operand1 .)
    IN              reduce using rule 90 (operand0 -> operand1 .)
    LBRACKET        reduce using rule 90 (operand0 -> operand1 .)
    COLON           reduce using rule 90 (operand0 -> operand1 .)
    RBRACKET        reduce using rule 90 (operand0 -> operand1 .)
    RPAREN          reduce using rule 90 (operand0 -> operand1 .)
    COMMA           reduce using rule 90 (operand0 -> operand1 .)
    SEMI            reduce using rule 90 (operand0 -> operand1 .)
    THEN            reduce using rule 90 (operand0 -> operand1 .)
    FI              reduce using rule 90 (operand0 -> operand1 .)
    ELSE            reduce using rule 90 (operand0 -> operand1 .)
    ELSIF           reduce using rule 90 (operand0 -> operand1 .)
    PLUS            shift and go to state 126
    MINUS           shift and go to state 131
    CONCAT          shift and go to state 130

    string_concatenation_operator  shift and go to state 129
    arithmetic_additive_operator   shift and go to state 128
    operator2                      shift and go to state 127

state 87

    (130) boolean_literal -> TRUE .

    TIMES           reduce using rule 130 (boolean_literal -> TRUE .)
    DIVIDE          reduce using rule 130 (boolean_literal -> TRUE .)
    MODULO          reduce using rule 130 (boolean_literal -> TRUE .)
    PLUS            reduce using rule 130 (boolean_literal -> TRUE .)
    MINUS           reduce using rule 130 (boolean_literal -> TRUE .)
    CONCAT          reduce using rule 130 (boolean_literal -> TRUE .)
    AND             reduce using rule 130 (boolean_literal -> TRUE .)
    OR              reduce using rule 130 (boolean_literal -> TRUE .)
    EQUAL           reduce using rule 130 (boolean_literal -> TRUE .)
    NOTEQ           reduce using rule 130 (boolean_literal -> TRUE .)
    GREATER         reduce using rule 130 (boolean_literal -> TRUE .)
    GTEQUAL         reduce using rule 130 (boolean_literal -> TRUE .)
    LESS            reduce using rule 130 (boolean_literal -> TRUE .)
    LTEQUAL         reduce using rule 130 (boolean_literal -> TRUE .)
    IN              reduce using rule 130 (boolean_literal -> TRUE .)
    RBRACKET        reduce using rule 130 (boolean_literal -> TRUE .)
    COMMA           reduce using rule 130 (boolean_literal -> TRUE .)
    SEMI            reduce using rule 130 (boolean_literal -> TRUE .)
    COLON           reduce using rule 130 (boolean_literal -> TRUE .)
    THEN            reduce using rule 130 (boolean_literal -> TRUE .)
    LBRACKET        reduce using rule 130 (boolean_literal -> TRUE .)
    RPAREN          reduce using rule 130 (boolean_literal -> TRUE .)
    ELSE            reduce using rule 130 (boolean_literal -> TRUE .)
    ELSIF           reduce using rule 130 (boolean_literal -> TRUE .)
    FI              reduce using rule 130 (boolean_literal -> TRUE .)

>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

    MINUS           reduce using rule 102 (operator2 -> string_concatenation_operator .)
    NOT             reduce using rule 102 (operator2 -> string_concatenation_operator .)
    ARROW           reduce using rule 102 (operator2 -> string_concatenation_operator .)
    LPAREN          reduce using rule 102 (operator2 -> string_concatenation_operator .)
    ID              reduce using rule 102 (operator2 -> string_concatenation_operator .)
    ICONST          reduce using rule 102 (operator2 -> string_concatenation_operator .)
    TRUE            reduce using rule 102 (operator2 -> string_concatenation_operator .)
    FALSE           reduce using rule 102 (operator2 -> string_concatenation_operator .)
    CCONST          reduce using rule 102 (operator2 -> string_concatenation_operator .)
    NULL            reduce using rule 102 (operator2 -> string_concatenation_operator .)
    SCONST          reduce using rule 102 (operator2 -> string_concatenation_operator .)

<<<<<<< HEAD

state 88
=======
    (13) synonym_definition -> identifier_list ASSIGN expression .

    COMMA           reduce using rule 13 (synonym_definition -> identifier_list ASSIGN expression .)
    SEMI            reduce using rule 13 (synonym_definition -> identifier_list ASSIGN expression .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

    (85) operand1 -> operand1 operator2 . operand2
    (86) operand2 -> . operand3
    (87) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (88) operand3 -> . monadic_operator operand4
    (89) operand3 -> . operand4
    (96) monadic_operator -> . MINUS
    (97) monadic_operator -> . NOT
    (90) operand4 -> . array_location
    (91) operand4 -> . referenced_location
    (92) operand4 -> . primitive_value
    (72) array_location -> . location
    (98) referenced_location -> . ARROW array_location
    (115) primitive_value -> . literal
    (116) primitive_value -> . value_array_element
    (117) primitive_value -> . value_array_slice
    (118) primitive_value -> . parenthesized_expression
    (56) location -> . identifier
    (57) location -> . dereferenced_reference
    (58) location -> . string_element
    (59) location -> . string_slice
    (60) location -> . array_element
    (61) location -> . array_slice
    (119) literal -> . integer_literal
    (120) literal -> . boolean_literal
    (121) literal -> . character_literal
    (122) literal -> . empty_literal
    (123) literal -> . character_string_literal
    (124) value_array_element -> . primitive_value LBRACKET expression_list RBRACKET
    (125) value_array_slice -> . primitive_value LBRACKET expression COLON expression RBRACKET
    (75) parenthesized_expression -> . LPAREN expression RPAREN
    (22) identifier -> . ID
    (62) dereferenced_reference -> . array_location ARROW
    (63) string_element -> . identifier LBRACKET start_element LBRACKET
    (65) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (68) array_element -> . array_location LBRACKET expression_list RBRACKET
    (71) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (126) integer_literal -> . ICONST
    (127) boolean_literal -> . TRUE
    (128) boolean_literal -> . FALSE
    (129) character_literal -> . CCONST
    (130) empty_literal -> . NULL
    (131) character_string_literal -> . SCONST

    MINUS           shift and go to state 36
    NOT             shift and go to state 35
    ARROW           shift and go to state 45
    LPAREN          shift and go to state 44
    ID              shift and go to state 21
    ICONST          shift and go to state 40
    TRUE            shift and go to state 55
    FALSE           shift and go to state 53
    CCONST          shift and go to state 34
    NULL            shift and go to state 27
    SCONST          shift and go to state 52

    location                       shift and go to state 6
    monadic_operator               shift and go to state 47
    operand2                       shift and go to state 148
    value_array_element            shift and go to state 48
    string_slice                   shift and go to state 3
    referenced_location            shift and go to state 29
    array_slice                    shift and go to state 15
    parenthesized_expression       shift and go to state 30
    integer_literal                shift and go to state 32
    empty_literal                  shift and go to state 50
    operand3                       shift and go to state 33
    string_element                 shift and go to state 1
    boolean_literal                shift and go to state 51
    array_location                 shift and go to state 46
    literal                        shift and go to state 37
    array_element                  shift and go to state 7
    primitive_value                shift and go to state 39
    character_literal              shift and go to state 41
    value_array_slice              shift and go to state 42
    operand4                       shift and go to state 54
    character_string_literal       shift and go to state 43
    dereferenced_reference         shift and go to state 20
    identifier                     shift and go to state 56

state 89

<<<<<<< HEAD
    (143) if_action -> IF expression then_clause . else_clause FI
    (144) if_action -> IF expression then_clause .
    (146) else_clause -> . ELSE action_statement_list
    (147) else_clause -> . ELSIF expression then_clause else_clause
    (148) else_clause -> . ELSIF expression then_clause

  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
    DCL             reduce using rule 144 (if_action -> IF expression then_clause .)
    SYN             reduce using rule 144 (if_action -> IF expression then_clause .)
    TYPE            reduce using rule 144 (if_action -> IF expression then_clause .)
    ID              reduce using rule 144 (if_action -> IF expression then_clause .)
    IF              reduce using rule 144 (if_action -> IF expression then_clause .)
    $end            reduce using rule 144 (if_action -> IF expression then_clause .)
    FI              reduce using rule 144 (if_action -> IF expression then_clause .)
    ELSE            shift and go to state 149
    ELSIF           shift and go to state 151

  ! ELSE            [ reduce using rule 144 (if_action -> IF expression then_clause .) ]
  ! ELSIF           [ reduce using rule 144 (if_action -> IF expression then_clause .) ]

    else_clause                    shift and go to state 150

state 90

    (145) then_clause -> THEN . action_statement_list
    (149) action_statement_list -> . action_statement action_statement_nullable
    (132) action_statement -> . identifier COLON action
    (133) action_statement -> . action
    (22) identifier -> . ID
    (134) action -> . bracketed_action
    (135) action -> . assignment_action
    (136) bracketed_action -> . if_action
    (137) assignment_action -> . array_location assigning_operator expression
    (143) if_action -> . IF expression then_clause else_clause FI
    (144) if_action -> . IF expression then_clause
    (72) array_location -> . location
    (56) location -> . identifier
    (57) location -> . dereferenced_reference
    (58) location -> . string_element
    (59) location -> . string_slice
    (60) location -> . array_element
    (61) location -> . array_slice
    (62) dereferenced_reference -> . array_location ARROW
    (63) string_element -> . identifier LBRACKET start_element LBRACKET
    (65) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (68) array_element -> . array_location LBRACKET expression_list RBRACKET
    (71) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET

    ID              shift and go to state 21
    IF              shift and go to state 4

    action_statement_list          shift and go to state 152
    location                       shift and go to state 6
    string_element                 shift and go to state 1
    string_slice                   shift and go to state 3
    array_slice                    shift and go to state 15
    if_action                      shift and go to state 17
    array_location                 shift and go to state 13
    array_element                  shift and go to state 7
    action                         shift and go to state 8
    bracketed_action               shift and go to state 22
    action_statement               shift and go to state 153
    assignment_action              shift and go to state 11
    dereferenced_reference         shift and go to state 20
    identifier                     shift and go to state 24
=======
    (129) integer_literal -> ICONST .

    TIMES           reduce using rule 129 (integer_literal -> ICONST .)
    DIVIDE          reduce using rule 129 (integer_literal -> ICONST .)
    MODULO          reduce using rule 129 (integer_literal -> ICONST .)
    PLUS            reduce using rule 129 (integer_literal -> ICONST .)
    MINUS           reduce using rule 129 (integer_literal -> ICONST .)
    CONCAT          reduce using rule 129 (integer_literal -> ICONST .)
    AND             reduce using rule 129 (integer_literal -> ICONST .)
    OR              reduce using rule 129 (integer_literal -> ICONST .)
    EQUAL           reduce using rule 129 (integer_literal -> ICONST .)
    NOTEQ           reduce using rule 129 (integer_literal -> ICONST .)
    GREATER         reduce using rule 129 (integer_literal -> ICONST .)
    GTEQUAL         reduce using rule 129 (integer_literal -> ICONST .)
    LESS            reduce using rule 129 (integer_literal -> ICONST .)
    LTEQUAL         reduce using rule 129 (integer_literal -> ICONST .)
    IN              reduce using rule 129 (integer_literal -> ICONST .)
    LBRACKET        reduce using rule 129 (integer_literal -> ICONST .)
    COLON           reduce using rule 129 (integer_literal -> ICONST .)
    COMMA           reduce using rule 129 (integer_literal -> ICONST .)
    SEMI            reduce using rule 129 (integer_literal -> ICONST .)
    THEN            reduce using rule 129 (integer_literal -> ICONST .)
    RBRACKET        reduce using rule 129 (integer_literal -> ICONST .)
    RPAREN          reduce using rule 129 (integer_literal -> ICONST .)
    ELSE            reduce using rule 129 (integer_literal -> ICONST .)
    ELSIF           reduce using rule 129 (integer_literal -> ICONST .)
    FI              reduce using rule 129 (integer_literal -> ICONST .)


state 90

    (104) monadic_operator -> MINUS .

    ARROW           reduce using rule 104 (monadic_operator -> MINUS .)
    ID              reduce using rule 104 (monadic_operator -> MINUS .)
    ICONST          reduce using rule 104 (monadic_operator -> MINUS .)
    TRUE            reduce using rule 104 (monadic_operator -> MINUS .)
    FALSE           reduce using rule 104 (monadic_operator -> MINUS .)
    CCONST          reduce using rule 104 (monadic_operator -> MINUS .)
    NULL            reduce using rule 104 (monadic_operator -> MINUS .)
    SCONST          reduce using rule 104 (monadic_operator -> MINUS .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


<<<<<<< HEAD
    (76) conditional_expression -> IF expression . then_expression else_expression FI
    (77) conditional_expression -> IF expression . then_expression elsif_expression else_expression FI
    (78) then_expression -> . THEN expression

    THEN            shift and go to state 154
=======
state 91

    (132) character_literal -> CCONST .

    TIMES           reduce using rule 132 (character_literal -> CCONST .)
    DIVIDE          reduce using rule 132 (character_literal -> CCONST .)
    MODULO          reduce using rule 132 (character_literal -> CCONST .)
    PLUS            reduce using rule 132 (character_literal -> CCONST .)
    MINUS           reduce using rule 132 (character_literal -> CCONST .)
    CONCAT          reduce using rule 132 (character_literal -> CCONST .)
    AND             reduce using rule 132 (character_literal -> CCONST .)
    OR              reduce using rule 132 (character_literal -> CCONST .)
    EQUAL           reduce using rule 132 (character_literal -> CCONST .)
    NOTEQ           reduce using rule 132 (character_literal -> CCONST .)
    GREATER         reduce using rule 132 (character_literal -> CCONST .)
    GTEQUAL         reduce using rule 132 (character_literal -> CCONST .)
    LESS            reduce using rule 132 (character_literal -> CCONST .)
    LTEQUAL         reduce using rule 132 (character_literal -> CCONST .)
    IN              reduce using rule 132 (character_literal -> CCONST .)
    FI              reduce using rule 132 (character_literal -> CCONST .)
    ELSE            reduce using rule 132 (character_literal -> CCONST .)
    ELSIF           reduce using rule 132 (character_literal -> CCONST .)
    COMMA           reduce using rule 132 (character_literal -> CCONST .)
    SEMI            reduce using rule 132 (character_literal -> CCONST .)
    COLON           reduce using rule 132 (character_literal -> CCONST .)
    THEN            reduce using rule 132 (character_literal -> CCONST .)
    RBRACKET        reduce using rule 132 (character_literal -> CCONST .)
    LBRACKET        reduce using rule 132 (character_literal -> CCONST .)
    RPAREN          reduce using rule 132 (character_literal -> CCONST .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

    then_expression                shift and go to state 155

state 92

<<<<<<< HEAD
    (83) operand0 -> operand0 operator1 . operand1
    (84) operand1 -> . operand2
    (85) operand1 -> . operand1 operator2 operand2
    (86) operand2 -> . operand3
    (87) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (88) operand3 -> . monadic_operator operand4
    (89) operand3 -> . operand4
    (96) monadic_operator -> . MINUS
    (97) monadic_operator -> . NOT
    (90) operand4 -> . array_location
    (91) operand4 -> . referenced_location
    (92) operand4 -> . primitive_value
    (72) array_location -> . location
    (98) referenced_location -> . ARROW array_location
    (115) primitive_value -> . literal
    (116) primitive_value -> . value_array_element
    (117) primitive_value -> . value_array_slice
    (118) primitive_value -> . parenthesized_expression
    (56) location -> . identifier
    (57) location -> . dereferenced_reference
    (58) location -> . string_element
    (59) location -> . string_slice
    (60) location -> . array_element
    (61) location -> . array_slice
    (119) literal -> . integer_literal
    (120) literal -> . boolean_literal
    (121) literal -> . character_literal
    (122) literal -> . empty_literal
    (123) literal -> . character_string_literal
    (124) value_array_element -> . primitive_value LBRACKET expression_list RBRACKET
    (125) value_array_slice -> . primitive_value LBRACKET expression COLON expression RBRACKET
    (75) parenthesized_expression -> . LPAREN expression RPAREN
    (22) identifier -> . ID
    (62) dereferenced_reference -> . array_location ARROW
    (63) string_element -> . identifier LBRACKET start_element LBRACKET
    (65) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (68) array_element -> . array_location LBRACKET expression_list RBRACKET
    (71) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (126) integer_literal -> . ICONST
    (127) boolean_literal -> . TRUE
    (128) boolean_literal -> . FALSE
    (129) character_literal -> . CCONST
    (130) empty_literal -> . NULL
    (131) character_string_literal -> . SCONST

    MINUS           shift and go to state 36
    NOT             shift and go to state 35
    ARROW           shift and go to state 45
    LPAREN          shift and go to state 44
    ID              shift and go to state 21
    ICONST          shift and go to state 40
    TRUE            shift and go to state 55
    FALSE           shift and go to state 53
    CCONST          shift and go to state 34
    NULL            shift and go to state 27
    SCONST          shift and go to state 52

    location                       shift and go to state 6
    monadic_operator               shift and go to state 47
    string_slice                   shift and go to state 3
    value_array_element            shift and go to state 48
    operand1                       shift and go to state 156
    operand2                       shift and go to state 49
    referenced_location            shift and go to state 29
    parenthesized_expression       shift and go to state 30
    array_slice                    shift and go to state 15
    integer_literal                shift and go to state 32
    empty_literal                  shift and go to state 50
    array_element                  shift and go to state 7
    operand3                       shift and go to state 33
    string_element                 shift and go to state 1
    boolean_literal                shift and go to state 51
    array_location                 shift and go to state 46
    literal                        shift and go to state 37
    primitive_value                shift and go to state 39
    character_literal              shift and go to state 41
    value_array_slice              shift and go to state 42
    operand4                       shift and go to state 54
    character_string_literal       shift and go to state 43
    dereferenced_reference         shift and go to state 20
    identifier                     shift and go to state 56

state 93

    (112) relational_operator -> LESS .

    MINUS           reduce using rule 112 (relational_operator -> LESS .)
    NOT             reduce using rule 112 (relational_operator -> LESS .)
    ARROW           reduce using rule 112 (relational_operator -> LESS .)
    LPAREN          reduce using rule 112 (relational_operator -> LESS .)
    ID              reduce using rule 112 (relational_operator -> LESS .)
    ICONST          reduce using rule 112 (relational_operator -> LESS .)
    TRUE            reduce using rule 112 (relational_operator -> LESS .)
    FALSE           reduce using rule 112 (relational_operator -> LESS .)
    CCONST          reduce using rule 112 (relational_operator -> LESS .)
    NULL            reduce using rule 112 (relational_operator -> LESS .)
    SCONST          reduce using rule 112 (relational_operator -> LESS .)


state 94

    (99) operator1 -> relational_operator .

    MINUS           reduce using rule 99 (operator1 -> relational_operator .)
    NOT             reduce using rule 99 (operator1 -> relational_operator .)
    ARROW           reduce using rule 99 (operator1 -> relational_operator .)
    LPAREN          reduce using rule 99 (operator1 -> relational_operator .)
    ID              reduce using rule 99 (operator1 -> relational_operator .)
    ICONST          reduce using rule 99 (operator1 -> relational_operator .)
    TRUE            reduce using rule 99 (operator1 -> relational_operator .)
    FALSE           reduce using rule 99 (operator1 -> relational_operator .)
    CCONST          reduce using rule 99 (operator1 -> relational_operator .)
    NULL            reduce using rule 99 (operator1 -> relational_operator .)
    SCONST          reduce using rule 99 (operator1 -> relational_operator .)
=======
    (69) location -> array_element .

    ARROW           reduce using rule 69 (location -> array_element .)
    LBRACKET        reduce using rule 69 (location -> array_element .)
    TIMES           reduce using rule 69 (location -> array_element .)
    DIVIDE          reduce using rule 69 (location -> array_element .)
    MODULO          reduce using rule 69 (location -> array_element .)
    PLUS            reduce using rule 69 (location -> array_element .)
    MINUS           reduce using rule 69 (location -> array_element .)
    CONCAT          reduce using rule 69 (location -> array_element .)
    AND             reduce using rule 69 (location -> array_element .)
    OR              reduce using rule 69 (location -> array_element .)
    EQUAL           reduce using rule 69 (location -> array_element .)
    NOTEQ           reduce using rule 69 (location -> array_element .)
    GREATER         reduce using rule 69 (location -> array_element .)
    GTEQUAL         reduce using rule 69 (location -> array_element .)
    LESS            reduce using rule 69 (location -> array_element .)
    LTEQUAL         reduce using rule 69 (location -> array_element .)
    IN              reduce using rule 69 (location -> array_element .)
    COMMA           reduce using rule 69 (location -> array_element .)
    RBRACKET        reduce using rule 69 (location -> array_element .)
    COLON           reduce using rule 69 (location -> array_element .)
    SEMI            reduce using rule 69 (location -> array_element .)
    THEN            reduce using rule 69 (location -> array_element .)
    RPAREN          reduce using rule 69 (location -> array_element .)
    ELSE            reduce using rule 69 (location -> array_element .)
    ELSIF           reduce using rule 69 (location -> array_element .)
    FI              reduce using rule 69 (location -> array_element .)


state 93

    (96) operand3 -> monadic_operator . operand4
    (98) operand4 -> . array_location
    (99) operand4 -> . referenced_location
    (100) operand4 -> . primitive_value
    (81) array_location -> . location
    (106) referenced_location -> . ARROW array_location
    (123) primitive_value -> . literal
    (65) location -> . identifier
    (66) location -> . dereferenced_reference
    (67) location -> . string_element
    (68) location -> . string_slice
    (69) location -> . array_element
    (70) location -> . array_slice
    (124) literal -> . integer_literal
    (125) literal -> . boolean_literal
    (126) literal -> . character_literal
    (127) literal -> . empty_literal
    (128) literal -> . character_string_literal
    (22) identifier -> . ID
    (71) dereferenced_reference -> . array_location ARROW
    (72) string_element -> . identifier LBRACKET start_element LBRACKET
    (74) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (77) array_element -> . array_location LBRACKET expression_list RBRACKET
    (80) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (129) integer_literal -> . ICONST
    (130) boolean_literal -> . TRUE
    (131) boolean_literal -> . FALSE
    (132) character_literal -> . CCONST
    (133) empty_literal -> . NULL
    (134) character_string_literal -> . SCONST

    ARROW           shift and go to state 72
    ID              shift and go to state 15
    ICONST          shift and go to state 89
    TRUE            shift and go to state 87
    FALSE           shift and go to state 80
    CCONST          shift and go to state 91
    NULL            shift and go to state 97
    SCONST          shift and go to state 95

    character_string_literal       shift and go to state 94
    referenced_location            shift and go to state 79
    array_slice                    shift and go to state 83
    array_location                 shift and go to state 73
    literal                        shift and go to state 74
    dereferenced_reference         shift and go to state 75
    integer_literal                shift and go to state 77
    primitive_value                shift and go to state 78
    string_slice                   shift and go to state 98
    string_element                 shift and go to state 81
    location                       shift and go to state 82
    identifier                     shift and go to state 84
    character_literal              shift and go to state 85
    empty_literal                  shift and go to state 101
    operand4                       shift and go to state 132
    boolean_literal                shift and go to state 104
    array_element                  shift and go to state 92

state 94

    (128) literal -> character_string_literal .

    TIMES           reduce using rule 128 (literal -> character_string_literal .)
    DIVIDE          reduce using rule 128 (literal -> character_string_literal .)
    MODULO          reduce using rule 128 (literal -> character_string_literal .)
    PLUS            reduce using rule 128 (literal -> character_string_literal .)
    MINUS           reduce using rule 128 (literal -> character_string_literal .)
    CONCAT          reduce using rule 128 (literal -> character_string_literal .)
    AND             reduce using rule 128 (literal -> character_string_literal .)
    OR              reduce using rule 128 (literal -> character_string_literal .)
    EQUAL           reduce using rule 128 (literal -> character_string_literal .)
    NOTEQ           reduce using rule 128 (literal -> character_string_literal .)
    GREATER         reduce using rule 128 (literal -> character_string_literal .)
    GTEQUAL         reduce using rule 128 (literal -> character_string_literal .)
    LESS            reduce using rule 128 (literal -> character_string_literal .)
    LTEQUAL         reduce using rule 128 (literal -> character_string_literal .)
    IN              reduce using rule 128 (literal -> character_string_literal .)
    RBRACKET        reduce using rule 128 (literal -> character_string_literal .)
    THEN            reduce using rule 128 (literal -> character_string_literal .)
    RPAREN          reduce using rule 128 (literal -> character_string_literal .)
    COMMA           reduce using rule 128 (literal -> character_string_literal .)
    COLON           reduce using rule 128 (literal -> character_string_literal .)
    FI              reduce using rule 128 (literal -> character_string_literal .)
    SEMI            reduce using rule 128 (literal -> character_string_literal .)
    LBRACKET        reduce using rule 128 (literal -> character_string_literal .)
    ELSE            reduce using rule 128 (literal -> character_string_literal .)
    ELSIF           reduce using rule 128 (literal -> character_string_literal .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 95

<<<<<<< HEAD
    (113) relational_operator -> LTEQUAL .

    MINUS           reduce using rule 113 (relational_operator -> LTEQUAL .)
    NOT             reduce using rule 113 (relational_operator -> LTEQUAL .)
    ARROW           reduce using rule 113 (relational_operator -> LTEQUAL .)
    LPAREN          reduce using rule 113 (relational_operator -> LTEQUAL .)
    ID              reduce using rule 113 (relational_operator -> LTEQUAL .)
    ICONST          reduce using rule 113 (relational_operator -> LTEQUAL .)
    TRUE            reduce using rule 113 (relational_operator -> LTEQUAL .)
    FALSE           reduce using rule 113 (relational_operator -> LTEQUAL .)
    CCONST          reduce using rule 113 (relational_operator -> LTEQUAL .)
    NULL            reduce using rule 113 (relational_operator -> LTEQUAL .)
    SCONST          reduce using rule 113 (relational_operator -> LTEQUAL .)
=======
    (134) character_string_literal -> SCONST .

    TIMES           reduce using rule 134 (character_string_literal -> SCONST .)
    DIVIDE          reduce using rule 134 (character_string_literal -> SCONST .)
    MODULO          reduce using rule 134 (character_string_literal -> SCONST .)
    PLUS            reduce using rule 134 (character_string_literal -> SCONST .)
    MINUS           reduce using rule 134 (character_string_literal -> SCONST .)
    CONCAT          reduce using rule 134 (character_string_literal -> SCONST .)
    AND             reduce using rule 134 (character_string_literal -> SCONST .)
    OR              reduce using rule 134 (character_string_literal -> SCONST .)
    EQUAL           reduce using rule 134 (character_string_literal -> SCONST .)
    NOTEQ           reduce using rule 134 (character_string_literal -> SCONST .)
    GREATER         reduce using rule 134 (character_string_literal -> SCONST .)
    GTEQUAL         reduce using rule 134 (character_string_literal -> SCONST .)
    LESS            reduce using rule 134 (character_string_literal -> SCONST .)
    LTEQUAL         reduce using rule 134 (character_string_literal -> SCONST .)
    IN              reduce using rule 134 (character_string_literal -> SCONST .)
    LBRACKET        reduce using rule 134 (character_string_literal -> SCONST .)
    COLON           reduce using rule 134 (character_string_literal -> SCONST .)
    COMMA           reduce using rule 134 (character_string_literal -> SCONST .)
    SEMI            reduce using rule 134 (character_string_literal -> SCONST .)
    THEN            reduce using rule 134 (character_string_literal -> SCONST .)
    RBRACKET        reduce using rule 134 (character_string_literal -> SCONST .)
    RPAREN          reduce using rule 134 (character_string_literal -> SCONST .)
    ELSE            reduce using rule 134 (character_string_literal -> SCONST .)
    ELSIF           reduce using rule 134 (character_string_literal -> SCONST .)
    FI              reduce using rule 134 (character_string_literal -> SCONST .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 96

<<<<<<< HEAD
    (106) relational_operator -> AND .

    MINUS           reduce using rule 106 (relational_operator -> AND .)
    NOT             reduce using rule 106 (relational_operator -> AND .)
    ARROW           reduce using rule 106 (relational_operator -> AND .)
    LPAREN          reduce using rule 106 (relational_operator -> AND .)
    ID              reduce using rule 106 (relational_operator -> AND .)
    ICONST          reduce using rule 106 (relational_operator -> AND .)
    TRUE            reduce using rule 106 (relational_operator -> AND .)
    FALSE           reduce using rule 106 (relational_operator -> AND .)
    CCONST          reduce using rule 106 (relational_operator -> AND .)
    NULL            reduce using rule 106 (relational_operator -> AND .)
    SCONST          reduce using rule 106 (relational_operator -> AND .)
=======
    (105) monadic_operator -> NOT .

    ARROW           reduce using rule 105 (monadic_operator -> NOT .)
    ID              reduce using rule 105 (monadic_operator -> NOT .)
    ICONST          reduce using rule 105 (monadic_operator -> NOT .)
    TRUE            reduce using rule 105 (monadic_operator -> NOT .)
    FALSE           reduce using rule 105 (monadic_operator -> NOT .)
    CCONST          reduce using rule 105 (monadic_operator -> NOT .)
    NULL            reduce using rule 105 (monadic_operator -> NOT .)
    SCONST          reduce using rule 105 (monadic_operator -> NOT .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 97

<<<<<<< HEAD
    (109) relational_operator -> NOTEQ .

    MINUS           reduce using rule 109 (relational_operator -> NOTEQ .)
    NOT             reduce using rule 109 (relational_operator -> NOTEQ .)
    ARROW           reduce using rule 109 (relational_operator -> NOTEQ .)
    LPAREN          reduce using rule 109 (relational_operator -> NOTEQ .)
    ID              reduce using rule 109 (relational_operator -> NOTEQ .)
    ICONST          reduce using rule 109 (relational_operator -> NOTEQ .)
    TRUE            reduce using rule 109 (relational_operator -> NOTEQ .)
    FALSE           reduce using rule 109 (relational_operator -> NOTEQ .)
    CCONST          reduce using rule 109 (relational_operator -> NOTEQ .)
    NULL            reduce using rule 109 (relational_operator -> NOTEQ .)
    SCONST          reduce using rule 109 (relational_operator -> NOTEQ .)
=======
    (133) empty_literal -> NULL .

    TIMES           reduce using rule 133 (empty_literal -> NULL .)
    DIVIDE          reduce using rule 133 (empty_literal -> NULL .)
    MODULO          reduce using rule 133 (empty_literal -> NULL .)
    PLUS            reduce using rule 133 (empty_literal -> NULL .)
    MINUS           reduce using rule 133 (empty_literal -> NULL .)
    CONCAT          reduce using rule 133 (empty_literal -> NULL .)
    AND             reduce using rule 133 (empty_literal -> NULL .)
    OR              reduce using rule 133 (empty_literal -> NULL .)
    EQUAL           reduce using rule 133 (empty_literal -> NULL .)
    NOTEQ           reduce using rule 133 (empty_literal -> NULL .)
    GREATER         reduce using rule 133 (empty_literal -> NULL .)
    GTEQUAL         reduce using rule 133 (empty_literal -> NULL .)
    LESS            reduce using rule 133 (empty_literal -> NULL .)
    LTEQUAL         reduce using rule 133 (empty_literal -> NULL .)
    IN              reduce using rule 133 (empty_literal -> NULL .)
    ELSE            reduce using rule 133 (empty_literal -> NULL .)
    ELSIF           reduce using rule 133 (empty_literal -> NULL .)
    COMMA           reduce using rule 133 (empty_literal -> NULL .)
    SEMI            reduce using rule 133 (empty_literal -> NULL .)
    COLON           reduce using rule 133 (empty_literal -> NULL .)
    THEN            reduce using rule 133 (empty_literal -> NULL .)
    RBRACKET        reduce using rule 133 (empty_literal -> NULL .)
    LBRACKET        reduce using rule 133 (empty_literal -> NULL .)
    RPAREN          reduce using rule 133 (empty_literal -> NULL .)
    FI              reduce using rule 133 (empty_literal -> NULL .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 98

<<<<<<< HEAD
    (111) relational_operator -> GTEQUAL .

    MINUS           reduce using rule 111 (relational_operator -> GTEQUAL .)
    NOT             reduce using rule 111 (relational_operator -> GTEQUAL .)
    ARROW           reduce using rule 111 (relational_operator -> GTEQUAL .)
    LPAREN          reduce using rule 111 (relational_operator -> GTEQUAL .)
    ID              reduce using rule 111 (relational_operator -> GTEQUAL .)
    ICONST          reduce using rule 111 (relational_operator -> GTEQUAL .)
    TRUE            reduce using rule 111 (relational_operator -> GTEQUAL .)
    FALSE           reduce using rule 111 (relational_operator -> GTEQUAL .)
    CCONST          reduce using rule 111 (relational_operator -> GTEQUAL .)
    NULL            reduce using rule 111 (relational_operator -> GTEQUAL .)
    SCONST          reduce using rule 111 (relational_operator -> GTEQUAL .)

=======
    (68) location -> string_slice .

    ARROW           reduce using rule 68 (location -> string_slice .)
    LBRACKET        reduce using rule 68 (location -> string_slice .)
    TIMES           reduce using rule 68 (location -> string_slice .)
    DIVIDE          reduce using rule 68 (location -> string_slice .)
    MODULO          reduce using rule 68 (location -> string_slice .)
    PLUS            reduce using rule 68 (location -> string_slice .)
    MINUS           reduce using rule 68 (location -> string_slice .)
    CONCAT          reduce using rule 68 (location -> string_slice .)
    AND             reduce using rule 68 (location -> string_slice .)
    OR              reduce using rule 68 (location -> string_slice .)
    EQUAL           reduce using rule 68 (location -> string_slice .)
    NOTEQ           reduce using rule 68 (location -> string_slice .)
    GREATER         reduce using rule 68 (location -> string_slice .)
    GTEQUAL         reduce using rule 68 (location -> string_slice .)
    LESS            reduce using rule 68 (location -> string_slice .)
    LTEQUAL         reduce using rule 68 (location -> string_slice .)
    IN              reduce using rule 68 (location -> string_slice .)
    COMMA           reduce using rule 68 (location -> string_slice .)
    RBRACKET        reduce using rule 68 (location -> string_slice .)
    COLON           reduce using rule 68 (location -> string_slice .)
    SEMI            reduce using rule 68 (location -> string_slice .)
    THEN            reduce using rule 68 (location -> string_slice .)
    RPAREN          reduce using rule 68 (location -> string_slice .)
    ELSE            reduce using rule 68 (location -> string_slice .)
    ELSIF           reduce using rule 68 (location -> string_slice .)
    FI              reduce using rule 68 (location -> string_slice .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


<<<<<<< HEAD
    (100) operator1 -> membership_operator .

    MINUS           reduce using rule 100 (operator1 -> membership_operator .)
    NOT             reduce using rule 100 (operator1 -> membership_operator .)
    ARROW           reduce using rule 100 (operator1 -> membership_operator .)
    LPAREN          reduce using rule 100 (operator1 -> membership_operator .)
    ID              reduce using rule 100 (operator1 -> membership_operator .)
    ICONST          reduce using rule 100 (operator1 -> membership_operator .)
    TRUE            reduce using rule 100 (operator1 -> membership_operator .)
    FALSE           reduce using rule 100 (operator1 -> membership_operator .)
    CCONST          reduce using rule 100 (operator1 -> membership_operator .)
    NULL            reduce using rule 100 (operator1 -> membership_operator .)
    SCONST          reduce using rule 100 (operator1 -> membership_operator .)
=======
state 99
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

    (84) conditional_expression -> IF . expression then_expression else_expression FI
    (85) conditional_expression -> IF . expression then_expression elsif_expression else_expression FI
    (82) expression -> . operand0
    (83) expression -> . conditional_expression
    (90) operand0 -> . operand1
    (91) operand0 -> . operand0 operator1 operand1
    (84) conditional_expression -> . IF expression then_expression else_expression FI
    (85) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (92) operand1 -> . operand2
    (93) operand1 -> . operand1 operator2 operand2
    (94) operand2 -> . operand3
    (95) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (96) operand3 -> . monadic_operator operand4
    (97) operand3 -> . operand4
    (104) monadic_operator -> . MINUS
    (105) monadic_operator -> . NOT
    (98) operand4 -> . array_location
    (99) operand4 -> . referenced_location
    (100) operand4 -> . primitive_value
    (81) array_location -> . location
    (106) referenced_location -> . ARROW array_location
    (123) primitive_value -> . literal
    (65) location -> . identifier
    (66) location -> . dereferenced_reference
    (67) location -> . string_element
    (68) location -> . string_slice
    (69) location -> . array_element
    (70) location -> . array_slice
    (124) literal -> . integer_literal
    (125) literal -> . boolean_literal
    (126) literal -> . character_literal
    (127) literal -> . empty_literal
    (128) literal -> . character_string_literal
    (22) identifier -> . ID
    (71) dereferenced_reference -> . array_location ARROW
    (72) string_element -> . identifier LBRACKET start_element LBRACKET
    (74) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (77) array_element -> . array_location LBRACKET expression_list RBRACKET
    (80) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (129) integer_literal -> . ICONST
    (130) boolean_literal -> . TRUE
    (131) boolean_literal -> . FALSE
    (132) character_literal -> . CCONST
    (133) empty_literal -> . NULL
    (134) character_string_literal -> . SCONST

    IF              shift and go to state 99
    MINUS           shift and go to state 90
    NOT             shift and go to state 96
    ARROW           shift and go to state 72
    ID              shift and go to state 15
    ICONST          shift and go to state 89
    TRUE            shift and go to state 87
    FALSE           shift and go to state 80
    CCONST          shift and go to state 91
    NULL            shift and go to state 97
    SCONST          shift and go to state 95

    monadic_operator               shift and go to state 93
    character_literal              shift and go to state 85
    character_string_literal       shift and go to state 94
    identifier                     shift and go to state 84
    literal                        shift and go to state 74
    dereferenced_reference         shift and go to state 75
    operand3                       shift and go to state 76
    integer_literal                shift and go to state 77
    array_slice                    shift and go to state 83
    primitive_value                shift and go to state 78
    referenced_location            shift and go to state 79
    string_slice                   shift and go to state 98
    string_element                 shift and go to state 81
    location                       shift and go to state 82
    conditional_expression         shift and go to state 100
    operand2                       shift and go to state 103
    array_location                 shift and go to state 73
    empty_literal                  shift and go to state 101
    operand1                       shift and go to state 86
    operand4                       shift and go to state 102
    expression                     shift and go to state 133
    boolean_literal                shift and go to state 104
    operand0                       shift and go to state 105
    array_element                  shift and go to state 92

state 100

<<<<<<< HEAD
    (107) relational_operator -> OR .

    MINUS           reduce using rule 107 (relational_operator -> OR .)
    NOT             reduce using rule 107 (relational_operator -> OR .)
    ARROW           reduce using rule 107 (relational_operator -> OR .)
    LPAREN          reduce using rule 107 (relational_operator -> OR .)
    ID              reduce using rule 107 (relational_operator -> OR .)
    ICONST          reduce using rule 107 (relational_operator -> OR .)
    TRUE            reduce using rule 107 (relational_operator -> OR .)
    FALSE           reduce using rule 107 (relational_operator -> OR .)
    CCONST          reduce using rule 107 (relational_operator -> OR .)
    NULL            reduce using rule 107 (relational_operator -> OR .)
    SCONST          reduce using rule 107 (relational_operator -> OR .)
=======
    (83) expression -> conditional_expression .

    LBRACKET        reduce using rule 83 (expression -> conditional_expression .)
    COLON           reduce using rule 83 (expression -> conditional_expression .)
    COMMA           reduce using rule 83 (expression -> conditional_expression .)
    SEMI            reduce using rule 83 (expression -> conditional_expression .)
    RBRACKET        reduce using rule 83 (expression -> conditional_expression .)
    RPAREN          reduce using rule 83 (expression -> conditional_expression .)
    THEN            reduce using rule 83 (expression -> conditional_expression .)
    FI              reduce using rule 83 (expression -> conditional_expression .)
    ELSE            reduce using rule 83 (expression -> conditional_expression .)
    ELSIF           reduce using rule 83 (expression -> conditional_expression .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 101

<<<<<<< HEAD
    (114) membership_operator -> IN .

    MINUS           reduce using rule 114 (membership_operator -> IN .)
    NOT             reduce using rule 114 (membership_operator -> IN .)
    ARROW           reduce using rule 114 (membership_operator -> IN .)
    LPAREN          reduce using rule 114 (membership_operator -> IN .)
    ID              reduce using rule 114 (membership_operator -> IN .)
    ICONST          reduce using rule 114 (membership_operator -> IN .)
    TRUE            reduce using rule 114 (membership_operator -> IN .)
    FALSE           reduce using rule 114 (membership_operator -> IN .)
    CCONST          reduce using rule 114 (membership_operator -> IN .)
    NULL            reduce using rule 114 (membership_operator -> IN .)
    SCONST          reduce using rule 114 (membership_operator -> IN .)
=======
    (127) literal -> empty_literal .

    TIMES           reduce using rule 127 (literal -> empty_literal .)
    DIVIDE          reduce using rule 127 (literal -> empty_literal .)
    MODULO          reduce using rule 127 (literal -> empty_literal .)
    PLUS            reduce using rule 127 (literal -> empty_literal .)
    MINUS           reduce using rule 127 (literal -> empty_literal .)
    CONCAT          reduce using rule 127 (literal -> empty_literal .)
    AND             reduce using rule 127 (literal -> empty_literal .)
    OR              reduce using rule 127 (literal -> empty_literal .)
    EQUAL           reduce using rule 127 (literal -> empty_literal .)
    NOTEQ           reduce using rule 127 (literal -> empty_literal .)
    GREATER         reduce using rule 127 (literal -> empty_literal .)
    GTEQUAL         reduce using rule 127 (literal -> empty_literal .)
    LESS            reduce using rule 127 (literal -> empty_literal .)
    LTEQUAL         reduce using rule 127 (literal -> empty_literal .)
    IN              reduce using rule 127 (literal -> empty_literal .)
    RBRACKET        reduce using rule 127 (literal -> empty_literal .)
    THEN            reduce using rule 127 (literal -> empty_literal .)
    RPAREN          reduce using rule 127 (literal -> empty_literal .)
    COMMA           reduce using rule 127 (literal -> empty_literal .)
    COLON           reduce using rule 127 (literal -> empty_literal .)
    FI              reduce using rule 127 (literal -> empty_literal .)
    SEMI            reduce using rule 127 (literal -> empty_literal .)
    LBRACKET        reduce using rule 127 (literal -> empty_literal .)
    ELSE            reduce using rule 127 (literal -> empty_literal .)
    ELSIF           reduce using rule 127 (literal -> empty_literal .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 102

<<<<<<< HEAD
    (110) relational_operator -> GREATER .

    MINUS           reduce using rule 110 (relational_operator -> GREATER .)
    NOT             reduce using rule 110 (relational_operator -> GREATER .)
    ARROW           reduce using rule 110 (relational_operator -> GREATER .)
    LPAREN          reduce using rule 110 (relational_operator -> GREATER .)
    ID              reduce using rule 110 (relational_operator -> GREATER .)
    ICONST          reduce using rule 110 (relational_operator -> GREATER .)
    TRUE            reduce using rule 110 (relational_operator -> GREATER .)
    FALSE           reduce using rule 110 (relational_operator -> GREATER .)
    CCONST          reduce using rule 110 (relational_operator -> GREATER .)
    NULL            reduce using rule 110 (relational_operator -> GREATER .)
    SCONST          reduce using rule 110 (relational_operator -> GREATER .)
=======
    (97) operand3 -> operand4 .

    TIMES           reduce using rule 97 (operand3 -> operand4 .)
    DIVIDE          reduce using rule 97 (operand3 -> operand4 .)
    MODULO          reduce using rule 97 (operand3 -> operand4 .)
    PLUS            reduce using rule 97 (operand3 -> operand4 .)
    MINUS           reduce using rule 97 (operand3 -> operand4 .)
    CONCAT          reduce using rule 97 (operand3 -> operand4 .)
    AND             reduce using rule 97 (operand3 -> operand4 .)
    OR              reduce using rule 97 (operand3 -> operand4 .)
    EQUAL           reduce using rule 97 (operand3 -> operand4 .)
    NOTEQ           reduce using rule 97 (operand3 -> operand4 .)
    GREATER         reduce using rule 97 (operand3 -> operand4 .)
    GTEQUAL         reduce using rule 97 (operand3 -> operand4 .)
    LESS            reduce using rule 97 (operand3 -> operand4 .)
    LTEQUAL         reduce using rule 97 (operand3 -> operand4 .)
    IN              reduce using rule 97 (operand3 -> operand4 .)
    FI              reduce using rule 97 (operand3 -> operand4 .)
    COMMA           reduce using rule 97 (operand3 -> operand4 .)
    SEMI            reduce using rule 97 (operand3 -> operand4 .)
    COLON           reduce using rule 97 (operand3 -> operand4 .)
    THEN            reduce using rule 97 (operand3 -> operand4 .)
    RBRACKET        reduce using rule 97 (operand3 -> operand4 .)
    LBRACKET        reduce using rule 97 (operand3 -> operand4 .)
    RPAREN          reduce using rule 97 (operand3 -> operand4 .)
    ELSE            reduce using rule 97 (operand3 -> operand4 .)
    ELSIF           reduce using rule 97 (operand3 -> operand4 .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 103

<<<<<<< HEAD
    (108) relational_operator -> EQUAL .

    MINUS           reduce using rule 108 (relational_operator -> EQUAL .)
    NOT             reduce using rule 108 (relational_operator -> EQUAL .)
    ARROW           reduce using rule 108 (relational_operator -> EQUAL .)
    LPAREN          reduce using rule 108 (relational_operator -> EQUAL .)
    ID              reduce using rule 108 (relational_operator -> EQUAL .)
    ICONST          reduce using rule 108 (relational_operator -> EQUAL .)
    TRUE            reduce using rule 108 (relational_operator -> EQUAL .)
    FALSE           reduce using rule 108 (relational_operator -> EQUAL .)
    CCONST          reduce using rule 108 (relational_operator -> EQUAL .)
    NULL            reduce using rule 108 (relational_operator -> EQUAL .)
    SCONST          reduce using rule 108 (relational_operator -> EQUAL .)


state 104

    (124) value_array_element -> primitive_value LBRACKET . expression_list RBRACKET
    (125) value_array_slice -> primitive_value LBRACKET . expression COLON expression RBRACKET
    (69) expression_list -> . expression
    (70) expression_list -> . expression COMMA expression_list
    (73) expression -> . operand0
    (74) expression -> . conditional_expression
    (82) operand0 -> . operand1
    (83) operand0 -> . operand0 operator1 operand1
    (76) conditional_expression -> . IF expression then_expression else_expression FI
    (77) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (84) operand1 -> . operand2
    (85) operand1 -> . operand1 operator2 operand2
    (86) operand2 -> . operand3
    (87) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (88) operand3 -> . monadic_operator operand4
    (89) operand3 -> . operand4
    (96) monadic_operator -> . MINUS
    (97) monadic_operator -> . NOT
    (90) operand4 -> . array_location
    (91) operand4 -> . referenced_location
    (92) operand4 -> . primitive_value
    (72) array_location -> . location
    (98) referenced_location -> . ARROW array_location
    (115) primitive_value -> . literal
    (116) primitive_value -> . value_array_element
    (117) primitive_value -> . value_array_slice
    (118) primitive_value -> . parenthesized_expression
    (56) location -> . identifier
    (57) location -> . dereferenced_reference
    (58) location -> . string_element
    (59) location -> . string_slice
    (60) location -> . array_element
    (61) location -> . array_slice
    (119) literal -> . integer_literal
    (120) literal -> . boolean_literal
    (121) literal -> . character_literal
    (122) literal -> . empty_literal
    (123) literal -> . character_string_literal
    (124) value_array_element -> . primitive_value LBRACKET expression_list RBRACKET
    (125) value_array_slice -> . primitive_value LBRACKET expression COLON expression RBRACKET
    (75) parenthesized_expression -> . LPAREN expression RPAREN
    (22) identifier -> . ID
    (62) dereferenced_reference -> . array_location ARROW
    (63) string_element -> . identifier LBRACKET start_element LBRACKET
    (65) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (68) array_element -> . array_location LBRACKET expression_list RBRACKET
    (71) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (126) integer_literal -> . ICONST
    (127) boolean_literal -> . TRUE
    (128) boolean_literal -> . FALSE
    (129) character_literal -> . CCONST
    (130) empty_literal -> . NULL
    (131) character_string_literal -> . SCONST

    IF              shift and go to state 31
    MINUS           shift and go to state 36
    NOT             shift and go to state 35
    ARROW           shift and go to state 45
    LPAREN          shift and go to state 44
    ID              shift and go to state 21
    ICONST          shift and go to state 40
    TRUE            shift and go to state 55
    FALSE           shift and go to state 53
    CCONST          shift and go to state 34
    NULL            shift and go to state 27
    SCONST          shift and go to state 52

    location                       shift and go to state 6
    monadic_operator               shift and go to state 47
    operand2                       shift and go to state 49
    value_array_element            shift and go to state 48
    operand1                       shift and go to state 25
    expression                     shift and go to state 157
    conditional_expression         shift and go to state 28
    referenced_location            shift and go to state 29
    expression_list                shift and go to state 158
    parenthesized_expression       shift and go to state 30
    integer_literal                shift and go to state 32
    empty_literal                  shift and go to state 50
    array_element                  shift and go to state 7
    operand3                       shift and go to state 33
    string_slice                   shift and go to state 3
    string_element                 shift and go to state 1
    boolean_literal                shift and go to state 51
    array_location                 shift and go to state 46
    literal                        shift and go to state 37
    operand0                       shift and go to state 38
    primitive_value                shift and go to state 39
    array_slice                    shift and go to state 15
    character_literal              shift and go to state 41
    value_array_slice              shift and go to state 42
    operand4                       shift and go to state 54
    character_string_literal       shift and go to state 43
    dereferenced_reference         shift and go to state 20
    identifier                     shift and go to state 56

state 105

    (75) parenthesized_expression -> LPAREN expression . RPAREN

    RPAREN          shift and go to state 159


state 106

    (98) referenced_location -> ARROW array_location .
    (62) dereferenced_reference -> array_location . ARROW
    (68) array_element -> array_location . LBRACKET expression_list RBRACKET
    (71) array_slice -> array_location . LBRACKET lower_bound COLON upper_bound RBRACKET

  ! shift/reduce conflict for LBRACKET resolved as shift
    TIMES           reduce using rule 98 (referenced_location -> ARROW array_location .)
    DIVIDE          reduce using rule 98 (referenced_location -> ARROW array_location .)
    MODULO          reduce using rule 98 (referenced_location -> ARROW array_location .)
    PLUS            reduce using rule 98 (referenced_location -> ARROW array_location .)
    MINUS           reduce using rule 98 (referenced_location -> ARROW array_location .)
    CONCAT          reduce using rule 98 (referenced_location -> ARROW array_location .)
    AND             reduce using rule 98 (referenced_location -> ARROW array_location .)
    OR              reduce using rule 98 (referenced_location -> ARROW array_location .)
    EQUAL           reduce using rule 98 (referenced_location -> ARROW array_location .)
    NOTEQ           reduce using rule 98 (referenced_location -> ARROW array_location .)
    GREATER         reduce using rule 98 (referenced_location -> ARROW array_location .)
    GTEQUAL         reduce using rule 98 (referenced_location -> ARROW array_location .)
    LESS            reduce using rule 98 (referenced_location -> ARROW array_location .)
    LTEQUAL         reduce using rule 98 (referenced_location -> ARROW array_location .)
    IN              reduce using rule 98 (referenced_location -> ARROW array_location .)
    COMMA           reduce using rule 98 (referenced_location -> ARROW array_location .)
    SEMI            reduce using rule 98 (referenced_location -> ARROW array_location .)
    FI              reduce using rule 98 (referenced_location -> ARROW array_location .)
    RPAREN          reduce using rule 98 (referenced_location -> ARROW array_location .)
    THEN            reduce using rule 98 (referenced_location -> ARROW array_location .)
    DCL             reduce using rule 98 (referenced_location -> ARROW array_location .)
    SYN             reduce using rule 98 (referenced_location -> ARROW array_location .)
    TYPE            reduce using rule 98 (referenced_location -> ARROW array_location .)
    ID              reduce using rule 98 (referenced_location -> ARROW array_location .)
    IF              reduce using rule 98 (referenced_location -> ARROW array_location .)
    $end            reduce using rule 98 (referenced_location -> ARROW array_location .)
    ELSE            reduce using rule 98 (referenced_location -> ARROW array_location .)
    ELSIF           reduce using rule 98 (referenced_location -> ARROW array_location .)
    RBRACKET        reduce using rule 98 (referenced_location -> ARROW array_location .)
    COLON           reduce using rule 98 (referenced_location -> ARROW array_location .)
    ARROW           shift and go to state 61
    LBRACKET        shift and go to state 71

  ! LBRACKET        [ reduce using rule 98 (referenced_location -> ARROW array_location .) ]


state 107

    (88) operand3 -> monadic_operator operand4 .

    TIMES           reduce using rule 88 (operand3 -> monadic_operator operand4 .)
    DIVIDE          reduce using rule 88 (operand3 -> monadic_operator operand4 .)
    MODULO          reduce using rule 88 (operand3 -> monadic_operator operand4 .)
    PLUS            reduce using rule 88 (operand3 -> monadic_operator operand4 .)
    MINUS           reduce using rule 88 (operand3 -> monadic_operator operand4 .)
    CONCAT          reduce using rule 88 (operand3 -> monadic_operator operand4 .)
    AND             reduce using rule 88 (operand3 -> monadic_operator operand4 .)
    OR              reduce using rule 88 (operand3 -> monadic_operator operand4 .)
    EQUAL           reduce using rule 88 (operand3 -> monadic_operator operand4 .)
    NOTEQ           reduce using rule 88 (operand3 -> monadic_operator operand4 .)
    GREATER         reduce using rule 88 (operand3 -> monadic_operator operand4 .)
    GTEQUAL         reduce using rule 88 (operand3 -> monadic_operator operand4 .)
    LESS            reduce using rule 88 (operand3 -> monadic_operator operand4 .)
    LTEQUAL         reduce using rule 88 (operand3 -> monadic_operator operand4 .)
    IN              reduce using rule 88 (operand3 -> monadic_operator operand4 .)
    COMMA           reduce using rule 88 (operand3 -> monadic_operator operand4 .)
    RBRACKET        reduce using rule 88 (operand3 -> monadic_operator operand4 .)
    THEN            reduce using rule 88 (operand3 -> monadic_operator operand4 .)
    SEMI            reduce using rule 88 (operand3 -> monadic_operator operand4 .)
    LBRACKET        reduce using rule 88 (operand3 -> monadic_operator operand4 .)
    COLON           reduce using rule 88 (operand3 -> monadic_operator operand4 .)
    RPAREN          reduce using rule 88 (operand3 -> monadic_operator operand4 .)
    DCL             reduce using rule 88 (operand3 -> monadic_operator operand4 .)
    SYN             reduce using rule 88 (operand3 -> monadic_operator operand4 .)
    TYPE            reduce using rule 88 (operand3 -> monadic_operator operand4 .)
    ID              reduce using rule 88 (operand3 -> monadic_operator operand4 .)
    IF              reduce using rule 88 (operand3 -> monadic_operator operand4 .)
    $end            reduce using rule 88 (operand3 -> monadic_operator operand4 .)
    ELSE            reduce using rule 88 (operand3 -> monadic_operator operand4 .)
    ELSIF           reduce using rule 88 (operand3 -> monadic_operator operand4 .)
    FI              reduce using rule 88 (operand3 -> monadic_operator operand4 .)
=======
    (92) operand1 -> operand2 .
    (95) operand2 -> operand2 . arithmetic_multiplicative_operator operand3
    (101) arithmetic_multiplicative_operator -> . TIMES
    (102) arithmetic_multiplicative_operator -> . DIVIDE
    (103) arithmetic_multiplicative_operator -> . MODULO

    PLUS            reduce using rule 92 (operand1 -> operand2 .)
    MINUS           reduce using rule 92 (operand1 -> operand2 .)
    CONCAT          reduce using rule 92 (operand1 -> operand2 .)
    AND             reduce using rule 92 (operand1 -> operand2 .)
    OR              reduce using rule 92 (operand1 -> operand2 .)
    EQUAL           reduce using rule 92 (operand1 -> operand2 .)
    NOTEQ           reduce using rule 92 (operand1 -> operand2 .)
    GREATER         reduce using rule 92 (operand1 -> operand2 .)
    GTEQUAL         reduce using rule 92 (operand1 -> operand2 .)
    LESS            reduce using rule 92 (operand1 -> operand2 .)
    LTEQUAL         reduce using rule 92 (operand1 -> operand2 .)
    IN              reduce using rule 92 (operand1 -> operand2 .)
    COLON           reduce using rule 92 (operand1 -> operand2 .)
    THEN            reduce using rule 92 (operand1 -> operand2 .)
    COMMA           reduce using rule 92 (operand1 -> operand2 .)
    SEMI            reduce using rule 92 (operand1 -> operand2 .)
    FI              reduce using rule 92 (operand1 -> operand2 .)
    RBRACKET        reduce using rule 92 (operand1 -> operand2 .)
    ELSE            reduce using rule 92 (operand1 -> operand2 .)
    ELSIF           reduce using rule 92 (operand1 -> operand2 .)
    RPAREN          reduce using rule 92 (operand1 -> operand2 .)
    LBRACKET        reduce using rule 92 (operand1 -> operand2 .)
    TIMES           shift and go to state 137
    DIVIDE          shift and go to state 134
    MODULO          shift and go to state 136

    arithmetic_multiplicative_operator shift and go to state 135

state 104

    (125) literal -> boolean_literal .

    TIMES           reduce using rule 125 (literal -> boolean_literal .)
    DIVIDE          reduce using rule 125 (literal -> boolean_literal .)
    MODULO          reduce using rule 125 (literal -> boolean_literal .)
    PLUS            reduce using rule 125 (literal -> boolean_literal .)
    MINUS           reduce using rule 125 (literal -> boolean_literal .)
    CONCAT          reduce using rule 125 (literal -> boolean_literal .)
    AND             reduce using rule 125 (literal -> boolean_literal .)
    OR              reduce using rule 125 (literal -> boolean_literal .)
    EQUAL           reduce using rule 125 (literal -> boolean_literal .)
    NOTEQ           reduce using rule 125 (literal -> boolean_literal .)
    GREATER         reduce using rule 125 (literal -> boolean_literal .)
    GTEQUAL         reduce using rule 125 (literal -> boolean_literal .)
    LESS            reduce using rule 125 (literal -> boolean_literal .)
    LTEQUAL         reduce using rule 125 (literal -> boolean_literal .)
    IN              reduce using rule 125 (literal -> boolean_literal .)
    RBRACKET        reduce using rule 125 (literal -> boolean_literal .)
    THEN            reduce using rule 125 (literal -> boolean_literal .)
    RPAREN          reduce using rule 125 (literal -> boolean_literal .)
    COMMA           reduce using rule 125 (literal -> boolean_literal .)
    COLON           reduce using rule 125 (literal -> boolean_literal .)
    FI              reduce using rule 125 (literal -> boolean_literal .)
    SEMI            reduce using rule 125 (literal -> boolean_literal .)
    LBRACKET        reduce using rule 125 (literal -> boolean_literal .)
    ELSE            reduce using rule 125 (literal -> boolean_literal .)
    ELSIF           reduce using rule 125 (literal -> boolean_literal .)


state 105

    (82) expression -> operand0 .
    (91) operand0 -> operand0 . operator1 operand1
    (107) operator1 -> . relational_operator
    (108) operator1 -> . membership_operator
    (114) relational_operator -> . AND
    (115) relational_operator -> . OR
    (116) relational_operator -> . EQUAL
    (117) relational_operator -> . NOTEQ
    (118) relational_operator -> . GREATER
    (119) relational_operator -> . GTEQUAL
    (120) relational_operator -> . LESS
    (121) relational_operator -> . LTEQUAL
    (122) membership_operator -> . IN

    LBRACKET        reduce using rule 82 (expression -> operand0 .)
    COLON           reduce using rule 82 (expression -> operand0 .)
    COMMA           reduce using rule 82 (expression -> operand0 .)
    SEMI            reduce using rule 82 (expression -> operand0 .)
    RBRACKET        reduce using rule 82 (expression -> operand0 .)
    RPAREN          reduce using rule 82 (expression -> operand0 .)
    THEN            reduce using rule 82 (expression -> operand0 .)
    FI              reduce using rule 82 (expression -> operand0 .)
    ELSE            reduce using rule 82 (expression -> operand0 .)
    ELSIF           reduce using rule 82 (expression -> operand0 .)
    AND             shift and go to state 139
    OR              shift and go to state 141
    EQUAL           shift and go to state 147
    NOTEQ           shift and go to state 146
    GREATER         shift and go to state 138
    GTEQUAL         shift and go to state 140
    LESS            shift and go to state 143
    LTEQUAL         shift and go to state 149
    IN              shift and go to state 148

    membership_operator            shift and go to state 142
    operator1                      shift and go to state 144
    relational_operator            shift and go to state 145

state 106

    (12) synonym_definition -> identifier_list mode ASSIGN . expression
    (82) expression -> . operand0
    (83) expression -> . conditional_expression
    (90) operand0 -> . operand1
    (91) operand0 -> . operand0 operator1 operand1
    (84) conditional_expression -> . IF expression then_expression else_expression FI
    (85) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (92) operand1 -> . operand2
    (93) operand1 -> . operand1 operator2 operand2
    (94) operand2 -> . operand3
    (95) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (96) operand3 -> . monadic_operator operand4
    (97) operand3 -> . operand4
    (104) monadic_operator -> . MINUS
    (105) monadic_operator -> . NOT
    (98) operand4 -> . array_location
    (99) operand4 -> . referenced_location
    (100) operand4 -> . primitive_value
    (81) array_location -> . location
    (106) referenced_location -> . ARROW array_location
    (123) primitive_value -> . literal
    (65) location -> . identifier
    (66) location -> . dereferenced_reference
    (67) location -> . string_element
    (68) location -> . string_slice
    (69) location -> . array_element
    (70) location -> . array_slice
    (124) literal -> . integer_literal
    (125) literal -> . boolean_literal
    (126) literal -> . character_literal
    (127) literal -> . empty_literal
    (128) literal -> . character_string_literal
    (22) identifier -> . ID
    (71) dereferenced_reference -> . array_location ARROW
    (72) string_element -> . identifier LBRACKET start_element LBRACKET
    (74) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (77) array_element -> . array_location LBRACKET expression_list RBRACKET
    (80) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (129) integer_literal -> . ICONST
    (130) boolean_literal -> . TRUE
    (131) boolean_literal -> . FALSE
    (132) character_literal -> . CCONST
    (133) empty_literal -> . NULL
    (134) character_string_literal -> . SCONST

    IF              shift and go to state 99
    MINUS           shift and go to state 90
    NOT             shift and go to state 96
    ARROW           shift and go to state 72
    ID              shift and go to state 15
    ICONST          shift and go to state 89
    TRUE            shift and go to state 87
    FALSE           shift and go to state 80
    CCONST          shift and go to state 91
    NULL            shift and go to state 97
    SCONST          shift and go to state 95

    monadic_operator               shift and go to state 93
    character_literal              shift and go to state 85
    character_string_literal       shift and go to state 94
    identifier                     shift and go to state 84
    array_location                 shift and go to state 73
    literal                        shift and go to state 74
    dereferenced_reference         shift and go to state 75
    operand3                       shift and go to state 76
    integer_literal                shift and go to state 77
    array_slice                    shift and go to state 83
    primitive_value                shift and go to state 78
    referenced_location            shift and go to state 79
    string_slice                   shift and go to state 98
    string_element                 shift and go to state 81
    location                       shift and go to state 82
    conditional_expression         shift and go to state 100
    operand2                       shift and go to state 103
    empty_literal                  shift and go to state 101
    operand1                       shift and go to state 86
    operand4                       shift and go to state 102
    expression                     shift and go to state 150
    boolean_literal                shift and go to state 104
    operand0                       shift and go to state 105
    array_element                  shift and go to state 92

state 107

    (30) formal_parameter_list -> formal_parameter .
    (31) formal_parameter_list -> formal_parameter . COMMA formal_parameter

    RPAREN          reduce using rule 30 (formal_parameter_list -> formal_parameter .)
    COMMA           shift and go to state 151
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 108

<<<<<<< HEAD
    (87) operand2 -> operand2 arithmetic_multiplicative_operator . operand3
    (88) operand3 -> . monadic_operator operand4
    (89) operand3 -> . operand4
    (96) monadic_operator -> . MINUS
    (97) monadic_operator -> . NOT
    (90) operand4 -> . array_location
    (91) operand4 -> . referenced_location
    (92) operand4 -> . primitive_value
    (72) array_location -> . location
    (98) referenced_location -> . ARROW array_location
    (115) primitive_value -> . literal
    (116) primitive_value -> . value_array_element
    (117) primitive_value -> . value_array_slice
    (118) primitive_value -> . parenthesized_expression
    (56) location -> . identifier
    (57) location -> . dereferenced_reference
    (58) location -> . string_element
    (59) location -> . string_slice
    (60) location -> . array_element
    (61) location -> . array_slice
    (119) literal -> . integer_literal
    (120) literal -> . boolean_literal
    (121) literal -> . character_literal
    (122) literal -> . empty_literal
    (123) literal -> . character_string_literal
    (124) value_array_element -> . primitive_value LBRACKET expression_list RBRACKET
    (125) value_array_slice -> . primitive_value LBRACKET expression COLON expression RBRACKET
    (75) parenthesized_expression -> . LPAREN expression RPAREN
    (22) identifier -> . ID
    (62) dereferenced_reference -> . array_location ARROW
    (63) string_element -> . identifier LBRACKET start_element LBRACKET
    (65) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (68) array_element -> . array_location LBRACKET expression_list RBRACKET
    (71) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (126) integer_literal -> . ICONST
    (127) boolean_literal -> . TRUE
    (128) boolean_literal -> . FALSE
    (129) character_literal -> . CCONST
    (130) empty_literal -> . NULL
    (131) character_string_literal -> . SCONST

    MINUS           shift and go to state 36
    NOT             shift and go to state 35
    ARROW           shift and go to state 45
    LPAREN          shift and go to state 44
    ID              shift and go to state 21
    ICONST          shift and go to state 40
    TRUE            shift and go to state 55
    FALSE           shift and go to state 53
    CCONST          shift and go to state 34
    NULL            shift and go to state 27
    SCONST          shift and go to state 52

    location                       shift and go to state 6
    monadic_operator               shift and go to state 47
    value_array_element            shift and go to state 48
    string_slice                   shift and go to state 3
    referenced_location            shift and go to state 29
    array_slice                    shift and go to state 15
    parenthesized_expression       shift and go to state 30
    integer_literal                shift and go to state 32
    empty_literal                  shift and go to state 50
    operand3                       shift and go to state 160
    string_element                 shift and go to state 1
    boolean_literal                shift and go to state 51
    array_location                 shift and go to state 46
    literal                        shift and go to state 37
    array_element                  shift and go to state 7
    primitive_value                shift and go to state 39
    character_literal              shift and go to state 41
    value_array_slice              shift and go to state 42
    operand4                       shift and go to state 54
    character_string_literal       shift and go to state 43
    dereferenced_reference         shift and go to state 20
    identifier                     shift and go to state 56

state 109

    (21) identifier_list -> identifier COMMA . identifier_list
    (20) identifier_list -> . identifier
    (21) identifier_list -> . identifier COMMA identifier_list
    (22) identifier -> . ID

    ID              shift and go to state 21

    identifier_list                shift and go to state 161
    identifier                     shift and go to state 57

state 110

    (11) synonym_list -> synonym_definition COMMA . synonym_list
    (10) synonym_list -> . synonym_definition
    (11) synonym_list -> . synonym_definition COMMA synonym_list
    (12) synonym_definition -> . identifier_list mode ASSIGN expression
    (13) synonym_definition -> . identifier_list ASSIGN expression
    (20) identifier_list -> . identifier
    (21) identifier_list -> . identifier COMMA identifier_list
    (22) identifier -> . ID

    ID              shift and go to state 21
=======
    (28) procedure_definition -> PROC LPAREN formal_parameter_list . RPAREN result_spec SEMI statement_nullable END SEMI
    (29) procedure_definition -> PROC LPAREN formal_parameter_list . RPAREN SEMI statement_nullable END SEMI

    RPAREN          shift and go to state 152


state 109

    (32) formal_parameter -> identifier_list . mode LOC
    (33) formal_parameter -> identifier_list . mode
    (36) mode -> . mode_name
    (37) mode -> . discrete_mode
    (38) mode -> . reference_mode
    (39) mode -> . composite_mode
    (40) mode_name -> . identifier
    (41) discrete_mode -> . integer_mode
    (42) discrete_mode -> . boolean_mode
    (43) discrete_mode -> . character_mode
    (44) discrete_mode -> . discrete_range_mode
    (54) reference_mode -> . REF mode
    (55) composite_mode -> . string_mode
    (56) composite_mode -> . array_mode
    (22) identifier -> . ID
    (46) integer_mode -> . INT
    (47) boolean_mode -> . BOOL
    (48) character_mode -> . CHAR
    (49) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (50) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (57) string_mode -> . CHARS LBRACKET string_length RBRACKET
    (59) array_mode -> . ARRAY LBRACKET index_mode_list RBRACKET element_mode
    (45) discrete_mode_name -> . identifier

    REF             shift and go to state 38
    ID              shift and go to state 15
    INT             shift and go to state 39
    BOOL            shift and go to state 53
    CHAR            shift and go to state 51
    CHARS           shift and go to state 43
    ARRAY           shift and go to state 52

    discrete_range_mode            shift and go to state 45
    identifier                     shift and go to state 36
    composite_mode                 shift and go to state 46
    character_mode                 shift and go to state 47
    discrete_mode_name             shift and go to state 48
    mode                           shift and go to state 153
    boolean_mode                   shift and go to state 50
    mode_name                      shift and go to state 41
    reference_mode                 shift and go to state 35
    array_mode                     shift and go to state 42
    integer_mode                   shift and go to state 40
    string_mode                    shift and go to state 44
    discrete_mode                  shift and go to state 37

state 110

    (50) discrete_range_mode -> discrete_mode LPAREN literal_range . RPAREN

    RPAREN          shift and go to state 154
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

    identifier                     shift and go to state 57
    synonym_definition             shift and go to state 58
    identifier_list                shift and go to state 59
    synonym_list                   shift and go to state 162

state 111

<<<<<<< HEAD
    (46) composite_mode -> string_mode .

    ASSIGN          reduce using rule 46 (composite_mode -> string_mode .)
    COMMA           reduce using rule 46 (composite_mode -> string_mode .)
    SEMI            reduce using rule 46 (composite_mode -> string_mode .)
=======
    (52) lower_bound -> expression .

    COLON           reduce using rule 52 (lower_bound -> expression .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 112

<<<<<<< HEAD
    (39) character_mode -> CHAR .

    LPAREN          reduce using rule 39 (character_mode -> CHAR .)
    COMMA           reduce using rule 39 (character_mode -> CHAR .)
    RBRACKET        reduce using rule 39 (character_mode -> CHAR .)
    ASSIGN          reduce using rule 39 (character_mode -> CHAR .)
    SEMI            reduce using rule 39 (character_mode -> CHAR .)
=======
    (51) literal_range -> lower_bound . COLON upper_bound

    COLON           shift and go to state 155
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 113

<<<<<<< HEAD
    (12) synonym_definition -> identifier_list mode . ASSIGN expression

    ASSIGN          shift and go to state 163
=======
    (58) string_length -> integer_literal .

    RBRACKET        reduce using rule 58 (string_length -> integer_literal .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 114

<<<<<<< HEAD
    (29) mode -> reference_mode .

    ASSIGN          reduce using rule 29 (mode -> reference_mode .)
    COMMA           reduce using rule 29 (mode -> reference_mode .)
    SEMI            reduce using rule 29 (mode -> reference_mode .)
=======
    (57) string_mode -> CHARS LBRACKET string_length . RBRACKET

    RBRACKET        shift and go to state 156
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 115

<<<<<<< HEAD
    (47) composite_mode -> array_mode .

    ASSIGN          reduce using rule 47 (composite_mode -> array_mode .)
    COMMA           reduce using rule 47 (composite_mode -> array_mode .)
    SEMI            reduce using rule 47 (composite_mode -> array_mode .)
=======
    (49) discrete_range_mode -> discrete_mode_name LPAREN literal_range . RPAREN

    RPAREN          shift and go to state 157
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 116

<<<<<<< HEAD
    (40) discrete_range_mode -> discrete_mode_name . LPAREN literal_range RPAREN

    LPAREN          shift and go to state 164
=======
    (19) initialization -> ASSIGN expression .

    COMMA           reduce using rule 19 (initialization -> ASSIGN expression .)
    SEMI            reduce using rule 19 (initialization -> ASSIGN expression .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 117

<<<<<<< HEAD
    (32) discrete_mode -> integer_mode .

    LPAREN          reduce using rule 32 (discrete_mode -> integer_mode .)
    COMMA           reduce using rule 32 (discrete_mode -> integer_mode .)
    SEMI            reduce using rule 32 (discrete_mode -> integer_mode .)
    RBRACKET        reduce using rule 32 (discrete_mode -> integer_mode .)
    ASSIGN          reduce using rule 32 (discrete_mode -> integer_mode .)
=======
    (45) discrete_mode_name -> identifier .
    (65) location -> identifier .
    (72) string_element -> identifier . LBRACKET start_element LBRACKET
    (74) string_slice -> identifier . LBRACKET left_element COLON right_element RBRACKET

  ! shift/reduce conflict for LBRACKET resolved as shift
    LPAREN          reduce using rule 45 (discrete_mode_name -> identifier .)
    ARROW           reduce using rule 65 (location -> identifier .)
    TIMES           reduce using rule 65 (location -> identifier .)
    DIVIDE          reduce using rule 65 (location -> identifier .)
    MODULO          reduce using rule 65 (location -> identifier .)
    PLUS            reduce using rule 65 (location -> identifier .)
    MINUS           reduce using rule 65 (location -> identifier .)
    CONCAT          reduce using rule 65 (location -> identifier .)
    AND             reduce using rule 65 (location -> identifier .)
    OR              reduce using rule 65 (location -> identifier .)
    EQUAL           reduce using rule 65 (location -> identifier .)
    NOTEQ           reduce using rule 65 (location -> identifier .)
    GREATER         reduce using rule 65 (location -> identifier .)
    GTEQUAL         reduce using rule 65 (location -> identifier .)
    LESS            reduce using rule 65 (location -> identifier .)
    LTEQUAL         reduce using rule 65 (location -> identifier .)
    IN              reduce using rule 65 (location -> identifier .)
    COLON           reduce using rule 65 (location -> identifier .)
    LBRACKET        shift and go to state 125

  ! LBRACKET        [ reduce using rule 65 (location -> identifier .) ]
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 118

<<<<<<< HEAD
    (45) reference_mode -> REF . mode
    (27) mode -> . mode_name
    (28) mode -> . discrete_mode
    (29) mode -> . reference_mode
    (30) mode -> . composite_mode
    (31) mode_name -> . identifier
    (32) discrete_mode -> . integer_mode
    (33) discrete_mode -> . boolean_mode
    (34) discrete_mode -> . character_mode
    (35) discrete_mode -> . discrete_range_mode
    (45) reference_mode -> . REF mode
    (46) composite_mode -> . string_mode
    (47) composite_mode -> . array_mode
    (22) identifier -> . ID
    (37) integer_mode -> . INT
    (38) boolean_mode -> . BOOL
    (39) character_mode -> . CHAR
    (40) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (41) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (48) string_mode -> . CHARS LBRACKET string_length RBRACKET
    (50) array_mode -> . ARRAY LBRACKET index_mode_list RBRACKET element_mode
    (36) discrete_mode_name -> . identifier

    REF             shift and go to state 118
    ID              shift and go to state 21
    INT             shift and go to state 119
    BOOL            shift and go to state 130
    CHAR            shift and go to state 112
    CHARS           shift and go to state 125
    ARRAY           shift and go to state 121

    string_mode                    shift and go to state 111
    mode                           shift and go to state 165
    reference_mode                 shift and go to state 114
    boolean_mode                   shift and go to state 122
    composite_mode                 shift and go to state 123
    integer_mode                   shift and go to state 117
    character_mode                 shift and go to state 124
    mode_name                      shift and go to state 120
    array_mode                     shift and go to state 115
    discrete_range_mode            shift and go to state 127
    discrete_mode                  shift and go to state 128
    discrete_mode_name             shift and go to state 116
    identifier                     shift and go to state 129

state 119

    (37) integer_mode -> INT .

    LPAREN          reduce using rule 37 (integer_mode -> INT .)
    ASSIGN          reduce using rule 37 (integer_mode -> INT .)
    COMMA           reduce using rule 37 (integer_mode -> INT .)
    RBRACKET        reduce using rule 37 (integer_mode -> INT .)
    SEMI            reduce using rule 37 (integer_mode -> INT .)
=======
    (62) index_mode -> discrete_mode .
    (50) discrete_range_mode -> discrete_mode . LPAREN literal_range RPAREN

    COMMA           reduce using rule 62 (index_mode -> discrete_mode .)
    RBRACKET        reduce using rule 62 (index_mode -> discrete_mode .)
    LPAREN          shift and go to state 64


state 119

    (63) index_mode -> literal_range .

    COMMA           reduce using rule 63 (index_mode -> literal_range .)
    RBRACKET        reduce using rule 63 (index_mode -> literal_range .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 120

<<<<<<< HEAD
    (27) mode -> mode_name .

    ASSIGN          reduce using rule 27 (mode -> mode_name .)
    COMMA           reduce using rule 27 (mode -> mode_name .)
    SEMI            reduce using rule 27 (mode -> mode_name .)
=======
    (59) array_mode -> ARRAY LBRACKET index_mode_list . RBRACKET element_mode

    RBRACKET        shift and go to state 158
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 121

<<<<<<< HEAD
    (50) array_mode -> ARRAY . LBRACKET index_mode_list RBRACKET element_mode

    LBRACKET        shift and go to state 166
=======
    (60) index_mode_list -> index_mode .
    (61) index_mode_list -> index_mode . COMMA index_mode_list

    RBRACKET        reduce using rule 60 (index_mode_list -> index_mode .)
    COMMA           shift and go to state 159
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 122

<<<<<<< HEAD
    (33) discrete_mode -> boolean_mode .

    LPAREN          reduce using rule 33 (discrete_mode -> boolean_mode .)
    COMMA           reduce using rule 33 (discrete_mode -> boolean_mode .)
    SEMI            reduce using rule 33 (discrete_mode -> boolean_mode .)
    RBRACKET        reduce using rule 33 (discrete_mode -> boolean_mode .)
    ASSIGN          reduce using rule 33 (discrete_mode -> boolean_mode .)

=======
    (106) referenced_location -> ARROW array_location .
    (71) dereferenced_reference -> array_location . ARROW
    (77) array_element -> array_location . LBRACKET expression_list RBRACKET
    (80) array_slice -> array_location . LBRACKET lower_bound COLON upper_bound RBRACKET
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

  ! shift/reduce conflict for LBRACKET resolved as shift
    TIMES           reduce using rule 106 (referenced_location -> ARROW array_location .)
    DIVIDE          reduce using rule 106 (referenced_location -> ARROW array_location .)
    MODULO          reduce using rule 106 (referenced_location -> ARROW array_location .)
    PLUS            reduce using rule 106 (referenced_location -> ARROW array_location .)
    MINUS           reduce using rule 106 (referenced_location -> ARROW array_location .)
    CONCAT          reduce using rule 106 (referenced_location -> ARROW array_location .)
    AND             reduce using rule 106 (referenced_location -> ARROW array_location .)
    OR              reduce using rule 106 (referenced_location -> ARROW array_location .)
    EQUAL           reduce using rule 106 (referenced_location -> ARROW array_location .)
    NOTEQ           reduce using rule 106 (referenced_location -> ARROW array_location .)
    GREATER         reduce using rule 106 (referenced_location -> ARROW array_location .)
    GTEQUAL         reduce using rule 106 (referenced_location -> ARROW array_location .)
    LESS            reduce using rule 106 (referenced_location -> ARROW array_location .)
    LTEQUAL         reduce using rule 106 (referenced_location -> ARROW array_location .)
    IN              reduce using rule 106 (referenced_location -> ARROW array_location .)
    COMMA           reduce using rule 106 (referenced_location -> ARROW array_location .)
    SEMI            reduce using rule 106 (referenced_location -> ARROW array_location .)
    COLON           reduce using rule 106 (referenced_location -> ARROW array_location .)
    THEN            reduce using rule 106 (referenced_location -> ARROW array_location .)
    RBRACKET        reduce using rule 106 (referenced_location -> ARROW array_location .)
    RPAREN          reduce using rule 106 (referenced_location -> ARROW array_location .)
    ELSE            reduce using rule 106 (referenced_location -> ARROW array_location .)
    ELSIF           reduce using rule 106 (referenced_location -> ARROW array_location .)
    FI              reduce using rule 106 (referenced_location -> ARROW array_location .)
    ARROW           shift and go to state 123
    LBRACKET        shift and go to state 124

<<<<<<< HEAD
    (30) mode -> composite_mode .

    ASSIGN          reduce using rule 30 (mode -> composite_mode .)
    COMMA           reduce using rule 30 (mode -> composite_mode .)
    SEMI            reduce using rule 30 (mode -> composite_mode .)
=======
  ! LBRACKET        [ reduce using rule 106 (referenced_location -> ARROW array_location .) ]

>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

state 123

    (71) dereferenced_reference -> array_location ARROW .

    ARROW           reduce using rule 71 (dereferenced_reference -> array_location ARROW .)
    LBRACKET        reduce using rule 71 (dereferenced_reference -> array_location ARROW .)
    TIMES           reduce using rule 71 (dereferenced_reference -> array_location ARROW .)
    DIVIDE          reduce using rule 71 (dereferenced_reference -> array_location ARROW .)
    MODULO          reduce using rule 71 (dereferenced_reference -> array_location ARROW .)
    PLUS            reduce using rule 71 (dereferenced_reference -> array_location ARROW .)
    MINUS           reduce using rule 71 (dereferenced_reference -> array_location ARROW .)
    CONCAT          reduce using rule 71 (dereferenced_reference -> array_location ARROW .)
    AND             reduce using rule 71 (dereferenced_reference -> array_location ARROW .)
    OR              reduce using rule 71 (dereferenced_reference -> array_location ARROW .)
    EQUAL           reduce using rule 71 (dereferenced_reference -> array_location ARROW .)
    NOTEQ           reduce using rule 71 (dereferenced_reference -> array_location ARROW .)
    GREATER         reduce using rule 71 (dereferenced_reference -> array_location ARROW .)
    GTEQUAL         reduce using rule 71 (dereferenced_reference -> array_location ARROW .)
    LESS            reduce using rule 71 (dereferenced_reference -> array_location ARROW .)
    LTEQUAL         reduce using rule 71 (dereferenced_reference -> array_location ARROW .)
    IN              reduce using rule 71 (dereferenced_reference -> array_location ARROW .)
    RBRACKET        reduce using rule 71 (dereferenced_reference -> array_location ARROW .)
    COMMA           reduce using rule 71 (dereferenced_reference -> array_location ARROW .)
    COLON           reduce using rule 71 (dereferenced_reference -> array_location ARROW .)
    SEMI            reduce using rule 71 (dereferenced_reference -> array_location ARROW .)
    THEN            reduce using rule 71 (dereferenced_reference -> array_location ARROW .)
    RPAREN          reduce using rule 71 (dereferenced_reference -> array_location ARROW .)
    ELSE            reduce using rule 71 (dereferenced_reference -> array_location ARROW .)
    ELSIF           reduce using rule 71 (dereferenced_reference -> array_location ARROW .)
    FI              reduce using rule 71 (dereferenced_reference -> array_location ARROW .)

<<<<<<< HEAD
    (34) discrete_mode -> character_mode .

    LPAREN          reduce using rule 34 (discrete_mode -> character_mode .)
    COMMA           reduce using rule 34 (discrete_mode -> character_mode .)
    SEMI            reduce using rule 34 (discrete_mode -> character_mode .)
    RBRACKET        reduce using rule 34 (discrete_mode -> character_mode .)
    ASSIGN          reduce using rule 34 (discrete_mode -> character_mode .)

=======
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

state 124

<<<<<<< HEAD
    (48) string_mode -> CHARS . LBRACKET string_length RBRACKET

    LBRACKET        shift and go to state 167
=======
    (77) array_element -> array_location LBRACKET . expression_list RBRACKET
    (80) array_slice -> array_location LBRACKET . lower_bound COLON upper_bound RBRACKET
    (78) expression_list -> . expression
    (79) expression_list -> . expression COMMA expression_list
    (52) lower_bound -> . expression
    (82) expression -> . operand0
    (83) expression -> . conditional_expression
    (90) operand0 -> . operand1
    (91) operand0 -> . operand0 operator1 operand1
    (84) conditional_expression -> . IF expression then_expression else_expression FI
    (85) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (92) operand1 -> . operand2
    (93) operand1 -> . operand1 operator2 operand2
    (94) operand2 -> . operand3
    (95) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (96) operand3 -> . monadic_operator operand4
    (97) operand3 -> . operand4
    (104) monadic_operator -> . MINUS
    (105) monadic_operator -> . NOT
    (98) operand4 -> . array_location
    (99) operand4 -> . referenced_location
    (100) operand4 -> . primitive_value
    (81) array_location -> . location
    (106) referenced_location -> . ARROW array_location
    (123) primitive_value -> . literal
    (65) location -> . identifier
    (66) location -> . dereferenced_reference
    (67) location -> . string_element
    (68) location -> . string_slice
    (69) location -> . array_element
    (70) location -> . array_slice
    (124) literal -> . integer_literal
    (125) literal -> . boolean_literal
    (126) literal -> . character_literal
    (127) literal -> . empty_literal
    (128) literal -> . character_string_literal
    (22) identifier -> . ID
    (71) dereferenced_reference -> . array_location ARROW
    (72) string_element -> . identifier LBRACKET start_element LBRACKET
    (74) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (77) array_element -> . array_location LBRACKET expression_list RBRACKET
    (80) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (129) integer_literal -> . ICONST
    (130) boolean_literal -> . TRUE
    (131) boolean_literal -> . FALSE
    (132) character_literal -> . CCONST
    (133) empty_literal -> . NULL
    (134) character_string_literal -> . SCONST

    IF              shift and go to state 99
    MINUS           shift and go to state 90
    NOT             shift and go to state 96
    ARROW           shift and go to state 72
    ID              shift and go to state 15
    ICONST          shift and go to state 89
    TRUE            shift and go to state 87
    FALSE           shift and go to state 80
    CCONST          shift and go to state 91
    NULL            shift and go to state 97
    SCONST          shift and go to state 95

    monadic_operator               shift and go to state 93
    character_literal              shift and go to state 85
    character_string_literal       shift and go to state 94
    identifier                     shift and go to state 84
    array_location                 shift and go to state 73
    literal                        shift and go to state 74
    dereferenced_reference         shift and go to state 75
    lower_bound                    shift and go to state 161
    operand3                       shift and go to state 76
    integer_literal                shift and go to state 77
    array_slice                    shift and go to state 83
    primitive_value                shift and go to state 78
    referenced_location            shift and go to state 79
    string_slice                   shift and go to state 98
    string_element                 shift and go to state 81
    location                       shift and go to state 82
    expression_list                shift and go to state 162
    conditional_expression         shift and go to state 100
    operand2                       shift and go to state 103
    empty_literal                  shift and go to state 101
    operand1                       shift and go to state 86
    operand4                       shift and go to state 102
    expression                     shift and go to state 160
    boolean_literal                shift and go to state 104
    operand0                       shift and go to state 105
    array_element                  shift and go to state 92

state 125
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

    (72) string_element -> identifier LBRACKET . start_element LBRACKET
    (74) string_slice -> identifier LBRACKET . left_element COLON right_element RBRACKET
    (73) start_element -> . expression
    (75) left_element -> . expression
    (82) expression -> . operand0
    (83) expression -> . conditional_expression
    (90) operand0 -> . operand1
    (91) operand0 -> . operand0 operator1 operand1
    (84) conditional_expression -> . IF expression then_expression else_expression FI
    (85) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (92) operand1 -> . operand2
    (93) operand1 -> . operand1 operator2 operand2
    (94) operand2 -> . operand3
    (95) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (96) operand3 -> . monadic_operator operand4
    (97) operand3 -> . operand4
    (104) monadic_operator -> . MINUS
    (105) monadic_operator -> . NOT
    (98) operand4 -> . array_location
    (99) operand4 -> . referenced_location
    (100) operand4 -> . primitive_value
    (81) array_location -> . location
    (106) referenced_location -> . ARROW array_location
    (123) primitive_value -> . literal
    (65) location -> . identifier
    (66) location -> . dereferenced_reference
    (67) location -> . string_element
    (68) location -> . string_slice
    (69) location -> . array_element
    (70) location -> . array_slice
    (124) literal -> . integer_literal
    (125) literal -> . boolean_literal
    (126) literal -> . character_literal
    (127) literal -> . empty_literal
    (128) literal -> . character_string_literal
    (22) identifier -> . ID
    (71) dereferenced_reference -> . array_location ARROW
    (72) string_element -> . identifier LBRACKET start_element LBRACKET
    (74) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (77) array_element -> . array_location LBRACKET expression_list RBRACKET
    (80) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (129) integer_literal -> . ICONST
    (130) boolean_literal -> . TRUE
    (131) boolean_literal -> . FALSE
    (132) character_literal -> . CCONST
    (133) empty_literal -> . NULL
    (134) character_string_literal -> . SCONST

    IF              shift and go to state 99
    MINUS           shift and go to state 90
    NOT             shift and go to state 96
    ARROW           shift and go to state 72
    ID              shift and go to state 15
    ICONST          shift and go to state 89
    TRUE            shift and go to state 87
    FALSE           shift and go to state 80
    CCONST          shift and go to state 91
    NULL            shift and go to state 97
    SCONST          shift and go to state 95

    monadic_operator               shift and go to state 93
    character_literal              shift and go to state 85
    character_string_literal       shift and go to state 94
    start_element                  shift and go to state 165
    identifier                     shift and go to state 84
    array_location                 shift and go to state 73
    literal                        shift and go to state 74
    dereferenced_reference         shift and go to state 75
    operand3                       shift and go to state 76
    left_element                   shift and go to state 163
    integer_literal                shift and go to state 77
    location                       shift and go to state 82
    primitive_value                shift and go to state 78
    referenced_location            shift and go to state 79
    string_slice                   shift and go to state 98
    string_element                 shift and go to state 81
    conditional_expression         shift and go to state 100
    operand2                       shift and go to state 103
    empty_literal                  shift and go to state 101
    operand1                       shift and go to state 86
    operand4                       shift and go to state 102
    expression                     shift and go to state 164
    array_slice                    shift and go to state 83
    boolean_literal                shift and go to state 104
    operand0                       shift and go to state 105
    array_element                  shift and go to state 92

state 126

<<<<<<< HEAD
    (13) synonym_definition -> identifier_list ASSIGN . expression
    (73) expression -> . operand0
    (74) expression -> . conditional_expression
    (82) operand0 -> . operand1
    (83) operand0 -> . operand0 operator1 operand1
    (76) conditional_expression -> . IF expression then_expression else_expression FI
    (77) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (84) operand1 -> . operand2
    (85) operand1 -> . operand1 operator2 operand2
    (86) operand2 -> . operand3
    (87) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (88) operand3 -> . monadic_operator operand4
    (89) operand3 -> . operand4
    (96) monadic_operator -> . MINUS
    (97) monadic_operator -> . NOT
    (90) operand4 -> . array_location
    (91) operand4 -> . referenced_location
    (92) operand4 -> . primitive_value
    (72) array_location -> . location
    (98) referenced_location -> . ARROW array_location
    (115) primitive_value -> . literal
    (116) primitive_value -> . value_array_element
    (117) primitive_value -> . value_array_slice
    (118) primitive_value -> . parenthesized_expression
    (56) location -> . identifier
    (57) location -> . dereferenced_reference
    (58) location -> . string_element
    (59) location -> . string_slice
    (60) location -> . array_element
    (61) location -> . array_slice
    (119) literal -> . integer_literal
    (120) literal -> . boolean_literal
    (121) literal -> . character_literal
    (122) literal -> . empty_literal
    (123) literal -> . character_string_literal
    (124) value_array_element -> . primitive_value LBRACKET expression_list RBRACKET
    (125) value_array_slice -> . primitive_value LBRACKET expression COLON expression RBRACKET
    (75) parenthesized_expression -> . LPAREN expression RPAREN
    (22) identifier -> . ID
    (62) dereferenced_reference -> . array_location ARROW
    (63) string_element -> . identifier LBRACKET start_element LBRACKET
    (65) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (68) array_element -> . array_location LBRACKET expression_list RBRACKET
    (71) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (126) integer_literal -> . ICONST
    (127) boolean_literal -> . TRUE
    (128) boolean_literal -> . FALSE
    (129) character_literal -> . CCONST
    (130) empty_literal -> . NULL
    (131) character_string_literal -> . SCONST

    IF              shift and go to state 31
    MINUS           shift and go to state 36
    NOT             shift and go to state 35
    ARROW           shift and go to state 45
    LPAREN          shift and go to state 44
    ID              shift and go to state 21
    ICONST          shift and go to state 40
    TRUE            shift and go to state 55
    FALSE           shift and go to state 53
    CCONST          shift and go to state 34
    NULL            shift and go to state 27
    SCONST          shift and go to state 52

    location                       shift and go to state 6
    monadic_operator               shift and go to state 47
    operand2                       shift and go to state 49
    value_array_element            shift and go to state 48
    operand1                       shift and go to state 25
    expression                     shift and go to state 168
    conditional_expression         shift and go to state 28
    referenced_location            shift and go to state 29
    parenthesized_expression       shift and go to state 30
    integer_literal                shift and go to state 32
    empty_literal                  shift and go to state 50
    array_element                  shift and go to state 7
    operand3                       shift and go to state 33
    string_slice                   shift and go to state 3
    string_element                 shift and go to state 1
    boolean_literal                shift and go to state 51
    array_location                 shift and go to state 46
    literal                        shift and go to state 37
    operand0                       shift and go to state 38
    primitive_value                shift and go to state 39
    array_slice                    shift and go to state 15
    character_literal              shift and go to state 41
    value_array_slice              shift and go to state 42
    operand4                       shift and go to state 54
    character_string_literal       shift and go to state 43
    dereferenced_reference         shift and go to state 20
    identifier                     shift and go to state 56
=======
    (111) arithmetic_additive_operator -> PLUS .
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

    MINUS           reduce using rule 111 (arithmetic_additive_operator -> PLUS .)
    NOT             reduce using rule 111 (arithmetic_additive_operator -> PLUS .)
    ARROW           reduce using rule 111 (arithmetic_additive_operator -> PLUS .)
    ID              reduce using rule 111 (arithmetic_additive_operator -> PLUS .)
    ICONST          reduce using rule 111 (arithmetic_additive_operator -> PLUS .)
    TRUE            reduce using rule 111 (arithmetic_additive_operator -> PLUS .)
    FALSE           reduce using rule 111 (arithmetic_additive_operator -> PLUS .)
    CCONST          reduce using rule 111 (arithmetic_additive_operator -> PLUS .)
    NULL            reduce using rule 111 (arithmetic_additive_operator -> PLUS .)
    SCONST          reduce using rule 111 (arithmetic_additive_operator -> PLUS .)

<<<<<<< HEAD
    (35) discrete_mode -> discrete_range_mode .

    LPAREN          reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    COMMA           reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    SEMI            reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    RBRACKET        reduce using rule 35 (discrete_mode -> discrete_range_mode .)
    ASSIGN          reduce using rule 35 (discrete_mode -> discrete_range_mode .)
=======

state 127
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

    (93) operand1 -> operand1 operator2 . operand2
    (94) operand2 -> . operand3
    (95) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (96) operand3 -> . monadic_operator operand4
    (97) operand3 -> . operand4
    (104) monadic_operator -> . MINUS
    (105) monadic_operator -> . NOT
    (98) operand4 -> . array_location
    (99) operand4 -> . referenced_location
    (100) operand4 -> . primitive_value
    (81) array_location -> . location
    (106) referenced_location -> . ARROW array_location
    (123) primitive_value -> . literal
    (65) location -> . identifier
    (66) location -> . dereferenced_reference
    (67) location -> . string_element
    (68) location -> . string_slice
    (69) location -> . array_element
    (70) location -> . array_slice
    (124) literal -> . integer_literal
    (125) literal -> . boolean_literal
    (126) literal -> . character_literal
    (127) literal -> . empty_literal
    (128) literal -> . character_string_literal
    (22) identifier -> . ID
    (71) dereferenced_reference -> . array_location ARROW
    (72) string_element -> . identifier LBRACKET start_element LBRACKET
    (74) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (77) array_element -> . array_location LBRACKET expression_list RBRACKET
    (80) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (129) integer_literal -> . ICONST
    (130) boolean_literal -> . TRUE
    (131) boolean_literal -> . FALSE
    (132) character_literal -> . CCONST
    (133) empty_literal -> . NULL
    (134) character_string_literal -> . SCONST

    MINUS           shift and go to state 90
    NOT             shift and go to state 96
    ARROW           shift and go to state 72
    ID              shift and go to state 15
    ICONST          shift and go to state 89
    TRUE            shift and go to state 87
    FALSE           shift and go to state 80
    CCONST          shift and go to state 91
    NULL            shift and go to state 97
    SCONST          shift and go to state 95

    monadic_operator               shift and go to state 93
    character_string_literal       shift and go to state 94
    identifier                     shift and go to state 84
    literal                        shift and go to state 74
    dereferenced_reference         shift and go to state 75
    operand3                       shift and go to state 76
    integer_literal                shift and go to state 77
    array_slice                    shift and go to state 83
    referenced_location            shift and go to state 79
    string_slice                   shift and go to state 98
    string_element                 shift and go to state 81
    location                       shift and go to state 82
    array_location                 shift and go to state 73
    operand2                       shift and go to state 166
    character_literal              shift and go to state 85
    empty_literal                  shift and go to state 101
    operand4                       shift and go to state 102
    primitive_value                shift and go to state 78
    boolean_literal                shift and go to state 104
    array_element                  shift and go to state 92

state 128

<<<<<<< HEAD
    (28) mode -> discrete_mode .
    (41) discrete_range_mode -> discrete_mode . LPAREN literal_range RPAREN

    ASSIGN          reduce using rule 28 (mode -> discrete_mode .)
    COMMA           reduce using rule 28 (mode -> discrete_mode .)
    SEMI            reduce using rule 28 (mode -> discrete_mode .)
    LPAREN          shift and go to state 169
=======
    (109) operator2 -> arithmetic_additive_operator .

    MINUS           reduce using rule 109 (operator2 -> arithmetic_additive_operator .)
    NOT             reduce using rule 109 (operator2 -> arithmetic_additive_operator .)
    ARROW           reduce using rule 109 (operator2 -> arithmetic_additive_operator .)
    ID              reduce using rule 109 (operator2 -> arithmetic_additive_operator .)
    ICONST          reduce using rule 109 (operator2 -> arithmetic_additive_operator .)
    TRUE            reduce using rule 109 (operator2 -> arithmetic_additive_operator .)
    FALSE           reduce using rule 109 (operator2 -> arithmetic_additive_operator .)
    CCONST          reduce using rule 109 (operator2 -> arithmetic_additive_operator .)
    NULL            reduce using rule 109 (operator2 -> arithmetic_additive_operator .)
    SCONST          reduce using rule 109 (operator2 -> arithmetic_additive_operator .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 129

<<<<<<< HEAD
    (31) mode_name -> identifier .
    (36) discrete_mode_name -> identifier .

    ASSIGN          reduce using rule 31 (mode_name -> identifier .)
    COMMA           reduce using rule 31 (mode_name -> identifier .)
    SEMI            reduce using rule 31 (mode_name -> identifier .)
    LPAREN          reduce using rule 36 (discrete_mode_name -> identifier .)
=======
    (110) operator2 -> string_concatenation_operator .

    MINUS           reduce using rule 110 (operator2 -> string_concatenation_operator .)
    NOT             reduce using rule 110 (operator2 -> string_concatenation_operator .)
    ARROW           reduce using rule 110 (operator2 -> string_concatenation_operator .)
    ID              reduce using rule 110 (operator2 -> string_concatenation_operator .)
    ICONST          reduce using rule 110 (operator2 -> string_concatenation_operator .)
    TRUE            reduce using rule 110 (operator2 -> string_concatenation_operator .)
    FALSE           reduce using rule 110 (operator2 -> string_concatenation_operator .)
    CCONST          reduce using rule 110 (operator2 -> string_concatenation_operator .)
    NULL            reduce using rule 110 (operator2 -> string_concatenation_operator .)
    SCONST          reduce using rule 110 (operator2 -> string_concatenation_operator .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 130

<<<<<<< HEAD
    (38) boolean_mode -> BOOL .

    LPAREN          reduce using rule 38 (boolean_mode -> BOOL .)
    ASSIGN          reduce using rule 38 (boolean_mode -> BOOL .)
    COMMA           reduce using rule 38 (boolean_mode -> BOOL .)
    SEMI            reduce using rule 38 (boolean_mode -> BOOL .)
    RBRACKET        reduce using rule 38 (boolean_mode -> BOOL .)
=======
    (113) string_concatenation_operator -> CONCAT .

    MINUS           reduce using rule 113 (string_concatenation_operator -> CONCAT .)
    NOT             reduce using rule 113 (string_concatenation_operator -> CONCAT .)
    ARROW           reduce using rule 113 (string_concatenation_operator -> CONCAT .)
    ID              reduce using rule 113 (string_concatenation_operator -> CONCAT .)
    ICONST          reduce using rule 113 (string_concatenation_operator -> CONCAT .)
    TRUE            reduce using rule 113 (string_concatenation_operator -> CONCAT .)
    FALSE           reduce using rule 113 (string_concatenation_operator -> CONCAT .)
    CCONST          reduce using rule 113 (string_concatenation_operator -> CONCAT .)
    NULL            reduce using rule 113 (string_concatenation_operator -> CONCAT .)
    SCONST          reduce using rule 113 (string_concatenation_operator -> CONCAT .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 131

<<<<<<< HEAD
    (9) synonym_statement -> SYN synonym_list SEMI .

    DCL             reduce using rule 9 (synonym_statement -> SYN synonym_list SEMI .)
    SYN             reduce using rule 9 (synonym_statement -> SYN synonym_list SEMI .)
    TYPE            reduce using rule 9 (synonym_statement -> SYN synonym_list SEMI .)
    ID              reduce using rule 9 (synonym_statement -> SYN synonym_list SEMI .)
    IF              reduce using rule 9 (synonym_statement -> SYN synonym_list SEMI .)
    $end            reduce using rule 9 (synonym_statement -> SYN synonym_list SEMI .)
=======
    (112) arithmetic_additive_operator -> MINUS .

    MINUS           reduce using rule 112 (arithmetic_additive_operator -> MINUS .)
    NOT             reduce using rule 112 (arithmetic_additive_operator -> MINUS .)
    ARROW           reduce using rule 112 (arithmetic_additive_operator -> MINUS .)
    ID              reduce using rule 112 (arithmetic_additive_operator -> MINUS .)
    ICONST          reduce using rule 112 (arithmetic_additive_operator -> MINUS .)
    TRUE            reduce using rule 112 (arithmetic_additive_operator -> MINUS .)
    FALSE           reduce using rule 112 (arithmetic_additive_operator -> MINUS .)
    CCONST          reduce using rule 112 (arithmetic_additive_operator -> MINUS .)
    NULL            reduce using rule 112 (arithmetic_additive_operator -> MINUS .)
    SCONST          reduce using rule 112 (arithmetic_additive_operator -> MINUS .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 132

<<<<<<< HEAD
    (138) assigning_operator -> closed_dyadic_operator ASSIGN .

    IF              reduce using rule 138 (assigning_operator -> closed_dyadic_operator ASSIGN .)
    MINUS           reduce using rule 138 (assigning_operator -> closed_dyadic_operator ASSIGN .)
    NOT             reduce using rule 138 (assigning_operator -> closed_dyadic_operator ASSIGN .)
    ARROW           reduce using rule 138 (assigning_operator -> closed_dyadic_operator ASSIGN .)
    LPAREN          reduce using rule 138 (assigning_operator -> closed_dyadic_operator ASSIGN .)
    ID              reduce using rule 138 (assigning_operator -> closed_dyadic_operator ASSIGN .)
    ICONST          reduce using rule 138 (assigning_operator -> closed_dyadic_operator ASSIGN .)
    TRUE            reduce using rule 138 (assigning_operator -> closed_dyadic_operator ASSIGN .)
    FALSE           reduce using rule 138 (assigning_operator -> closed_dyadic_operator ASSIGN .)
    CCONST          reduce using rule 138 (assigning_operator -> closed_dyadic_operator ASSIGN .)
    NULL            reduce using rule 138 (assigning_operator -> closed_dyadic_operator ASSIGN .)
    SCONST          reduce using rule 138 (assigning_operator -> closed_dyadic_operator ASSIGN .)
=======
    (96) operand3 -> monadic_operator operand4 .

    TIMES           reduce using rule 96 (operand3 -> monadic_operator operand4 .)
    DIVIDE          reduce using rule 96 (operand3 -> monadic_operator operand4 .)
    MODULO          reduce using rule 96 (operand3 -> monadic_operator operand4 .)
    PLUS            reduce using rule 96 (operand3 -> monadic_operator operand4 .)
    MINUS           reduce using rule 96 (operand3 -> monadic_operator operand4 .)
    CONCAT          reduce using rule 96 (operand3 -> monadic_operator operand4 .)
    AND             reduce using rule 96 (operand3 -> monadic_operator operand4 .)
    OR              reduce using rule 96 (operand3 -> monadic_operator operand4 .)
    EQUAL           reduce using rule 96 (operand3 -> monadic_operator operand4 .)
    NOTEQ           reduce using rule 96 (operand3 -> monadic_operator operand4 .)
    GREATER         reduce using rule 96 (operand3 -> monadic_operator operand4 .)
    GTEQUAL         reduce using rule 96 (operand3 -> monadic_operator operand4 .)
    LESS            reduce using rule 96 (operand3 -> monadic_operator operand4 .)
    LTEQUAL         reduce using rule 96 (operand3 -> monadic_operator operand4 .)
    IN              reduce using rule 96 (operand3 -> monadic_operator operand4 .)
    FI              reduce using rule 96 (operand3 -> monadic_operator operand4 .)
    COMMA           reduce using rule 96 (operand3 -> monadic_operator operand4 .)
    SEMI            reduce using rule 96 (operand3 -> monadic_operator operand4 .)
    COLON           reduce using rule 96 (operand3 -> monadic_operator operand4 .)
    THEN            reduce using rule 96 (operand3 -> monadic_operator operand4 .)
    RBRACKET        reduce using rule 96 (operand3 -> monadic_operator operand4 .)
    LBRACKET        reduce using rule 96 (operand3 -> monadic_operator operand4 .)
    RPAREN          reduce using rule 96 (operand3 -> monadic_operator operand4 .)
    ELSE            reduce using rule 96 (operand3 -> monadic_operator operand4 .)
    ELSIF           reduce using rule 96 (operand3 -> monadic_operator operand4 .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 133

<<<<<<< HEAD
    (137) assignment_action -> array_location assigning_operator expression .

    DCL             reduce using rule 137 (assignment_action -> array_location assigning_operator expression .)
    SYN             reduce using rule 137 (assignment_action -> array_location assigning_operator expression .)
    TYPE            reduce using rule 137 (assignment_action -> array_location assigning_operator expression .)
    ID              reduce using rule 137 (assignment_action -> array_location assigning_operator expression .)
    IF              reduce using rule 137 (assignment_action -> array_location assigning_operator expression .)
    $end            reduce using rule 137 (assignment_action -> array_location assigning_operator expression .)
    FI              reduce using rule 137 (assignment_action -> array_location assigning_operator expression .)
    ELSE            reduce using rule 137 (assignment_action -> array_location assigning_operator expression .)
    ELSIF           reduce using rule 137 (assignment_action -> array_location assigning_operator expression .)

=======
    (84) conditional_expression -> IF expression . then_expression else_expression FI
    (85) conditional_expression -> IF expression . then_expression elsif_expression else_expression FI
    (86) then_expression -> . THEN expression
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

    THEN            shift and go to state 167

<<<<<<< HEAD
    (69) expression_list -> expression .
    (70) expression_list -> expression . COMMA expression_list
    (43) lower_bound -> expression .

    RBRACKET        reduce using rule 69 (expression_list -> expression .)
    COMMA           shift and go to state 170
    COLON           reduce using rule 43 (lower_bound -> expression .)
=======
    then_expression                shift and go to state 168

state 134
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

    (102) arithmetic_multiplicative_operator -> DIVIDE .

    MINUS           reduce using rule 102 (arithmetic_multiplicative_operator -> DIVIDE .)
    NOT             reduce using rule 102 (arithmetic_multiplicative_operator -> DIVIDE .)
    ARROW           reduce using rule 102 (arithmetic_multiplicative_operator -> DIVIDE .)
    ID              reduce using rule 102 (arithmetic_multiplicative_operator -> DIVIDE .)
    ICONST          reduce using rule 102 (arithmetic_multiplicative_operator -> DIVIDE .)
    TRUE            reduce using rule 102 (arithmetic_multiplicative_operator -> DIVIDE .)
    FALSE           reduce using rule 102 (arithmetic_multiplicative_operator -> DIVIDE .)
    CCONST          reduce using rule 102 (arithmetic_multiplicative_operator -> DIVIDE .)
    NULL            reduce using rule 102 (arithmetic_multiplicative_operator -> DIVIDE .)
    SCONST          reduce using rule 102 (arithmetic_multiplicative_operator -> DIVIDE .)

<<<<<<< HEAD
    (68) array_element -> array_location LBRACKET expression_list . RBRACKET

    RBRACKET        shift and go to state 171
=======

state 135
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

    (95) operand2 -> operand2 arithmetic_multiplicative_operator . operand3
    (96) operand3 -> . monadic_operator operand4
    (97) operand3 -> . operand4
    (104) monadic_operator -> . MINUS
    (105) monadic_operator -> . NOT
    (98) operand4 -> . array_location
    (99) operand4 -> . referenced_location
    (100) operand4 -> . primitive_value
    (81) array_location -> . location
    (106) referenced_location -> . ARROW array_location
    (123) primitive_value -> . literal
    (65) location -> . identifier
    (66) location -> . dereferenced_reference
    (67) location -> . string_element
    (68) location -> . string_slice
    (69) location -> . array_element
    (70) location -> . array_slice
    (124) literal -> . integer_literal
    (125) literal -> . boolean_literal
    (126) literal -> . character_literal
    (127) literal -> . empty_literal
    (128) literal -> . character_string_literal
    (22) identifier -> . ID
    (71) dereferenced_reference -> . array_location ARROW
    (72) string_element -> . identifier LBRACKET start_element LBRACKET
    (74) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (77) array_element -> . array_location LBRACKET expression_list RBRACKET
    (80) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (129) integer_literal -> . ICONST
    (130) boolean_literal -> . TRUE
    (131) boolean_literal -> . FALSE
    (132) character_literal -> . CCONST
    (133) empty_literal -> . NULL
    (134) character_string_literal -> . SCONST

    MINUS           shift and go to state 90
    NOT             shift and go to state 96
    ARROW           shift and go to state 72
    ID              shift and go to state 15
    ICONST          shift and go to state 89
    TRUE            shift and go to state 87
    FALSE           shift and go to state 80
    CCONST          shift and go to state 91
    NULL            shift and go to state 97
    SCONST          shift and go to state 95

    monadic_operator               shift and go to state 93
    character_string_literal       shift and go to state 94
    identifier                     shift and go to state 84
    array_location                 shift and go to state 73
    literal                        shift and go to state 74
    dereferenced_reference         shift and go to state 75
    operand3                       shift and go to state 169
    integer_literal                shift and go to state 77
    array_slice                    shift and go to state 83
    referenced_location            shift and go to state 79
    string_slice                   shift and go to state 98
    string_element                 shift and go to state 81
    location                       shift and go to state 82
    character_literal              shift and go to state 85
    empty_literal                  shift and go to state 101
    operand4                       shift and go to state 102
    primitive_value                shift and go to state 78
    boolean_literal                shift and go to state 104
    array_element                  shift and go to state 92

state 136

<<<<<<< HEAD
    (71) array_slice -> array_location LBRACKET lower_bound . COLON upper_bound RBRACKET

    COLON           shift and go to state 172
=======
    (103) arithmetic_multiplicative_operator -> MODULO .

    MINUS           reduce using rule 103 (arithmetic_multiplicative_operator -> MODULO .)
    NOT             reduce using rule 103 (arithmetic_multiplicative_operator -> MODULO .)
    ARROW           reduce using rule 103 (arithmetic_multiplicative_operator -> MODULO .)
    ID              reduce using rule 103 (arithmetic_multiplicative_operator -> MODULO .)
    ICONST          reduce using rule 103 (arithmetic_multiplicative_operator -> MODULO .)
    TRUE            reduce using rule 103 (arithmetic_multiplicative_operator -> MODULO .)
    FALSE           reduce using rule 103 (arithmetic_multiplicative_operator -> MODULO .)
    CCONST          reduce using rule 103 (arithmetic_multiplicative_operator -> MODULO .)
    NULL            reduce using rule 103 (arithmetic_multiplicative_operator -> MODULO .)
    SCONST          reduce using rule 103 (arithmetic_multiplicative_operator -> MODULO .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 137

<<<<<<< HEAD
    (23) newmode_statement -> TYPE newmode_list SEMI .

    DCL             reduce using rule 23 (newmode_statement -> TYPE newmode_list SEMI .)
    SYN             reduce using rule 23 (newmode_statement -> TYPE newmode_list SEMI .)
    TYPE            reduce using rule 23 (newmode_statement -> TYPE newmode_list SEMI .)
    ID              reduce using rule 23 (newmode_statement -> TYPE newmode_list SEMI .)
    IF              reduce using rule 23 (newmode_statement -> TYPE newmode_list SEMI .)
    $end            reduce using rule 23 (newmode_statement -> TYPE newmode_list SEMI .)
=======
    (101) arithmetic_multiplicative_operator -> TIMES .

    MINUS           reduce using rule 101 (arithmetic_multiplicative_operator -> TIMES .)
    NOT             reduce using rule 101 (arithmetic_multiplicative_operator -> TIMES .)
    ARROW           reduce using rule 101 (arithmetic_multiplicative_operator -> TIMES .)
    ID              reduce using rule 101 (arithmetic_multiplicative_operator -> TIMES .)
    ICONST          reduce using rule 101 (arithmetic_multiplicative_operator -> TIMES .)
    TRUE            reduce using rule 101 (arithmetic_multiplicative_operator -> TIMES .)
    FALSE           reduce using rule 101 (arithmetic_multiplicative_operator -> TIMES .)
    CCONST          reduce using rule 101 (arithmetic_multiplicative_operator -> TIMES .)
    NULL            reduce using rule 101 (arithmetic_multiplicative_operator -> TIMES .)
    SCONST          reduce using rule 101 (arithmetic_multiplicative_operator -> TIMES .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 138

<<<<<<< HEAD
    (25) newmode_list -> mode_definition COMMA . newmode_list
    (24) newmode_list -> . mode_definition
    (25) newmode_list -> . mode_definition COMMA newmode_list
    (26) mode_definition -> . identifier_list ASSIGN mode
    (20) identifier_list -> . identifier
    (21) identifier_list -> . identifier COMMA identifier_list
    (22) identifier -> . ID

    ID              shift and go to state 21
=======
    (118) relational_operator -> GREATER .

    MINUS           reduce using rule 118 (relational_operator -> GREATER .)
    NOT             reduce using rule 118 (relational_operator -> GREATER .)
    ARROW           reduce using rule 118 (relational_operator -> GREATER .)
    ID              reduce using rule 118 (relational_operator -> GREATER .)
    ICONST          reduce using rule 118 (relational_operator -> GREATER .)
    TRUE            reduce using rule 118 (relational_operator -> GREATER .)
    FALSE           reduce using rule 118 (relational_operator -> GREATER .)
    CCONST          reduce using rule 118 (relational_operator -> GREATER .)
    NULL            reduce using rule 118 (relational_operator -> GREATER .)
    SCONST          reduce using rule 118 (relational_operator -> GREATER .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

    newmode_list                   shift and go to state 173
    identifier_list                shift and go to state 77
    identifier                     shift and go to state 57
    mode_definition                shift and go to state 76

state 139

<<<<<<< HEAD
    (26) mode_definition -> identifier_list ASSIGN . mode
    (27) mode -> . mode_name
    (28) mode -> . discrete_mode
    (29) mode -> . reference_mode
    (30) mode -> . composite_mode
    (31) mode_name -> . identifier
    (32) discrete_mode -> . integer_mode
    (33) discrete_mode -> . boolean_mode
    (34) discrete_mode -> . character_mode
    (35) discrete_mode -> . discrete_range_mode
    (45) reference_mode -> . REF mode
    (46) composite_mode -> . string_mode
    (47) composite_mode -> . array_mode
    (22) identifier -> . ID
    (37) integer_mode -> . INT
    (38) boolean_mode -> . BOOL
    (39) character_mode -> . CHAR
    (40) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (41) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (48) string_mode -> . CHARS LBRACKET string_length RBRACKET
    (50) array_mode -> . ARRAY LBRACKET index_mode_list RBRACKET element_mode
    (36) discrete_mode_name -> . identifier

    REF             shift and go to state 118
    ID              shift and go to state 21
    INT             shift and go to state 119
    BOOL            shift and go to state 130
    CHAR            shift and go to state 112
    CHARS           shift and go to state 125
    ARRAY           shift and go to state 121

    string_mode                    shift and go to state 111
    mode                           shift and go to state 174
    reference_mode                 shift and go to state 114
    boolean_mode                   shift and go to state 122
    composite_mode                 shift and go to state 123
    integer_mode                   shift and go to state 117
    character_mode                 shift and go to state 124
    mode_name                      shift and go to state 120
    array_mode                     shift and go to state 115
    discrete_range_mode            shift and go to state 127
    discrete_mode                  shift and go to state 128
    discrete_mode_name             shift and go to state 116
    identifier                     shift and go to state 129

state 140

    (16) declaration_list -> declaration COMMA . declaration_list
    (15) declaration_list -> . declaration
    (16) declaration_list -> . declaration COMMA declaration_list
    (17) declaration -> . identifier_list mode initialization
    (18) declaration -> . identifier_list mode
    (20) identifier_list -> . identifier
    (21) identifier_list -> . identifier COMMA identifier_list
    (22) identifier -> . ID

    ID              shift and go to state 21
=======
    (114) relational_operator -> AND .

    MINUS           reduce using rule 114 (relational_operator -> AND .)
    NOT             reduce using rule 114 (relational_operator -> AND .)
    ARROW           reduce using rule 114 (relational_operator -> AND .)
    ID              reduce using rule 114 (relational_operator -> AND .)
    ICONST          reduce using rule 114 (relational_operator -> AND .)
    TRUE            reduce using rule 114 (relational_operator -> AND .)
    FALSE           reduce using rule 114 (relational_operator -> AND .)
    CCONST          reduce using rule 114 (relational_operator -> AND .)
    NULL            reduce using rule 114 (relational_operator -> AND .)
    SCONST          reduce using rule 114 (relational_operator -> AND .)


state 140

    (119) relational_operator -> GTEQUAL .

    MINUS           reduce using rule 119 (relational_operator -> GTEQUAL .)
    NOT             reduce using rule 119 (relational_operator -> GTEQUAL .)
    ARROW           reduce using rule 119 (relational_operator -> GTEQUAL .)
    ID              reduce using rule 119 (relational_operator -> GTEQUAL .)
    ICONST          reduce using rule 119 (relational_operator -> GTEQUAL .)
    TRUE            reduce using rule 119 (relational_operator -> GTEQUAL .)
    FALSE           reduce using rule 119 (relational_operator -> GTEQUAL .)
    CCONST          reduce using rule 119 (relational_operator -> GTEQUAL .)
    NULL            reduce using rule 119 (relational_operator -> GTEQUAL .)
    SCONST          reduce using rule 119 (relational_operator -> GTEQUAL .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

    declaration                    shift and go to state 78
    declaration_list               shift and go to state 175
    identifier_list                shift and go to state 80
    identifier                     shift and go to state 57

state 141

<<<<<<< HEAD
    (14) declaration_statement -> DCL declaration_list SEMI .

    DCL             reduce using rule 14 (declaration_statement -> DCL declaration_list SEMI .)
    SYN             reduce using rule 14 (declaration_statement -> DCL declaration_list SEMI .)
    TYPE            reduce using rule 14 (declaration_statement -> DCL declaration_list SEMI .)
    ID              reduce using rule 14 (declaration_statement -> DCL declaration_list SEMI .)
    IF              reduce using rule 14 (declaration_statement -> DCL declaration_list SEMI .)
    $end            reduce using rule 14 (declaration_statement -> DCL declaration_list SEMI .)
=======
    (115) relational_operator -> OR .

    MINUS           reduce using rule 115 (relational_operator -> OR .)
    NOT             reduce using rule 115 (relational_operator -> OR .)
    ARROW           reduce using rule 115 (relational_operator -> OR .)
    ID              reduce using rule 115 (relational_operator -> OR .)
    ICONST          reduce using rule 115 (relational_operator -> OR .)
    TRUE            reduce using rule 115 (relational_operator -> OR .)
    FALSE           reduce using rule 115 (relational_operator -> OR .)
    CCONST          reduce using rule 115 (relational_operator -> OR .)
    NULL            reduce using rule 115 (relational_operator -> OR .)
    SCONST          reduce using rule 115 (relational_operator -> OR .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 142

<<<<<<< HEAD
    (17) declaration -> identifier_list mode . initialization
    (18) declaration -> identifier_list mode .
    (19) initialization -> . ASSIGN expression

    COMMA           reduce using rule 18 (declaration -> identifier_list mode .)
    SEMI            reduce using rule 18 (declaration -> identifier_list mode .)
    ASSIGN          shift and go to state 177
=======
    (108) operator1 -> membership_operator .

    MINUS           reduce using rule 108 (operator1 -> membership_operator .)
    NOT             reduce using rule 108 (operator1 -> membership_operator .)
    ARROW           reduce using rule 108 (operator1 -> membership_operator .)
    ID              reduce using rule 108 (operator1 -> membership_operator .)
    ICONST          reduce using rule 108 (operator1 -> membership_operator .)
    TRUE            reduce using rule 108 (operator1 -> membership_operator .)
    FALSE           reduce using rule 108 (operator1 -> membership_operator .)
    CCONST          reduce using rule 108 (operator1 -> membership_operator .)
    NULL            reduce using rule 108 (operator1 -> membership_operator .)
    SCONST          reduce using rule 108 (operator1 -> membership_operator .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

    initialization                 shift and go to state 176

state 143

<<<<<<< HEAD
    (3) statement_nullable -> statement statement_nullable .

    $end            reduce using rule 3 (statement_nullable -> statement statement_nullable .)

=======
    (120) relational_operator -> LESS .
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

    MINUS           reduce using rule 120 (relational_operator -> LESS .)
    NOT             reduce using rule 120 (relational_operator -> LESS .)
    ARROW           reduce using rule 120 (relational_operator -> LESS .)
    ID              reduce using rule 120 (relational_operator -> LESS .)
    ICONST          reduce using rule 120 (relational_operator -> LESS .)
    TRUE            reduce using rule 120 (relational_operator -> LESS .)
    FALSE           reduce using rule 120 (relational_operator -> LESS .)
    CCONST          reduce using rule 120 (relational_operator -> LESS .)
    NULL            reduce using rule 120 (relational_operator -> LESS .)
    SCONST          reduce using rule 120 (relational_operator -> LESS .)

<<<<<<< HEAD
    (132) action_statement -> identifier COLON action .

    ELSE            reduce using rule 132 (action_statement -> identifier COLON action .)
    ELSIF           reduce using rule 132 (action_statement -> identifier COLON action .)
    DCL             reduce using rule 132 (action_statement -> identifier COLON action .)
    SYN             reduce using rule 132 (action_statement -> identifier COLON action .)
    TYPE            reduce using rule 132 (action_statement -> identifier COLON action .)
    ID              reduce using rule 132 (action_statement -> identifier COLON action .)
    IF              reduce using rule 132 (action_statement -> identifier COLON action .)
    $end            reduce using rule 132 (action_statement -> identifier COLON action .)
    FI              reduce using rule 132 (action_statement -> identifier COLON action .)
=======

state 144
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

    (91) operand0 -> operand0 operator1 . operand1
    (92) operand1 -> . operand2
    (93) operand1 -> . operand1 operator2 operand2
    (94) operand2 -> . operand3
    (95) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (96) operand3 -> . monadic_operator operand4
    (97) operand3 -> . operand4
    (104) monadic_operator -> . MINUS
    (105) monadic_operator -> . NOT
    (98) operand4 -> . array_location
    (99) operand4 -> . referenced_location
    (100) operand4 -> . primitive_value
    (81) array_location -> . location
    (106) referenced_location -> . ARROW array_location
    (123) primitive_value -> . literal
    (65) location -> . identifier
    (66) location -> . dereferenced_reference
    (67) location -> . string_element
    (68) location -> . string_slice
    (69) location -> . array_element
    (70) location -> . array_slice
    (124) literal -> . integer_literal
    (125) literal -> . boolean_literal
    (126) literal -> . character_literal
    (127) literal -> . empty_literal
    (128) literal -> . character_string_literal
    (22) identifier -> . ID
    (71) dereferenced_reference -> . array_location ARROW
    (72) string_element -> . identifier LBRACKET start_element LBRACKET
    (74) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (77) array_element -> . array_location LBRACKET expression_list RBRACKET
    (80) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (129) integer_literal -> . ICONST
    (130) boolean_literal -> . TRUE
    (131) boolean_literal -> . FALSE
    (132) character_literal -> . CCONST
    (133) empty_literal -> . NULL
    (134) character_string_literal -> . SCONST

    MINUS           shift and go to state 90
    NOT             shift and go to state 96
    ARROW           shift and go to state 72
    ID              shift and go to state 15
    ICONST          shift and go to state 89
    TRUE            shift and go to state 87
    FALSE           shift and go to state 80
    CCONST          shift and go to state 91
    NULL            shift and go to state 97
    SCONST          shift and go to state 95

    monadic_operator               shift and go to state 93
    character_literal              shift and go to state 85
    character_string_literal       shift and go to state 94
    identifier                     shift and go to state 84
    literal                        shift and go to state 74
    dereferenced_reference         shift and go to state 75
    operand3                       shift and go to state 76
    integer_literal                shift and go to state 77
    array_slice                    shift and go to state 83
    referenced_location            shift and go to state 79
    string_slice                   shift and go to state 98
    string_element                 shift and go to state 81
    location                       shift and go to state 82
    operand2                       shift and go to state 103
    array_location                 shift and go to state 73
    empty_literal                  shift and go to state 101
    operand1                       shift and go to state 170
    operand4                       shift and go to state 102
    primitive_value                shift and go to state 78
    boolean_literal                shift and go to state 104
    array_element                  shift and go to state 92

state 145

<<<<<<< HEAD
    (64) start_element -> expression .
    (66) left_element -> expression .

    LBRACKET        reduce using rule 64 (start_element -> expression .)
    COLON           reduce using rule 66 (left_element -> expression .)
=======
    (107) operator1 -> relational_operator .

    MINUS           reduce using rule 107 (operator1 -> relational_operator .)
    NOT             reduce using rule 107 (operator1 -> relational_operator .)
    ARROW           reduce using rule 107 (operator1 -> relational_operator .)
    ID              reduce using rule 107 (operator1 -> relational_operator .)
    ICONST          reduce using rule 107 (operator1 -> relational_operator .)
    TRUE            reduce using rule 107 (operator1 -> relational_operator .)
    FALSE           reduce using rule 107 (operator1 -> relational_operator .)
    CCONST          reduce using rule 107 (operator1 -> relational_operator .)
    NULL            reduce using rule 107 (operator1 -> relational_operator .)
    SCONST          reduce using rule 107 (operator1 -> relational_operator .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 146

<<<<<<< HEAD
    (65) string_slice -> identifier LBRACKET left_element . COLON right_element RBRACKET

    COLON           shift and go to state 178
=======
    (117) relational_operator -> NOTEQ .

    MINUS           reduce using rule 117 (relational_operator -> NOTEQ .)
    NOT             reduce using rule 117 (relational_operator -> NOTEQ .)
    ARROW           reduce using rule 117 (relational_operator -> NOTEQ .)
    ID              reduce using rule 117 (relational_operator -> NOTEQ .)
    ICONST          reduce using rule 117 (relational_operator -> NOTEQ .)
    TRUE            reduce using rule 117 (relational_operator -> NOTEQ .)
    FALSE           reduce using rule 117 (relational_operator -> NOTEQ .)
    CCONST          reduce using rule 117 (relational_operator -> NOTEQ .)
    NULL            reduce using rule 117 (relational_operator -> NOTEQ .)
    SCONST          reduce using rule 117 (relational_operator -> NOTEQ .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 147

<<<<<<< HEAD
    (63) string_element -> identifier LBRACKET start_element . LBRACKET

    LBRACKET        shift and go to state 179
=======
    (116) relational_operator -> EQUAL .

    MINUS           reduce using rule 116 (relational_operator -> EQUAL .)
    NOT             reduce using rule 116 (relational_operator -> EQUAL .)
    ARROW           reduce using rule 116 (relational_operator -> EQUAL .)
    ID              reduce using rule 116 (relational_operator -> EQUAL .)
    ICONST          reduce using rule 116 (relational_operator -> EQUAL .)
    TRUE            reduce using rule 116 (relational_operator -> EQUAL .)
    FALSE           reduce using rule 116 (relational_operator -> EQUAL .)
    CCONST          reduce using rule 116 (relational_operator -> EQUAL .)
    NULL            reduce using rule 116 (relational_operator -> EQUAL .)
    SCONST          reduce using rule 116 (relational_operator -> EQUAL .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 148

<<<<<<< HEAD
    (85) operand1 -> operand1 operator2 operand2 .
    (87) operand2 -> operand2 . arithmetic_multiplicative_operator operand3
    (93) arithmetic_multiplicative_operator -> . TIMES
    (94) arithmetic_multiplicative_operator -> . DIVIDE
    (95) arithmetic_multiplicative_operator -> . MODULO

    PLUS            reduce using rule 85 (operand1 -> operand1 operator2 operand2 .)
    MINUS           reduce using rule 85 (operand1 -> operand1 operator2 operand2 .)
    CONCAT          reduce using rule 85 (operand1 -> operand1 operator2 operand2 .)
    AND             reduce using rule 85 (operand1 -> operand1 operator2 operand2 .)
    OR              reduce using rule 85 (operand1 -> operand1 operator2 operand2 .)
    EQUAL           reduce using rule 85 (operand1 -> operand1 operator2 operand2 .)
    NOTEQ           reduce using rule 85 (operand1 -> operand1 operator2 operand2 .)
    GREATER         reduce using rule 85 (operand1 -> operand1 operator2 operand2 .)
    GTEQUAL         reduce using rule 85 (operand1 -> operand1 operator2 operand2 .)
    LESS            reduce using rule 85 (operand1 -> operand1 operator2 operand2 .)
    LTEQUAL         reduce using rule 85 (operand1 -> operand1 operator2 operand2 .)
    IN              reduce using rule 85 (operand1 -> operand1 operator2 operand2 .)
    COLON           reduce using rule 85 (operand1 -> operand1 operator2 operand2 .)
    COMMA           reduce using rule 85 (operand1 -> operand1 operator2 operand2 .)
    SEMI            reduce using rule 85 (operand1 -> operand1 operator2 operand2 .)
    THEN            reduce using rule 85 (operand1 -> operand1 operator2 operand2 .)
    RBRACKET        reduce using rule 85 (operand1 -> operand1 operator2 operand2 .)
    FI              reduce using rule 85 (operand1 -> operand1 operator2 operand2 .)
    LBRACKET        reduce using rule 85 (operand1 -> operand1 operator2 operand2 .)
    ELSE            reduce using rule 85 (operand1 -> operand1 operator2 operand2 .)
    ELSIF           reduce using rule 85 (operand1 -> operand1 operator2 operand2 .)
    DCL             reduce using rule 85 (operand1 -> operand1 operator2 operand2 .)
    SYN             reduce using rule 85 (operand1 -> operand1 operator2 operand2 .)
    TYPE            reduce using rule 85 (operand1 -> operand1 operator2 operand2 .)
    ID              reduce using rule 85 (operand1 -> operand1 operator2 operand2 .)
    IF              reduce using rule 85 (operand1 -> operand1 operator2 operand2 .)
    $end            reduce using rule 85 (operand1 -> operand1 operator2 operand2 .)
    RPAREN          reduce using rule 85 (operand1 -> operand1 operator2 operand2 .)
    TIMES           shift and go to state 73
    DIVIDE          shift and go to state 70
    MODULO          shift and go to state 72

    arithmetic_multiplicative_operator shift and go to state 108

state 149

    (146) else_clause -> ELSE . action_statement_list
    (149) action_statement_list -> . action_statement action_statement_nullable
    (132) action_statement -> . identifier COLON action
    (133) action_statement -> . action
    (22) identifier -> . ID
    (134) action -> . bracketed_action
    (135) action -> . assignment_action
    (136) bracketed_action -> . if_action
    (137) assignment_action -> . array_location assigning_operator expression
    (143) if_action -> . IF expression then_clause else_clause FI
    (144) if_action -> . IF expression then_clause
    (72) array_location -> . location
    (56) location -> . identifier
    (57) location -> . dereferenced_reference
    (58) location -> . string_element
    (59) location -> . string_slice
    (60) location -> . array_element
    (61) location -> . array_slice
    (62) dereferenced_reference -> . array_location ARROW
    (63) string_element -> . identifier LBRACKET start_element LBRACKET
    (65) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (68) array_element -> . array_location LBRACKET expression_list RBRACKET
    (71) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET

    ID              shift and go to state 21
    IF              shift and go to state 4

    action_statement_list          shift and go to state 180
    location                       shift and go to state 6
    string_element                 shift and go to state 1
    string_slice                   shift and go to state 3
    array_slice                    shift and go to state 15
    if_action                      shift and go to state 17
    array_location                 shift and go to state 13
    array_element                  shift and go to state 7
    action                         shift and go to state 8
    bracketed_action               shift and go to state 22
    action_statement               shift and go to state 153
    assignment_action              shift and go to state 11
    dereferenced_reference         shift and go to state 20
    identifier                     shift and go to state 24

state 150

    (143) if_action -> IF expression then_clause else_clause . FI

    FI              shift and go to state 181
=======
    (122) membership_operator -> IN .

    MINUS           reduce using rule 122 (membership_operator -> IN .)
    NOT             reduce using rule 122 (membership_operator -> IN .)
    ARROW           reduce using rule 122 (membership_operator -> IN .)
    ID              reduce using rule 122 (membership_operator -> IN .)
    ICONST          reduce using rule 122 (membership_operator -> IN .)
    TRUE            reduce using rule 122 (membership_operator -> IN .)
    FALSE           reduce using rule 122 (membership_operator -> IN .)
    CCONST          reduce using rule 122 (membership_operator -> IN .)
    NULL            reduce using rule 122 (membership_operator -> IN .)
    SCONST          reduce using rule 122 (membership_operator -> IN .)


state 149

    (121) relational_operator -> LTEQUAL .

    MINUS           reduce using rule 121 (relational_operator -> LTEQUAL .)
    NOT             reduce using rule 121 (relational_operator -> LTEQUAL .)
    ARROW           reduce using rule 121 (relational_operator -> LTEQUAL .)
    ID              reduce using rule 121 (relational_operator -> LTEQUAL .)
    ICONST          reduce using rule 121 (relational_operator -> LTEQUAL .)
    TRUE            reduce using rule 121 (relational_operator -> LTEQUAL .)
    FALSE           reduce using rule 121 (relational_operator -> LTEQUAL .)
    CCONST          reduce using rule 121 (relational_operator -> LTEQUAL .)
    NULL            reduce using rule 121 (relational_operator -> LTEQUAL .)
    SCONST          reduce using rule 121 (relational_operator -> LTEQUAL .)


state 150

    (12) synonym_definition -> identifier_list mode ASSIGN expression .

    COMMA           reduce using rule 12 (synonym_definition -> identifier_list mode ASSIGN expression .)
    SEMI            reduce using rule 12 (synonym_definition -> identifier_list mode ASSIGN expression .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 151

<<<<<<< HEAD
    (147) else_clause -> ELSIF . expression then_clause else_clause
    (148) else_clause -> ELSIF . expression then_clause
    (73) expression -> . operand0
    (74) expression -> . conditional_expression
    (82) operand0 -> . operand1
    (83) operand0 -> . operand0 operator1 operand1
    (76) conditional_expression -> . IF expression then_expression else_expression FI
    (77) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (84) operand1 -> . operand2
    (85) operand1 -> . operand1 operator2 operand2
    (86) operand2 -> . operand3
    (87) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (88) operand3 -> . monadic_operator operand4
    (89) operand3 -> . operand4
    (96) monadic_operator -> . MINUS
    (97) monadic_operator -> . NOT
    (90) operand4 -> . array_location
    (91) operand4 -> . referenced_location
    (92) operand4 -> . primitive_value
    (72) array_location -> . location
    (98) referenced_location -> . ARROW array_location
    (115) primitive_value -> . literal
    (116) primitive_value -> . value_array_element
    (117) primitive_value -> . value_array_slice
    (118) primitive_value -> . parenthesized_expression
    (56) location -> . identifier
    (57) location -> . dereferenced_reference
    (58) location -> . string_element
    (59) location -> . string_slice
    (60) location -> . array_element
    (61) location -> . array_slice
    (119) literal -> . integer_literal
    (120) literal -> . boolean_literal
    (121) literal -> . character_literal
    (122) literal -> . empty_literal
    (123) literal -> . character_string_literal
    (124) value_array_element -> . primitive_value LBRACKET expression_list RBRACKET
    (125) value_array_slice -> . primitive_value LBRACKET expression COLON expression RBRACKET
    (75) parenthesized_expression -> . LPAREN expression RPAREN
    (22) identifier -> . ID
    (62) dereferenced_reference -> . array_location ARROW
    (63) string_element -> . identifier LBRACKET start_element LBRACKET
    (65) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (68) array_element -> . array_location LBRACKET expression_list RBRACKET
    (71) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (126) integer_literal -> . ICONST
    (127) boolean_literal -> . TRUE
    (128) boolean_literal -> . FALSE
    (129) character_literal -> . CCONST
    (130) empty_literal -> . NULL
    (131) character_string_literal -> . SCONST

    IF              shift and go to state 31
    MINUS           shift and go to state 36
    NOT             shift and go to state 35
    ARROW           shift and go to state 45
    LPAREN          shift and go to state 44
    ID              shift and go to state 21
    ICONST          shift and go to state 40
    TRUE            shift and go to state 55
    FALSE           shift and go to state 53
    CCONST          shift and go to state 34
    NULL            shift and go to state 27
    SCONST          shift and go to state 52

    location                       shift and go to state 6
    monadic_operator               shift and go to state 47
    operand2                       shift and go to state 49
    value_array_element            shift and go to state 48
    operand1                       shift and go to state 25
    expression                     shift and go to state 182
    character_literal              shift and go to state 41
    conditional_expression         shift and go to state 28
    referenced_location            shift and go to state 29
    parenthesized_expression       shift and go to state 30
    array_slice                    shift and go to state 15
    integer_literal                shift and go to state 32
    empty_literal                  shift and go to state 50
    operand3                       shift and go to state 33
    string_slice                   shift and go to state 3
    string_element                 shift and go to state 1
    boolean_literal                shift and go to state 51
    array_location                 shift and go to state 46
    literal                        shift and go to state 37
    operand0                       shift and go to state 38
    primitive_value                shift and go to state 39
    array_element                  shift and go to state 7
    value_array_slice              shift and go to state 42
    operand4                       shift and go to state 54
    character_string_literal       shift and go to state 43
    dereferenced_reference         shift and go to state 20
    identifier                     shift and go to state 56

state 152

    (145) then_clause -> THEN action_statement_list .

    ELSE            reduce using rule 145 (then_clause -> THEN action_statement_list .)
    ELSIF           reduce using rule 145 (then_clause -> THEN action_statement_list .)
    FI              reduce using rule 145 (then_clause -> THEN action_statement_list .)
    DCL             reduce using rule 145 (then_clause -> THEN action_statement_list .)
    SYN             reduce using rule 145 (then_clause -> THEN action_statement_list .)
    TYPE            reduce using rule 145 (then_clause -> THEN action_statement_list .)
    ID              reduce using rule 145 (then_clause -> THEN action_statement_list .)
    IF              reduce using rule 145 (then_clause -> THEN action_statement_list .)
    $end            reduce using rule 145 (then_clause -> THEN action_statement_list .)
=======
    (31) formal_parameter_list -> formal_parameter COMMA . formal_parameter
    (32) formal_parameter -> . identifier_list mode LOC
    (33) formal_parameter -> . identifier_list mode
    (20) identifier_list -> . identifier
    (21) identifier_list -> . identifier COMMA identifier_list
    (22) identifier -> . ID

    ID              shift and go to state 15

    identifier                     shift and go to state 16
    formal_parameter               shift and go to state 171
    identifier_list                shift and go to state 109

state 152

    (28) procedure_definition -> PROC LPAREN formal_parameter_list RPAREN . result_spec SEMI statement_nullable END SEMI
    (29) procedure_definition -> PROC LPAREN formal_parameter_list RPAREN . SEMI statement_nullable END SEMI
    (34) result_spec -> . RETURNS LPAREN mode LOC RPAREN
    (35) result_spec -> . RETURNS LPAREN mode RPAREN

    SEMI            shift and go to state 174
    RETURNS         shift and go to state 172
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

    result_spec                    shift and go to state 173

state 153

<<<<<<< HEAD
    (149) action_statement_list -> action_statement . action_statement_nullable
    (150) action_statement_nullable -> . action_statement action_statement_nullable
    (151) action_statement_nullable -> . empty
    (132) action_statement -> . identifier COLON action
    (133) action_statement -> . action
    (152) empty -> .
    (22) identifier -> . ID
    (134) action -> . bracketed_action
    (135) action -> . assignment_action
    (136) bracketed_action -> . if_action
    (137) assignment_action -> . array_location assigning_operator expression
    (143) if_action -> . IF expression then_clause else_clause FI
    (144) if_action -> . IF expression then_clause
    (72) array_location -> . location
    (56) location -> . identifier
    (57) location -> . dereferenced_reference
    (58) location -> . string_element
    (59) location -> . string_slice
    (60) location -> . array_element
    (61) location -> . array_slice
    (62) dereferenced_reference -> . array_location ARROW
    (63) string_element -> . identifier LBRACKET start_element LBRACKET
    (65) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (68) array_element -> . array_location LBRACKET expression_list RBRACKET
    (71) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
    ELSE            reduce using rule 152 (empty -> .)
    ELSIF           reduce using rule 152 (empty -> .)
    DCL             reduce using rule 152 (empty -> .)
    SYN             reduce using rule 152 (empty -> .)
    TYPE            reduce using rule 152 (empty -> .)
    $end            reduce using rule 152 (empty -> .)
    FI              reduce using rule 152 (empty -> .)
    ID              shift and go to state 21
    IF              shift and go to state 4

  ! ID              [ reduce using rule 152 (empty -> .) ]
  ! IF              [ reduce using rule 152 (empty -> .) ]

    location                       shift and go to state 6
    string_element                 shift and go to state 1
    string_slice                   shift and go to state 3
    array_slice                    shift and go to state 15
    assignment_action              shift and go to state 11
    if_action                      shift and go to state 17
    array_location                 shift and go to state 13
    array_element                  shift and go to state 7
    action                         shift and go to state 8
    bracketed_action               shift and go to state 22
    action_statement               shift and go to state 183
    action_statement_nullable      shift and go to state 185
    empty                          shift and go to state 184
    dereferenced_reference         shift and go to state 20
    identifier                     shift and go to state 24

state 154

    (78) then_expression -> THEN . expression
    (73) expression -> . operand0
    (74) expression -> . conditional_expression
    (82) operand0 -> . operand1
    (83) operand0 -> . operand0 operator1 operand1
    (76) conditional_expression -> . IF expression then_expression else_expression FI
    (77) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (84) operand1 -> . operand2
    (85) operand1 -> . operand1 operator2 operand2
    (86) operand2 -> . operand3
    (87) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (88) operand3 -> . monadic_operator operand4
    (89) operand3 -> . operand4
    (96) monadic_operator -> . MINUS
    (97) monadic_operator -> . NOT
    (90) operand4 -> . array_location
    (91) operand4 -> . referenced_location
    (92) operand4 -> . primitive_value
    (72) array_location -> . location
    (98) referenced_location -> . ARROW array_location
    (115) primitive_value -> . literal
    (116) primitive_value -> . value_array_element
    (117) primitive_value -> . value_array_slice
    (118) primitive_value -> . parenthesized_expression
    (56) location -> . identifier
    (57) location -> . dereferenced_reference
    (58) location -> . string_element
    (59) location -> . string_slice
    (60) location -> . array_element
    (61) location -> . array_slice
    (119) literal -> . integer_literal
    (120) literal -> . boolean_literal
    (121) literal -> . character_literal
    (122) literal -> . empty_literal
    (123) literal -> . character_string_literal
    (124) value_array_element -> . primitive_value LBRACKET expression_list RBRACKET
    (125) value_array_slice -> . primitive_value LBRACKET expression COLON expression RBRACKET
    (75) parenthesized_expression -> . LPAREN expression RPAREN
    (22) identifier -> . ID
    (62) dereferenced_reference -> . array_location ARROW
    (63) string_element -> . identifier LBRACKET start_element LBRACKET
    (65) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (68) array_element -> . array_location LBRACKET expression_list RBRACKET
    (71) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (126) integer_literal -> . ICONST
    (127) boolean_literal -> . TRUE
    (128) boolean_literal -> . FALSE
    (129) character_literal -> . CCONST
    (130) empty_literal -> . NULL
    (131) character_string_literal -> . SCONST

    IF              shift and go to state 31
    MINUS           shift and go to state 36
    NOT             shift and go to state 35
    ARROW           shift and go to state 45
    LPAREN          shift and go to state 44
    ID              shift and go to state 21
    ICONST          shift and go to state 40
    TRUE            shift and go to state 55
    FALSE           shift and go to state 53
    CCONST          shift and go to state 34
    NULL            shift and go to state 27
    SCONST          shift and go to state 52

    location                       shift and go to state 6
    monadic_operator               shift and go to state 47
    operand2                       shift and go to state 49
    value_array_element            shift and go to state 48
    operand1                       shift and go to state 25
    expression                     shift and go to state 186
    conditional_expression         shift and go to state 28
    referenced_location            shift and go to state 29
    parenthesized_expression       shift and go to state 30
    array_slice                    shift and go to state 15
    integer_literal                shift and go to state 32
    empty_literal                  shift and go to state 50
    array_element                  shift and go to state 7
    operand3                       shift and go to state 33
    string_slice                   shift and go to state 3
    string_element                 shift and go to state 1
    boolean_literal                shift and go to state 51
    array_location                 shift and go to state 46
    literal                        shift and go to state 37
    operand0                       shift and go to state 38
    primitive_value                shift and go to state 39
    character_literal              shift and go to state 41
    value_array_slice              shift and go to state 42
    operand4                       shift and go to state 54
    character_string_literal       shift and go to state 43
    dereferenced_reference         shift and go to state 20
    identifier                     shift and go to state 56

state 155

    (76) conditional_expression -> IF expression then_expression . else_expression FI
    (77) conditional_expression -> IF expression then_expression . elsif_expression else_expression FI
    (79) else_expression -> . ELSE expression
    (80) elsif_expression -> . ELSIF expression then_expression
    (81) elsif_expression -> . elsif_expression ELSIF expression then_expression

    ELSE            shift and go to state 187
    ELSIF           shift and go to state 188

    elsif_expression               shift and go to state 189
    else_expression                shift and go to state 190

state 156

    (83) operand0 -> operand0 operator1 operand1 .
    (85) operand1 -> operand1 . operator2 operand2
    (101) operator2 -> . arithmetic_additive_operator
    (102) operator2 -> . string_concatenation_operator
    (103) arithmetic_additive_operator -> . PLUS
    (104) arithmetic_additive_operator -> . MINUS
    (105) string_concatenation_operator -> . CONCAT

    AND             reduce using rule 83 (operand0 -> operand0 operator1 operand1 .)
    OR              reduce using rule 83 (operand0 -> operand0 operator1 operand1 .)
    EQUAL           reduce using rule 83 (operand0 -> operand0 operator1 operand1 .)
    NOTEQ           reduce using rule 83 (operand0 -> operand0 operator1 operand1 .)
    GREATER         reduce using rule 83 (operand0 -> operand0 operator1 operand1 .)
    GTEQUAL         reduce using rule 83 (operand0 -> operand0 operator1 operand1 .)
    LESS            reduce using rule 83 (operand0 -> operand0 operator1 operand1 .)
    LTEQUAL         reduce using rule 83 (operand0 -> operand0 operator1 operand1 .)
    IN              reduce using rule 83 (operand0 -> operand0 operator1 operand1 .)
    LBRACKET        reduce using rule 83 (operand0 -> operand0 operator1 operand1 .)
    COLON           reduce using rule 83 (operand0 -> operand0 operator1 operand1 .)
    RPAREN          reduce using rule 83 (operand0 -> operand0 operator1 operand1 .)
    COMMA           reduce using rule 83 (operand0 -> operand0 operator1 operand1 .)
    RBRACKET        reduce using rule 83 (operand0 -> operand0 operator1 operand1 .)
    FI              reduce using rule 83 (operand0 -> operand0 operator1 operand1 .)
    SEMI            reduce using rule 83 (operand0 -> operand0 operator1 operand1 .)
    DCL             reduce using rule 83 (operand0 -> operand0 operator1 operand1 .)
    SYN             reduce using rule 83 (operand0 -> operand0 operator1 operand1 .)
    TYPE            reduce using rule 83 (operand0 -> operand0 operator1 operand1 .)
    ID              reduce using rule 83 (operand0 -> operand0 operator1 operand1 .)
    IF              reduce using rule 83 (operand0 -> operand0 operator1 operand1 .)
    $end            reduce using rule 83 (operand0 -> operand0 operator1 operand1 .)
    ELSE            reduce using rule 83 (operand0 -> operand0 operator1 operand1 .)
    ELSIF           reduce using rule 83 (operand0 -> operand0 operator1 operand1 .)
    THEN            reduce using rule 83 (operand0 -> operand0 operator1 operand1 .)
    PLUS            shift and go to state 64
    MINUS           shift and go to state 74
    CONCAT          shift and go to state 68

    arithmetic_additive_operator   shift and go to state 86
    string_concatenation_operator  shift and go to state 87
    operator2                      shift and go to state 88

state 157

    (125) value_array_slice -> primitive_value LBRACKET expression . COLON expression RBRACKET
    (69) expression_list -> expression .
    (70) expression_list -> expression . COMMA expression_list
=======
    (32) formal_parameter -> identifier_list mode . LOC
    (33) formal_parameter -> identifier_list mode .

    LOC             shift and go to state 175
    COMMA           reduce using rule 33 (formal_parameter -> identifier_list mode .)
    RPAREN          reduce using rule 33 (formal_parameter -> identifier_list mode .)


state 154

    (50) discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .

    LPAREN          reduce using rule 50 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    ASSIGN          reduce using rule 50 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    COMMA           reduce using rule 50 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    SEMI            reduce using rule 50 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    RBRACKET        reduce using rule 50 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    LOC             reduce using rule 50 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    RPAREN          reduce using rule 50 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)


state 155

    (51) literal_range -> lower_bound COLON . upper_bound
    (53) upper_bound -> . expression
    (82) expression -> . operand0
    (83) expression -> . conditional_expression
    (90) operand0 -> . operand1
    (91) operand0 -> . operand0 operator1 operand1
    (84) conditional_expression -> . IF expression then_expression else_expression FI
    (85) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (92) operand1 -> . operand2
    (93) operand1 -> . operand1 operator2 operand2
    (94) operand2 -> . operand3
    (95) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (96) operand3 -> . monadic_operator operand4
    (97) operand3 -> . operand4
    (104) monadic_operator -> . MINUS
    (105) monadic_operator -> . NOT
    (98) operand4 -> . array_location
    (99) operand4 -> . referenced_location
    (100) operand4 -> . primitive_value
    (81) array_location -> . location
    (106) referenced_location -> . ARROW array_location
    (123) primitive_value -> . literal
    (65) location -> . identifier
    (66) location -> . dereferenced_reference
    (67) location -> . string_element
    (68) location -> . string_slice
    (69) location -> . array_element
    (70) location -> . array_slice
    (124) literal -> . integer_literal
    (125) literal -> . boolean_literal
    (126) literal -> . character_literal
    (127) literal -> . empty_literal
    (128) literal -> . character_string_literal
    (22) identifier -> . ID
    (71) dereferenced_reference -> . array_location ARROW
    (72) string_element -> . identifier LBRACKET start_element LBRACKET
    (74) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (77) array_element -> . array_location LBRACKET expression_list RBRACKET
    (80) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (129) integer_literal -> . ICONST
    (130) boolean_literal -> . TRUE
    (131) boolean_literal -> . FALSE
    (132) character_literal -> . CCONST
    (133) empty_literal -> . NULL
    (134) character_string_literal -> . SCONST

    IF              shift and go to state 99
    MINUS           shift and go to state 90
    NOT             shift and go to state 96
    ARROW           shift and go to state 72
    ID              shift and go to state 15
    ICONST          shift and go to state 89
    TRUE            shift and go to state 87
    FALSE           shift and go to state 80
    CCONST          shift and go to state 91
    NULL            shift and go to state 97
    SCONST          shift and go to state 95

    monadic_operator               shift and go to state 93
    character_literal              shift and go to state 85
    character_string_literal       shift and go to state 94
    identifier                     shift and go to state 84
    array_location                 shift and go to state 73
    literal                        shift and go to state 74
    dereferenced_reference         shift and go to state 75
    operand3                       shift and go to state 76
    integer_literal                shift and go to state 77
    array_slice                    shift and go to state 83
    primitive_value                shift and go to state 78
    referenced_location            shift and go to state 79
    string_slice                   shift and go to state 98
    string_element                 shift and go to state 81
    location                       shift and go to state 82
    conditional_expression         shift and go to state 100
    operand2                       shift and go to state 103
    upper_bound                    shift and go to state 177
    empty_literal                  shift and go to state 101
    operand1                       shift and go to state 86
    operand4                       shift and go to state 102
    expression                     shift and go to state 176
    boolean_literal                shift and go to state 104
    operand0                       shift and go to state 105
    array_element                  shift and go to state 92

state 156

    (57) string_mode -> CHARS LBRACKET string_length RBRACKET .

    ASSIGN          reduce using rule 57 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    COMMA           reduce using rule 57 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    SEMI            reduce using rule 57 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    LOC             reduce using rule 57 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    RPAREN          reduce using rule 57 (string_mode -> CHARS LBRACKET string_length RBRACKET .)

>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

    COLON           shift and go to state 191
    RBRACKET        reduce using rule 69 (expression_list -> expression .)
    COMMA           shift and go to state 170

<<<<<<< HEAD
=======
    (49) discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

    LPAREN          reduce using rule 49 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    ASSIGN          reduce using rule 49 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    COMMA           reduce using rule 49 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    SEMI            reduce using rule 49 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    RBRACKET        reduce using rule 49 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    LOC             reduce using rule 49 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    RPAREN          reduce using rule 49 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)

<<<<<<< HEAD
    (124) value_array_element -> primitive_value LBRACKET expression_list . RBRACKET

    RBRACKET        shift and go to state 192


state 159

    (75) parenthesized_expression -> LPAREN expression RPAREN .

    LBRACKET        reduce using rule 75 (parenthesized_expression -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 75 (parenthesized_expression -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 75 (parenthesized_expression -> LPAREN expression RPAREN .)
    MODULO          reduce using rule 75 (parenthesized_expression -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 75 (parenthesized_expression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 75 (parenthesized_expression -> LPAREN expression RPAREN .)
    CONCAT          reduce using rule 75 (parenthesized_expression -> LPAREN expression RPAREN .)
    AND             reduce using rule 75 (parenthesized_expression -> LPAREN expression RPAREN .)
    OR              reduce using rule 75 (parenthesized_expression -> LPAREN expression RPAREN .)
    EQUAL           reduce using rule 75 (parenthesized_expression -> LPAREN expression RPAREN .)
    NOTEQ           reduce using rule 75 (parenthesized_expression -> LPAREN expression RPAREN .)
    GREATER         reduce using rule 75 (parenthesized_expression -> LPAREN expression RPAREN .)
    GTEQUAL         reduce using rule 75 (parenthesized_expression -> LPAREN expression RPAREN .)
    LESS            reduce using rule 75 (parenthesized_expression -> LPAREN expression RPAREN .)
    LTEQUAL         reduce using rule 75 (parenthesized_expression -> LPAREN expression RPAREN .)
    IN              reduce using rule 75 (parenthesized_expression -> LPAREN expression RPAREN .)
    RBRACKET        reduce using rule 75 (parenthesized_expression -> LPAREN expression RPAREN .)
    THEN            reduce using rule 75 (parenthesized_expression -> LPAREN expression RPAREN .)
    DCL             reduce using rule 75 (parenthesized_expression -> LPAREN expression RPAREN .)
    SYN             reduce using rule 75 (parenthesized_expression -> LPAREN expression RPAREN .)
    TYPE            reduce using rule 75 (parenthesized_expression -> LPAREN expression RPAREN .)
    ID              reduce using rule 75 (parenthesized_expression -> LPAREN expression RPAREN .)
    IF              reduce using rule 75 (parenthesized_expression -> LPAREN expression RPAREN .)
    $end            reduce using rule 75 (parenthesized_expression -> LPAREN expression RPAREN .)
    ELSE            reduce using rule 75 (parenthesized_expression -> LPAREN expression RPAREN .)
    ELSIF           reduce using rule 75 (parenthesized_expression -> LPAREN expression RPAREN .)
    FI              reduce using rule 75 (parenthesized_expression -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 75 (parenthesized_expression -> LPAREN expression RPAREN .)
    SEMI            reduce using rule 75 (parenthesized_expression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 75 (parenthesized_expression -> LPAREN expression RPAREN .)
    COLON           reduce using rule 75 (parenthesized_expression -> LPAREN expression RPAREN .)
=======

state 158

    (59) array_mode -> ARRAY LBRACKET index_mode_list RBRACKET . element_mode
    (64) element_mode -> . mode
    (36) mode -> . mode_name
    (37) mode -> . discrete_mode
    (38) mode -> . reference_mode
    (39) mode -> . composite_mode
    (40) mode_name -> . identifier
    (41) discrete_mode -> . integer_mode
    (42) discrete_mode -> . boolean_mode
    (43) discrete_mode -> . character_mode
    (44) discrete_mode -> . discrete_range_mode
    (54) reference_mode -> . REF mode
    (55) composite_mode -> . string_mode
    (56) composite_mode -> . array_mode
    (22) identifier -> . ID
    (46) integer_mode -> . INT
    (47) boolean_mode -> . BOOL
    (48) character_mode -> . CHAR
    (49) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (50) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (57) string_mode -> . CHARS LBRACKET string_length RBRACKET
    (59) array_mode -> . ARRAY LBRACKET index_mode_list RBRACKET element_mode
    (45) discrete_mode_name -> . identifier

    REF             shift and go to state 38
    ID              shift and go to state 15
    INT             shift and go to state 39
    BOOL            shift and go to state 53
    CHAR            shift and go to state 51
    CHARS           shift and go to state 43
    ARRAY           shift and go to state 52

    discrete_range_mode            shift and go to state 45
    identifier                     shift and go to state 36
    composite_mode                 shift and go to state 46
    discrete_mode                  shift and go to state 37
    array_mode                     shift and go to state 42
    discrete_mode_name             shift and go to state 48
    mode                           shift and go to state 178
    boolean_mode                   shift and go to state 50
    mode_name                      shift and go to state 41
    reference_mode                 shift and go to state 35
    element_mode                   shift and go to state 179
    integer_mode                   shift and go to state 40
    string_mode                    shift and go to state 44
    character_mode                 shift and go to state 47

state 159

    (61) index_mode_list -> index_mode COMMA . index_mode_list
    (60) index_mode_list -> . index_mode
    (61) index_mode_list -> . index_mode COMMA index_mode_list
    (62) index_mode -> . discrete_mode
    (63) index_mode -> . literal_range
    (41) discrete_mode -> . integer_mode
    (42) discrete_mode -> . boolean_mode
    (43) discrete_mode -> . character_mode
    (44) discrete_mode -> . discrete_range_mode
    (51) literal_range -> . lower_bound COLON upper_bound
    (46) integer_mode -> . INT
    (47) boolean_mode -> . BOOL
    (48) character_mode -> . CHAR
    (49) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (50) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (52) lower_bound -> . expression
    (45) discrete_mode_name -> . identifier
    (82) expression -> . operand0
    (83) expression -> . conditional_expression
    (22) identifier -> . ID
    (90) operand0 -> . operand1
    (91) operand0 -> . operand0 operator1 operand1
    (84) conditional_expression -> . IF expression then_expression else_expression FI
    (85) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (92) operand1 -> . operand2
    (93) operand1 -> . operand1 operator2 operand2
    (94) operand2 -> . operand3
    (95) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (96) operand3 -> . monadic_operator operand4
    (97) operand3 -> . operand4
    (104) monadic_operator -> . MINUS
    (105) monadic_operator -> . NOT
    (98) operand4 -> . array_location
    (99) operand4 -> . referenced_location
    (100) operand4 -> . primitive_value
    (81) array_location -> . location
    (106) referenced_location -> . ARROW array_location
    (123) primitive_value -> . literal
    (65) location -> . identifier
    (66) location -> . dereferenced_reference
    (67) location -> . string_element
    (68) location -> . string_slice
    (69) location -> . array_element
    (70) location -> . array_slice
    (124) literal -> . integer_literal
    (125) literal -> . boolean_literal
    (126) literal -> . character_literal
    (127) literal -> . empty_literal
    (128) literal -> . character_string_literal
    (71) dereferenced_reference -> . array_location ARROW
    (72) string_element -> . identifier LBRACKET start_element LBRACKET
    (74) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (77) array_element -> . array_location LBRACKET expression_list RBRACKET
    (80) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (129) integer_literal -> . ICONST
    (130) boolean_literal -> . TRUE
    (131) boolean_literal -> . FALSE
    (132) character_literal -> . CCONST
    (133) empty_literal -> . NULL
    (134) character_string_literal -> . SCONST

    INT             shift and go to state 39
    BOOL            shift and go to state 53
    CHAR            shift and go to state 51
    ID              shift and go to state 15
    IF              shift and go to state 99
    MINUS           shift and go to state 90
    NOT             shift and go to state 96
    ARROW           shift and go to state 72
    ICONST          shift and go to state 89
    TRUE            shift and go to state 87
    FALSE           shift and go to state 80
    CCONST          shift and go to state 91
    NULL            shift and go to state 97
    SCONST          shift and go to state 95

    literal                        shift and go to state 74
    dereferenced_reference         shift and go to state 75
    operand3                       shift and go to state 76
    integer_literal                shift and go to state 77
    primitive_value                shift and go to state 78
    referenced_location            shift and go to state 79
    string_element                 shift and go to state 81
    location                       shift and go to state 82
    discrete_range_mode            shift and go to state 45
    array_slice                    shift and go to state 83
    operand2                       shift and go to state 103
    character_mode                 shift and go to state 47
    character_literal              shift and go to state 85
    operand1                       shift and go to state 86
    boolean_mode                   shift and go to state 50
    expression                     shift and go to state 111
    integer_mode                   shift and go to state 40
    array_element                  shift and go to state 92
    monadic_operator               shift and go to state 93
    character_string_literal       shift and go to state 94
    identifier                     shift and go to state 117
    discrete_mode                  shift and go to state 118
    lower_bound                    shift and go to state 112
    literal_range                  shift and go to state 119
    string_slice                   shift and go to state 98
    conditional_expression         shift and go to state 100
    array_location                 shift and go to state 73
    index_mode_list                shift and go to state 180
    discrete_mode_name             shift and go to state 48
    empty_literal                  shift and go to state 101
    operand4                       shift and go to state 102
    boolean_literal                shift and go to state 104
    operand0                       shift and go to state 105
    index_mode                     shift and go to state 121
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


<<<<<<< HEAD
state 160

    (87) operand2 -> operand2 arithmetic_multiplicative_operator operand3 .

    TIMES           reduce using rule 87 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    DIVIDE          reduce using rule 87 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    MODULO          reduce using rule 87 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    PLUS            reduce using rule 87 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    MINUS           reduce using rule 87 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    CONCAT          reduce using rule 87 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    AND             reduce using rule 87 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    OR              reduce using rule 87 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    EQUAL           reduce using rule 87 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    NOTEQ           reduce using rule 87 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    GREATER         reduce using rule 87 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    GTEQUAL         reduce using rule 87 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    LESS            reduce using rule 87 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    LTEQUAL         reduce using rule 87 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    IN              reduce using rule 87 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    THEN            reduce using rule 87 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    RPAREN          reduce using rule 87 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    DCL             reduce using rule 87 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    SYN             reduce using rule 87 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    TYPE            reduce using rule 87 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    ID              reduce using rule 87 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    IF              reduce using rule 87 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    $end            reduce using rule 87 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    ELSE            reduce using rule 87 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    ELSIF           reduce using rule 87 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    FI              reduce using rule 87 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    COMMA           reduce using rule 87 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    RBRACKET        reduce using rule 87 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    COLON           reduce using rule 87 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    LBRACKET        reduce using rule 87 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    SEMI            reduce using rule 87 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
=======
    (78) expression_list -> expression .
    (79) expression_list -> expression . COMMA expression_list
    (52) lower_bound -> expression .

    RBRACKET        reduce using rule 78 (expression_list -> expression .)
    COMMA           shift and go to state 181
    COLON           reduce using rule 52 (lower_bound -> expression .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 161

<<<<<<< HEAD
    (21) identifier_list -> identifier COMMA identifier_list .

    ASSIGN          reduce using rule 21 (identifier_list -> identifier COMMA identifier_list .)
    REF             reduce using rule 21 (identifier_list -> identifier COMMA identifier_list .)
    ID              reduce using rule 21 (identifier_list -> identifier COMMA identifier_list .)
    INT             reduce using rule 21 (identifier_list -> identifier COMMA identifier_list .)
    BOOL            reduce using rule 21 (identifier_list -> identifier COMMA identifier_list .)
    CHAR            reduce using rule 21 (identifier_list -> identifier COMMA identifier_list .)
    CHARS           reduce using rule 21 (identifier_list -> identifier COMMA identifier_list .)
    ARRAY           reduce using rule 21 (identifier_list -> identifier COMMA identifier_list .)
=======
    (80) array_slice -> array_location LBRACKET lower_bound . COLON upper_bound RBRACKET

    COLON           shift and go to state 182
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 162

<<<<<<< HEAD
    (11) synonym_list -> synonym_definition COMMA synonym_list .

    SEMI            reduce using rule 11 (synonym_list -> synonym_definition COMMA synonym_list .)
=======
    (77) array_element -> array_location LBRACKET expression_list . RBRACKET

    RBRACKET        shift and go to state 183
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 163

<<<<<<< HEAD
    (12) synonym_definition -> identifier_list mode ASSIGN . expression
    (73) expression -> . operand0
    (74) expression -> . conditional_expression
    (82) operand0 -> . operand1
    (83) operand0 -> . operand0 operator1 operand1
    (76) conditional_expression -> . IF expression then_expression else_expression FI
    (77) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (84) operand1 -> . operand2
    (85) operand1 -> . operand1 operator2 operand2
    (86) operand2 -> . operand3
    (87) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (88) operand3 -> . monadic_operator operand4
    (89) operand3 -> . operand4
    (96) monadic_operator -> . MINUS
    (97) monadic_operator -> . NOT
    (90) operand4 -> . array_location
    (91) operand4 -> . referenced_location
    (92) operand4 -> . primitive_value
    (72) array_location -> . location
    (98) referenced_location -> . ARROW array_location
    (115) primitive_value -> . literal
    (116) primitive_value -> . value_array_element
    (117) primitive_value -> . value_array_slice
    (118) primitive_value -> . parenthesized_expression
    (56) location -> . identifier
    (57) location -> . dereferenced_reference
    (58) location -> . string_element
    (59) location -> . string_slice
    (60) location -> . array_element
    (61) location -> . array_slice
    (119) literal -> . integer_literal
    (120) literal -> . boolean_literal
    (121) literal -> . character_literal
    (122) literal -> . empty_literal
    (123) literal -> . character_string_literal
    (124) value_array_element -> . primitive_value LBRACKET expression_list RBRACKET
    (125) value_array_slice -> . primitive_value LBRACKET expression COLON expression RBRACKET
    (75) parenthesized_expression -> . LPAREN expression RPAREN
    (22) identifier -> . ID
    (62) dereferenced_reference -> . array_location ARROW
    (63) string_element -> . identifier LBRACKET start_element LBRACKET
    (65) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (68) array_element -> . array_location LBRACKET expression_list RBRACKET
    (71) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (126) integer_literal -> . ICONST
    (127) boolean_literal -> . TRUE
    (128) boolean_literal -> . FALSE
    (129) character_literal -> . CCONST
    (130) empty_literal -> . NULL
    (131) character_string_literal -> . SCONST

    IF              shift and go to state 31
    MINUS           shift and go to state 36
    NOT             shift and go to state 35
    ARROW           shift and go to state 45
    LPAREN          shift and go to state 44
    ID              shift and go to state 21
    ICONST          shift and go to state 40
    TRUE            shift and go to state 55
    FALSE           shift and go to state 53
    CCONST          shift and go to state 34
    NULL            shift and go to state 27
    SCONST          shift and go to state 52

    location                       shift and go to state 6
    operand2                       shift and go to state 49
    value_array_element            shift and go to state 48
    operand1                       shift and go to state 25
    expression                     shift and go to state 193
    conditional_expression         shift and go to state 28
    referenced_location            shift and go to state 29
    monadic_operator               shift and go to state 47
    integer_literal                shift and go to state 32
    empty_literal                  shift and go to state 50
    array_element                  shift and go to state 7
    operand3                       shift and go to state 33
    string_slice                   shift and go to state 3
    string_element                 shift and go to state 1
    boolean_literal                shift and go to state 51
    array_location                 shift and go to state 46
    literal                        shift and go to state 37
    operand0                       shift and go to state 38
    primitive_value                shift and go to state 39
    array_slice                    shift and go to state 15
    character_literal              shift and go to state 41
    parenthesized_expression       shift and go to state 30
    value_array_slice              shift and go to state 42
    operand4                       shift and go to state 54
    character_string_literal       shift and go to state 43
    dereferenced_reference         shift and go to state 20
    identifier                     shift and go to state 56

state 164

    (40) discrete_range_mode -> discrete_mode_name LPAREN . literal_range RPAREN
    (42) literal_range -> . lower_bound COLON upper_bound
    (43) lower_bound -> . expression
    (73) expression -> . operand0
    (74) expression -> . conditional_expression
    (82) operand0 -> . operand1
    (83) operand0 -> . operand0 operator1 operand1
    (76) conditional_expression -> . IF expression then_expression else_expression FI
    (77) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (84) operand1 -> . operand2
    (85) operand1 -> . operand1 operator2 operand2
    (86) operand2 -> . operand3
    (87) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (88) operand3 -> . monadic_operator operand4
    (89) operand3 -> . operand4
    (96) monadic_operator -> . MINUS
    (97) monadic_operator -> . NOT
    (90) operand4 -> . array_location
    (91) operand4 -> . referenced_location
    (92) operand4 -> . primitive_value
    (72) array_location -> . location
    (98) referenced_location -> . ARROW array_location
    (115) primitive_value -> . literal
    (116) primitive_value -> . value_array_element
    (117) primitive_value -> . value_array_slice
    (118) primitive_value -> . parenthesized_expression
    (56) location -> . identifier
    (57) location -> . dereferenced_reference
    (58) location -> . string_element
    (59) location -> . string_slice
    (60) location -> . array_element
    (61) location -> . array_slice
    (119) literal -> . integer_literal
    (120) literal -> . boolean_literal
    (121) literal -> . character_literal
    (122) literal -> . empty_literal
    (123) literal -> . character_string_literal
    (124) value_array_element -> . primitive_value LBRACKET expression_list RBRACKET
    (125) value_array_slice -> . primitive_value LBRACKET expression COLON expression RBRACKET
    (75) parenthesized_expression -> . LPAREN expression RPAREN
    (22) identifier -> . ID
    (62) dereferenced_reference -> . array_location ARROW
    (63) string_element -> . identifier LBRACKET start_element LBRACKET
    (65) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (68) array_element -> . array_location LBRACKET expression_list RBRACKET
    (71) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (126) integer_literal -> . ICONST
    (127) boolean_literal -> . TRUE
    (128) boolean_literal -> . FALSE
    (129) character_literal -> . CCONST
    (130) empty_literal -> . NULL
    (131) character_string_literal -> . SCONST

    IF              shift and go to state 31
    MINUS           shift and go to state 36
    NOT             shift and go to state 35
    ARROW           shift and go to state 45
    LPAREN          shift and go to state 44
    ID              shift and go to state 21
    ICONST          shift and go to state 40
    TRUE            shift and go to state 55
    FALSE           shift and go to state 53
    CCONST          shift and go to state 34
    NULL            shift and go to state 27
    SCONST          shift and go to state 52

    location                       shift and go to state 6
    monadic_operator               shift and go to state 47
    operand2                       shift and go to state 49
    value_array_element            shift and go to state 48
    operand1                       shift and go to state 25
    expression                     shift and go to state 194
    character_literal              shift and go to state 41
    conditional_expression         shift and go to state 28
    referenced_location            shift and go to state 29
    parenthesized_expression       shift and go to state 30
    array_slice                    shift and go to state 15
    integer_literal                shift and go to state 32
    empty_literal                  shift and go to state 50
    literal_range                  shift and go to state 195
    operand3                       shift and go to state 33
    string_slice                   shift and go to state 3
    boolean_literal                shift and go to state 51
    array_location                 shift and go to state 46
    literal                        shift and go to state 37
    operand0                       shift and go to state 38
    primitive_value                shift and go to state 39
    array_element                  shift and go to state 7
    value_array_slice              shift and go to state 42
    operand4                       shift and go to state 54
    string_element                 shift and go to state 1
    lower_bound                    shift and go to state 196
    character_string_literal       shift and go to state 43
    dereferenced_reference         shift and go to state 20
    identifier                     shift and go to state 56

state 165

    (45) reference_mode -> REF mode .

    ASSIGN          reduce using rule 45 (reference_mode -> REF mode .)
    COMMA           reduce using rule 45 (reference_mode -> REF mode .)
    SEMI            reduce using rule 45 (reference_mode -> REF mode .)
=======
    (74) string_slice -> identifier LBRACKET left_element . COLON right_element RBRACKET

    COLON           shift and go to state 184


state 164

    (73) start_element -> expression .
    (75) left_element -> expression .

    LBRACKET        reduce using rule 73 (start_element -> expression .)
    COLON           reduce using rule 75 (left_element -> expression .)


state 165

    (72) string_element -> identifier LBRACKET start_element . LBRACKET

    LBRACKET        shift and go to state 185
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 166

<<<<<<< HEAD
    (50) array_mode -> ARRAY LBRACKET . index_mode_list RBRACKET element_mode
    (51) index_mode_list -> . index_mode
    (52) index_mode_list -> . index_mode COMMA index_mode_list
    (53) index_mode -> . discrete_mode
    (54) index_mode -> . literal_range
    (32) discrete_mode -> . integer_mode
    (33) discrete_mode -> . boolean_mode
    (34) discrete_mode -> . character_mode
    (35) discrete_mode -> . discrete_range_mode
    (42) literal_range -> . lower_bound COLON upper_bound
    (37) integer_mode -> . INT
    (38) boolean_mode -> . BOOL
    (39) character_mode -> . CHAR
    (40) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (41) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (43) lower_bound -> . expression
    (36) discrete_mode_name -> . identifier
    (73) expression -> . operand0
    (74) expression -> . conditional_expression
    (22) identifier -> . ID
    (82) operand0 -> . operand1
    (83) operand0 -> . operand0 operator1 operand1
    (76) conditional_expression -> . IF expression then_expression else_expression FI
    (77) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (84) operand1 -> . operand2
    (85) operand1 -> . operand1 operator2 operand2
    (86) operand2 -> . operand3
    (87) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (88) operand3 -> . monadic_operator operand4
    (89) operand3 -> . operand4
    (96) monadic_operator -> . MINUS
    (97) monadic_operator -> . NOT
    (90) operand4 -> . array_location
    (91) operand4 -> . referenced_location
    (92) operand4 -> . primitive_value
    (72) array_location -> . location
    (98) referenced_location -> . ARROW array_location
    (115) primitive_value -> . literal
    (116) primitive_value -> . value_array_element
    (117) primitive_value -> . value_array_slice
    (118) primitive_value -> . parenthesized_expression
    (56) location -> . identifier
    (57) location -> . dereferenced_reference
    (58) location -> . string_element
    (59) location -> . string_slice
    (60) location -> . array_element
    (61) location -> . array_slice
    (119) literal -> . integer_literal
    (120) literal -> . boolean_literal
    (121) literal -> . character_literal
    (122) literal -> . empty_literal
    (123) literal -> . character_string_literal
    (124) value_array_element -> . primitive_value LBRACKET expression_list RBRACKET
    (125) value_array_slice -> . primitive_value LBRACKET expression COLON expression RBRACKET
    (75) parenthesized_expression -> . LPAREN expression RPAREN
    (62) dereferenced_reference -> . array_location ARROW
    (63) string_element -> . identifier LBRACKET start_element LBRACKET
    (65) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (68) array_element -> . array_location LBRACKET expression_list RBRACKET
    (71) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (126) integer_literal -> . ICONST
    (127) boolean_literal -> . TRUE
    (128) boolean_literal -> . FALSE
    (129) character_literal -> . CCONST
    (130) empty_literal -> . NULL
    (131) character_string_literal -> . SCONST

    INT             shift and go to state 119
    BOOL            shift and go to state 130
    CHAR            shift and go to state 112
    ID              shift and go to state 21
    IF              shift and go to state 31
    MINUS           shift and go to state 36
    NOT             shift and go to state 35
    ARROW           shift and go to state 45
    LPAREN          shift and go to state 44
    ICONST          shift and go to state 40
    TRUE            shift and go to state 55
    FALSE           shift and go to state 53
    CCONST          shift and go to state 34
    NULL            shift and go to state 27
    SCONST          shift and go to state 52

    string_element                 shift and go to state 1
    operand1                       shift and go to state 25
    expression                     shift and go to state 194
    index_mode                     shift and go to state 197
    referenced_location            shift and go to state 29
    parenthesized_expression       shift and go to state 30
    integer_mode                   shift and go to state 117
    integer_literal                shift and go to state 32
    operand3                       shift and go to state 33
    string_slice                   shift and go to state 3
    location                       shift and go to state 6
    literal                        shift and go to state 37
    operand0                       shift and go to state 38
    boolean_mode                   shift and go to state 122
    character_literal              shift and go to state 41
    value_array_slice              shift and go to state 42
    character_mode                 shift and go to state 124
    discrete_range_mode            shift and go to state 127
    discrete_mode                  shift and go to state 198
    index_mode_list                shift and go to state 199
    array_location                 shift and go to state 46
    monadic_operator               shift and go to state 47
    conditional_expression         shift and go to state 28
    value_array_element            shift and go to state 48
    discrete_mode_name             shift and go to state 116
    operand2                       shift and go to state 49
    array_slice                    shift and go to state 15
    empty_literal                  shift and go to state 50
    literal_range                  shift and go to state 200
    character_string_literal       shift and go to state 43
    boolean_literal                shift and go to state 51
    array_element                  shift and go to state 7
    operand4                       shift and go to state 54
    primitive_value                shift and go to state 39
    lower_bound                    shift and go to state 196
    dereferenced_reference         shift and go to state 20
    identifier                     shift and go to state 201

state 167

    (48) string_mode -> CHARS LBRACKET . string_length RBRACKET
    (49) string_length -> . integer_literal
    (126) integer_literal -> . ICONST

    ICONST          shift and go to state 40

    integer_literal                shift and go to state 202
    string_length                  shift and go to state 203

state 168

    (13) synonym_definition -> identifier_list ASSIGN expression .

    COMMA           reduce using rule 13 (synonym_definition -> identifier_list ASSIGN expression .)
    SEMI            reduce using rule 13 (synonym_definition -> identifier_list ASSIGN expression .)
=======
    (93) operand1 -> operand1 operator2 operand2 .
    (95) operand2 -> operand2 . arithmetic_multiplicative_operator operand3
    (101) arithmetic_multiplicative_operator -> . TIMES
    (102) arithmetic_multiplicative_operator -> . DIVIDE
    (103) arithmetic_multiplicative_operator -> . MODULO

    PLUS            reduce using rule 93 (operand1 -> operand1 operator2 operand2 .)
    MINUS           reduce using rule 93 (operand1 -> operand1 operator2 operand2 .)
    CONCAT          reduce using rule 93 (operand1 -> operand1 operator2 operand2 .)
    AND             reduce using rule 93 (operand1 -> operand1 operator2 operand2 .)
    OR              reduce using rule 93 (operand1 -> operand1 operator2 operand2 .)
    EQUAL           reduce using rule 93 (operand1 -> operand1 operator2 operand2 .)
    NOTEQ           reduce using rule 93 (operand1 -> operand1 operator2 operand2 .)
    GREATER         reduce using rule 93 (operand1 -> operand1 operator2 operand2 .)
    GTEQUAL         reduce using rule 93 (operand1 -> operand1 operator2 operand2 .)
    LESS            reduce using rule 93 (operand1 -> operand1 operator2 operand2 .)
    LTEQUAL         reduce using rule 93 (operand1 -> operand1 operator2 operand2 .)
    IN              reduce using rule 93 (operand1 -> operand1 operator2 operand2 .)
    COLON           reduce using rule 93 (operand1 -> operand1 operator2 operand2 .)
    THEN            reduce using rule 93 (operand1 -> operand1 operator2 operand2 .)
    COMMA           reduce using rule 93 (operand1 -> operand1 operator2 operand2 .)
    SEMI            reduce using rule 93 (operand1 -> operand1 operator2 operand2 .)
    FI              reduce using rule 93 (operand1 -> operand1 operator2 operand2 .)
    RBRACKET        reduce using rule 93 (operand1 -> operand1 operator2 operand2 .)
    ELSE            reduce using rule 93 (operand1 -> operand1 operator2 operand2 .)
    ELSIF           reduce using rule 93 (operand1 -> operand1 operator2 operand2 .)
    RPAREN          reduce using rule 93 (operand1 -> operand1 operator2 operand2 .)
    LBRACKET        reduce using rule 93 (operand1 -> operand1 operator2 operand2 .)
    TIMES           shift and go to state 137
    DIVIDE          shift and go to state 134
    MODULO          shift and go to state 136

    arithmetic_multiplicative_operator shift and go to state 135

state 167

    (86) then_expression -> THEN . expression
    (82) expression -> . operand0
    (83) expression -> . conditional_expression
    (90) operand0 -> . operand1
    (91) operand0 -> . operand0 operator1 operand1
    (84) conditional_expression -> . IF expression then_expression else_expression FI
    (85) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (92) operand1 -> . operand2
    (93) operand1 -> . operand1 operator2 operand2
    (94) operand2 -> . operand3
    (95) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (96) operand3 -> . monadic_operator operand4
    (97) operand3 -> . operand4
    (104) monadic_operator -> . MINUS
    (105) monadic_operator -> . NOT
    (98) operand4 -> . array_location
    (99) operand4 -> . referenced_location
    (100) operand4 -> . primitive_value
    (81) array_location -> . location
    (106) referenced_location -> . ARROW array_location
    (123) primitive_value -> . literal
    (65) location -> . identifier
    (66) location -> . dereferenced_reference
    (67) location -> . string_element
    (68) location -> . string_slice
    (69) location -> . array_element
    (70) location -> . array_slice
    (124) literal -> . integer_literal
    (125) literal -> . boolean_literal
    (126) literal -> . character_literal
    (127) literal -> . empty_literal
    (128) literal -> . character_string_literal
    (22) identifier -> . ID
    (71) dereferenced_reference -> . array_location ARROW
    (72) string_element -> . identifier LBRACKET start_element LBRACKET
    (74) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (77) array_element -> . array_location LBRACKET expression_list RBRACKET
    (80) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (129) integer_literal -> . ICONST
    (130) boolean_literal -> . TRUE
    (131) boolean_literal -> . FALSE
    (132) character_literal -> . CCONST
    (133) empty_literal -> . NULL
    (134) character_string_literal -> . SCONST

    IF              shift and go to state 99
    MINUS           shift and go to state 90
    NOT             shift and go to state 96
    ARROW           shift and go to state 72
    ID              shift and go to state 15
    ICONST          shift and go to state 89
    TRUE            shift and go to state 87
    FALSE           shift and go to state 80
    CCONST          shift and go to state 91
    NULL            shift and go to state 97
    SCONST          shift and go to state 95

    monadic_operator               shift and go to state 93
    character_literal              shift and go to state 85
    character_string_literal       shift and go to state 94
    identifier                     shift and go to state 84
    array_location                 shift and go to state 73
    literal                        shift and go to state 74
    dereferenced_reference         shift and go to state 75
    operand3                       shift and go to state 76
    integer_literal                shift and go to state 77
    array_slice                    shift and go to state 83
    primitive_value                shift and go to state 78
    referenced_location            shift and go to state 79
    string_slice                   shift and go to state 98
    string_element                 shift and go to state 81
    location                       shift and go to state 82
    conditional_expression         shift and go to state 100
    operand2                       shift and go to state 103
    empty_literal                  shift and go to state 101
    operand1                       shift and go to state 86
    operand4                       shift and go to state 102
    expression                     shift and go to state 186
    boolean_literal                shift and go to state 104
    operand0                       shift and go to state 105
    array_element                  shift and go to state 92

state 168

    (84) conditional_expression -> IF expression then_expression . else_expression FI
    (85) conditional_expression -> IF expression then_expression . elsif_expression else_expression FI
    (87) else_expression -> . ELSE expression
    (88) elsif_expression -> . ELSIF expression then_expression
    (89) elsif_expression -> . elsif_expression ELSIF expression then_expression

    ELSE            shift and go to state 188
    ELSIF           shift and go to state 190
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

    else_expression                shift and go to state 189
    elsif_expression               shift and go to state 187

state 169

<<<<<<< HEAD
    (41) discrete_range_mode -> discrete_mode LPAREN . literal_range RPAREN
    (42) literal_range -> . lower_bound COLON upper_bound
    (43) lower_bound -> . expression
    (73) expression -> . operand0
    (74) expression -> . conditional_expression
    (82) operand0 -> . operand1
    (83) operand0 -> . operand0 operator1 operand1
    (76) conditional_expression -> . IF expression then_expression else_expression FI
    (77) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (84) operand1 -> . operand2
    (85) operand1 -> . operand1 operator2 operand2
    (86) operand2 -> . operand3
    (87) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (88) operand3 -> . monadic_operator operand4
    (89) operand3 -> . operand4
    (96) monadic_operator -> . MINUS
    (97) monadic_operator -> . NOT
    (90) operand4 -> . array_location
    (91) operand4 -> . referenced_location
    (92) operand4 -> . primitive_value
    (72) array_location -> . location
    (98) referenced_location -> . ARROW array_location
    (115) primitive_value -> . literal
    (116) primitive_value -> . value_array_element
    (117) primitive_value -> . value_array_slice
    (118) primitive_value -> . parenthesized_expression
    (56) location -> . identifier
    (57) location -> . dereferenced_reference
    (58) location -> . string_element
    (59) location -> . string_slice
    (60) location -> . array_element
    (61) location -> . array_slice
    (119) literal -> . integer_literal
    (120) literal -> . boolean_literal
    (121) literal -> . character_literal
    (122) literal -> . empty_literal
    (123) literal -> . character_string_literal
    (124) value_array_element -> . primitive_value LBRACKET expression_list RBRACKET
    (125) value_array_slice -> . primitive_value LBRACKET expression COLON expression RBRACKET
    (75) parenthesized_expression -> . LPAREN expression RPAREN
    (22) identifier -> . ID
    (62) dereferenced_reference -> . array_location ARROW
    (63) string_element -> . identifier LBRACKET start_element LBRACKET
    (65) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (68) array_element -> . array_location LBRACKET expression_list RBRACKET
    (71) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (126) integer_literal -> . ICONST
    (127) boolean_literal -> . TRUE
    (128) boolean_literal -> . FALSE
    (129) character_literal -> . CCONST
    (130) empty_literal -> . NULL
    (131) character_string_literal -> . SCONST

    IF              shift and go to state 31
    MINUS           shift and go to state 36
    NOT             shift and go to state 35
    ARROW           shift and go to state 45
    LPAREN          shift and go to state 44
    ID              shift and go to state 21
    ICONST          shift and go to state 40
    TRUE            shift and go to state 55
    FALSE           shift and go to state 53
    CCONST          shift and go to state 34
    NULL            shift and go to state 27
    SCONST          shift and go to state 52

    location                       shift and go to state 6
    monadic_operator               shift and go to state 47
    operand2                       shift and go to state 49
    operand1                       shift and go to state 25
    expression                     shift and go to state 194
    character_literal              shift and go to state 41
    conditional_expression         shift and go to state 28
    referenced_location            shift and go to state 29
    parenthesized_expression       shift and go to state 30
    array_slice                    shift and go to state 15
    integer_literal                shift and go to state 32
    empty_literal                  shift and go to state 50
    literal_range                  shift and go to state 204
    operand3                       shift and go to state 33
    string_slice                   shift and go to state 3
    value_array_element            shift and go to state 48
    boolean_literal                shift and go to state 51
    array_location                 shift and go to state 46
    literal                        shift and go to state 37
    operand0                       shift and go to state 38
    primitive_value                shift and go to state 39
    array_element                  shift and go to state 7
    value_array_slice              shift and go to state 42
    operand4                       shift and go to state 54
    string_element                 shift and go to state 1
    lower_bound                    shift and go to state 196
    character_string_literal       shift and go to state 43
    dereferenced_reference         shift and go to state 20
    identifier                     shift and go to state 56

state 170

    (70) expression_list -> expression COMMA . expression_list
    (69) expression_list -> . expression
    (70) expression_list -> . expression COMMA expression_list
    (73) expression -> . operand0
    (74) expression -> . conditional_expression
    (82) operand0 -> . operand1
    (83) operand0 -> . operand0 operator1 operand1
    (76) conditional_expression -> . IF expression then_expression else_expression FI
    (77) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (84) operand1 -> . operand2
    (85) operand1 -> . operand1 operator2 operand2
    (86) operand2 -> . operand3
    (87) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (88) operand3 -> . monadic_operator operand4
    (89) operand3 -> . operand4
    (96) monadic_operator -> . MINUS
    (97) monadic_operator -> . NOT
    (90) operand4 -> . array_location
    (91) operand4 -> . referenced_location
    (92) operand4 -> . primitive_value
    (72) array_location -> . location
    (98) referenced_location -> . ARROW array_location
    (115) primitive_value -> . literal
    (116) primitive_value -> . value_array_element
    (117) primitive_value -> . value_array_slice
    (118) primitive_value -> . parenthesized_expression
    (56) location -> . identifier
    (57) location -> . dereferenced_reference
    (58) location -> . string_element
    (59) location -> . string_slice
    (60) location -> . array_element
    (61) location -> . array_slice
    (119) literal -> . integer_literal
    (120) literal -> . boolean_literal
    (121) literal -> . character_literal
    (122) literal -> . empty_literal
    (123) literal -> . character_string_literal
    (124) value_array_element -> . primitive_value LBRACKET expression_list RBRACKET
    (125) value_array_slice -> . primitive_value LBRACKET expression COLON expression RBRACKET
    (75) parenthesized_expression -> . LPAREN expression RPAREN
    (22) identifier -> . ID
    (62) dereferenced_reference -> . array_location ARROW
    (63) string_element -> . identifier LBRACKET start_element LBRACKET
    (65) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (68) array_element -> . array_location LBRACKET expression_list RBRACKET
    (71) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (126) integer_literal -> . ICONST
    (127) boolean_literal -> . TRUE
    (128) boolean_literal -> . FALSE
    (129) character_literal -> . CCONST
    (130) empty_literal -> . NULL
    (131) character_string_literal -> . SCONST

    IF              shift and go to state 31
    MINUS           shift and go to state 36
    NOT             shift and go to state 35
    ARROW           shift and go to state 45
    LPAREN          shift and go to state 44
    ID              shift and go to state 21
    ICONST          shift and go to state 40
    TRUE            shift and go to state 55
    FALSE           shift and go to state 53
    CCONST          shift and go to state 34
    NULL            shift and go to state 27
    SCONST          shift and go to state 52

    location                       shift and go to state 6
    monadic_operator               shift and go to state 47
    operand2                       shift and go to state 49
    value_array_element            shift and go to state 48
    operand1                       shift and go to state 25
    expression                     shift and go to state 205
    conditional_expression         shift and go to state 28
    referenced_location            shift and go to state 29
    expression_list                shift and go to state 206
    parenthesized_expression       shift and go to state 30
    integer_literal                shift and go to state 32
    empty_literal                  shift and go to state 50
    array_element                  shift and go to state 7
    operand3                       shift and go to state 33
    string_slice                   shift and go to state 3
    string_element                 shift and go to state 1
    boolean_literal                shift and go to state 51
    array_location                 shift and go to state 46
    literal                        shift and go to state 37
    operand0                       shift and go to state 38
    primitive_value                shift and go to state 39
    array_slice                    shift and go to state 15
    character_literal              shift and go to state 41
    value_array_slice              shift and go to state 42
    operand4                       shift and go to state 54
    character_string_literal       shift and go to state 43
    dereferenced_reference         shift and go to state 20
    identifier                     shift and go to state 56
=======
    (95) operand2 -> operand2 arithmetic_multiplicative_operator operand3 .

    TIMES           reduce using rule 95 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    DIVIDE          reduce using rule 95 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    MODULO          reduce using rule 95 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    PLUS            reduce using rule 95 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    MINUS           reduce using rule 95 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    CONCAT          reduce using rule 95 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    AND             reduce using rule 95 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    OR              reduce using rule 95 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    EQUAL           reduce using rule 95 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    NOTEQ           reduce using rule 95 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    GREATER         reduce using rule 95 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    GTEQUAL         reduce using rule 95 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    LESS            reduce using rule 95 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    LTEQUAL         reduce using rule 95 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    IN              reduce using rule 95 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    RBRACKET        reduce using rule 95 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    ELSE            reduce using rule 95 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    ELSIF           reduce using rule 95 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    COMMA           reduce using rule 95 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    SEMI            reduce using rule 95 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    COLON           reduce using rule 95 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    THEN            reduce using rule 95 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    LBRACKET        reduce using rule 95 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    RPAREN          reduce using rule 95 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    FI              reduce using rule 95 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)


state 170

    (91) operand0 -> operand0 operator1 operand1 .
    (93) operand1 -> operand1 . operator2 operand2
    (109) operator2 -> . arithmetic_additive_operator
    (110) operator2 -> . string_concatenation_operator
    (111) arithmetic_additive_operator -> . PLUS
    (112) arithmetic_additive_operator -> . MINUS
    (113) string_concatenation_operator -> . CONCAT

    AND             reduce using rule 91 (operand0 -> operand0 operator1 operand1 .)
    OR              reduce using rule 91 (operand0 -> operand0 operator1 operand1 .)
    EQUAL           reduce using rule 91 (operand0 -> operand0 operator1 operand1 .)
    NOTEQ           reduce using rule 91 (operand0 -> operand0 operator1 operand1 .)
    GREATER         reduce using rule 91 (operand0 -> operand0 operator1 operand1 .)
    GTEQUAL         reduce using rule 91 (operand0 -> operand0 operator1 operand1 .)
    LESS            reduce using rule 91 (operand0 -> operand0 operator1 operand1 .)
    LTEQUAL         reduce using rule 91 (operand0 -> operand0 operator1 operand1 .)
    IN              reduce using rule 91 (operand0 -> operand0 operator1 operand1 .)
    LBRACKET        reduce using rule 91 (operand0 -> operand0 operator1 operand1 .)
    COLON           reduce using rule 91 (operand0 -> operand0 operator1 operand1 .)
    RBRACKET        reduce using rule 91 (operand0 -> operand0 operator1 operand1 .)
    RPAREN          reduce using rule 91 (operand0 -> operand0 operator1 operand1 .)
    COMMA           reduce using rule 91 (operand0 -> operand0 operator1 operand1 .)
    SEMI            reduce using rule 91 (operand0 -> operand0 operator1 operand1 .)
    THEN            reduce using rule 91 (operand0 -> operand0 operator1 operand1 .)
    FI              reduce using rule 91 (operand0 -> operand0 operator1 operand1 .)
    ELSE            reduce using rule 91 (operand0 -> operand0 operator1 operand1 .)
    ELSIF           reduce using rule 91 (operand0 -> operand0 operator1 operand1 .)
    PLUS            shift and go to state 126
    MINUS           shift and go to state 131
    CONCAT          shift and go to state 130

    operator2                      shift and go to state 127
    arithmetic_additive_operator   shift and go to state 128
    string_concatenation_operator  shift and go to state 129

state 171

    (31) formal_parameter_list -> formal_parameter COMMA formal_parameter .
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

    RPAREN          reduce using rule 31 (formal_parameter_list -> formal_parameter COMMA formal_parameter .)

<<<<<<< HEAD
    (68) array_element -> array_location LBRACKET expression_list RBRACKET .

    ARROW           reduce using rule 68 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    LBRACKET        reduce using rule 68 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    TIMES           reduce using rule 68 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    DIVIDE          reduce using rule 68 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    MODULO          reduce using rule 68 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    PLUS            reduce using rule 68 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    MINUS           reduce using rule 68 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    CONCAT          reduce using rule 68 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    AND             reduce using rule 68 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    OR              reduce using rule 68 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    EQUAL           reduce using rule 68 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    NOTEQ           reduce using rule 68 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    GREATER         reduce using rule 68 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    GTEQUAL         reduce using rule 68 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    LESS            reduce using rule 68 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    LTEQUAL         reduce using rule 68 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    IN              reduce using rule 68 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    THEN            reduce using rule 68 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    RPAREN          reduce using rule 68 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    DCL             reduce using rule 68 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    SYN             reduce using rule 68 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    TYPE            reduce using rule 68 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    ID              reduce using rule 68 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    IF              reduce using rule 68 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    $end            reduce using rule 68 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    ELSE            reduce using rule 68 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    ELSIF           reduce using rule 68 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    FI              reduce using rule 68 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    COMMA           reduce using rule 68 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    RBRACKET        reduce using rule 68 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    COLON           reduce using rule 68 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    SEMI            reduce using rule 68 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    ASSIGN          reduce using rule 68 (array_element -> array_location LBRACKET expression_list RBRACKET .)


state 172
=======

state 172

    (34) result_spec -> RETURNS . LPAREN mode LOC RPAREN
    (35) result_spec -> RETURNS . LPAREN mode RPAREN

    LPAREN          shift and go to state 191
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

    (71) array_slice -> array_location LBRACKET lower_bound COLON . upper_bound RBRACKET
    (44) upper_bound -> . expression
    (73) expression -> . operand0
    (74) expression -> . conditional_expression
    (82) operand0 -> . operand1
    (83) operand0 -> . operand0 operator1 operand1
    (76) conditional_expression -> . IF expression then_expression else_expression FI
    (77) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (84) operand1 -> . operand2
    (85) operand1 -> . operand1 operator2 operand2
    (86) operand2 -> . operand3
    (87) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (88) operand3 -> . monadic_operator operand4
    (89) operand3 -> . operand4
    (96) monadic_operator -> . MINUS
    (97) monadic_operator -> . NOT
    (90) operand4 -> . array_location
    (91) operand4 -> . referenced_location
    (92) operand4 -> . primitive_value
    (72) array_location -> . location
    (98) referenced_location -> . ARROW array_location
    (115) primitive_value -> . literal
    (116) primitive_value -> . value_array_element
    (117) primitive_value -> . value_array_slice
    (118) primitive_value -> . parenthesized_expression
    (56) location -> . identifier
    (57) location -> . dereferenced_reference
    (58) location -> . string_element
    (59) location -> . string_slice
    (60) location -> . array_element
    (61) location -> . array_slice
    (119) literal -> . integer_literal
    (120) literal -> . boolean_literal
    (121) literal -> . character_literal
    (122) literal -> . empty_literal
    (123) literal -> . character_string_literal
    (124) value_array_element -> . primitive_value LBRACKET expression_list RBRACKET
    (125) value_array_slice -> . primitive_value LBRACKET expression COLON expression RBRACKET
    (75) parenthesized_expression -> . LPAREN expression RPAREN
    (22) identifier -> . ID
    (62) dereferenced_reference -> . array_location ARROW
    (63) string_element -> . identifier LBRACKET start_element LBRACKET
    (65) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (68) array_element -> . array_location LBRACKET expression_list RBRACKET
    (71) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (126) integer_literal -> . ICONST
    (127) boolean_literal -> . TRUE
    (128) boolean_literal -> . FALSE
    (129) character_literal -> . CCONST
    (130) empty_literal -> . NULL
    (131) character_string_literal -> . SCONST

    IF              shift and go to state 31
    MINUS           shift and go to state 36
    NOT             shift and go to state 35
    ARROW           shift and go to state 45
    LPAREN          shift and go to state 44
    ID              shift and go to state 21
    ICONST          shift and go to state 40
    TRUE            shift and go to state 55
    FALSE           shift and go to state 53
    CCONST          shift and go to state 34
    NULL            shift and go to state 27
    SCONST          shift and go to state 52

    location                       shift and go to state 6
    monadic_operator               shift and go to state 47
    operand2                       shift and go to state 49
    value_array_element            shift and go to state 48
    operand1                       shift and go to state 25
    expression                     shift and go to state 207
    conditional_expression         shift and go to state 28
    referenced_location            shift and go to state 29
    parenthesized_expression       shift and go to state 30
    array_slice                    shift and go to state 15
    integer_literal                shift and go to state 32
    empty_literal                  shift and go to state 50
    array_element                  shift and go to state 7
    operand3                       shift and go to state 33
    string_slice                   shift and go to state 3
    upper_bound                    shift and go to state 208
    boolean_literal                shift and go to state 51
    array_location                 shift and go to state 46
    literal                        shift and go to state 37
    operand0                       shift and go to state 38
    primitive_value                shift and go to state 39
    character_literal              shift and go to state 41
    value_array_slice              shift and go to state 42
    operand4                       shift and go to state 54
    string_element                 shift and go to state 1
    character_string_literal       shift and go to state 43
    dereferenced_reference         shift and go to state 20
    identifier                     shift and go to state 56

state 173

<<<<<<< HEAD
    (25) newmode_list -> mode_definition COMMA newmode_list .

    SEMI            reduce using rule 25 (newmode_list -> mode_definition COMMA newmode_list .)
=======
    (28) procedure_definition -> PROC LPAREN formal_parameter_list RPAREN result_spec . SEMI statement_nullable END SEMI

    SEMI            shift and go to state 192
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 174

<<<<<<< HEAD
    (26) mode_definition -> identifier_list ASSIGN mode .

    COMMA           reduce using rule 26 (mode_definition -> identifier_list ASSIGN mode .)
    SEMI            reduce using rule 26 (mode_definition -> identifier_list ASSIGN mode .)


state 175

    (16) declaration_list -> declaration COMMA declaration_list .

    SEMI            reduce using rule 16 (declaration_list -> declaration COMMA declaration_list .)
=======
    (29) procedure_definition -> PROC LPAREN formal_parameter_list RPAREN SEMI . statement_nullable END SEMI
    (3) statement_nullable -> . statement statement_nullable
    (4) statement_nullable -> . empty
    (5) statement -> . declaration_statement
    (6) statement -> . synonym_statement
    (7) statement -> . newmode_statement
    (8) statement -> . procedure_statement
    (135) empty -> .
    (14) declaration_statement -> . DCL declaration_list SEMI
    (9) synonym_statement -> . SYN synonym_list SEMI
    (23) newmode_statement -> . TYPE newmode_list SEMI
    (27) procedure_statement -> . ID COLON procedure_definition

    END             reduce using rule 135 (empty -> .)
    DCL             shift and go to state 7
    SYN             shift and go to state 11
    TYPE            shift and go to state 4
    ID              shift and go to state 2

    synonym_statement              shift and go to state 6
    procedure_statement            shift and go to state 5
    newmode_statement              shift and go to state 8
    statement_nullable             shift and go to state 193
    declaration_statement          shift and go to state 1
    statement                      shift and go to state 22
    empty                          shift and go to state 21

state 175

    (32) formal_parameter -> identifier_list mode LOC .

    COMMA           reduce using rule 32 (formal_parameter -> identifier_list mode LOC .)
    RPAREN          reduce using rule 32 (formal_parameter -> identifier_list mode LOC .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 176

<<<<<<< HEAD
    (17) declaration -> identifier_list mode initialization .

    COMMA           reduce using rule 17 (declaration -> identifier_list mode initialization .)
    SEMI            reduce using rule 17 (declaration -> identifier_list mode initialization .)
=======
    (53) upper_bound -> expression .

    RPAREN          reduce using rule 53 (upper_bound -> expression .)
    COMMA           reduce using rule 53 (upper_bound -> expression .)
    RBRACKET        reduce using rule 53 (upper_bound -> expression .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 177

<<<<<<< HEAD
    (19) initialization -> ASSIGN . expression
    (73) expression -> . operand0
    (74) expression -> . conditional_expression
    (82) operand0 -> . operand1
    (83) operand0 -> . operand0 operator1 operand1
    (76) conditional_expression -> . IF expression then_expression else_expression FI
    (77) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (84) operand1 -> . operand2
    (85) operand1 -> . operand1 operator2 operand2
    (86) operand2 -> . operand3
    (87) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (88) operand3 -> . monadic_operator operand4
    (89) operand3 -> . operand4
    (96) monadic_operator -> . MINUS
    (97) monadic_operator -> . NOT
    (90) operand4 -> . array_location
    (91) operand4 -> . referenced_location
    (92) operand4 -> . primitive_value
    (72) array_location -> . location
    (98) referenced_location -> . ARROW array_location
    (115) primitive_value -> . literal
    (116) primitive_value -> . value_array_element
    (117) primitive_value -> . value_array_slice
    (118) primitive_value -> . parenthesized_expression
    (56) location -> . identifier
    (57) location -> . dereferenced_reference
    (58) location -> . string_element
    (59) location -> . string_slice
    (60) location -> . array_element
    (61) location -> . array_slice
    (119) literal -> . integer_literal
    (120) literal -> . boolean_literal
    (121) literal -> . character_literal
    (122) literal -> . empty_literal
    (123) literal -> . character_string_literal
    (124) value_array_element -> . primitive_value LBRACKET expression_list RBRACKET
    (125) value_array_slice -> . primitive_value LBRACKET expression COLON expression RBRACKET
    (75) parenthesized_expression -> . LPAREN expression RPAREN
    (22) identifier -> . ID
    (62) dereferenced_reference -> . array_location ARROW
    (63) string_element -> . identifier LBRACKET start_element LBRACKET
    (65) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (68) array_element -> . array_location LBRACKET expression_list RBRACKET
    (71) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (126) integer_literal -> . ICONST
    (127) boolean_literal -> . TRUE
    (128) boolean_literal -> . FALSE
    (129) character_literal -> . CCONST
    (130) empty_literal -> . NULL
    (131) character_string_literal -> . SCONST

    IF              shift and go to state 31
    MINUS           shift and go to state 36
    NOT             shift and go to state 35
    ARROW           shift and go to state 45
    LPAREN          shift and go to state 44
    ID              shift and go to state 21
    ICONST          shift and go to state 40
    TRUE            shift and go to state 55
    FALSE           shift and go to state 53
    CCONST          shift and go to state 34
    NULL            shift and go to state 27
    SCONST          shift and go to state 52

    location                       shift and go to state 6
    monadic_operator               shift and go to state 47
    operand2                       shift and go to state 49
    value_array_element            shift and go to state 48
    operand1                       shift and go to state 25
    expression                     shift and go to state 209
    conditional_expression         shift and go to state 28
    referenced_location            shift and go to state 29
    parenthesized_expression       shift and go to state 30
    array_slice                    shift and go to state 15
    integer_literal                shift and go to state 32
    empty_literal                  shift and go to state 50
    array_element                  shift and go to state 7
    operand3                       shift and go to state 33
    string_slice                   shift and go to state 3
    string_element                 shift and go to state 1
    boolean_literal                shift and go to state 51
    array_location                 shift and go to state 46
    literal                        shift and go to state 37
    operand0                       shift and go to state 38
    primitive_value                shift and go to state 39
    character_literal              shift and go to state 41
    value_array_slice              shift and go to state 42
    operand4                       shift and go to state 54
    character_string_literal       shift and go to state 43
    dereferenced_reference         shift and go to state 20
    identifier                     shift and go to state 56

state 178

    (65) string_slice -> identifier LBRACKET left_element COLON . right_element RBRACKET
    (67) right_element -> . expression
    (73) expression -> . operand0
    (74) expression -> . conditional_expression
    (82) operand0 -> . operand1
    (83) operand0 -> . operand0 operator1 operand1
    (76) conditional_expression -> . IF expression then_expression else_expression FI
    (77) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (84) operand1 -> . operand2
    (85) operand1 -> . operand1 operator2 operand2
    (86) operand2 -> . operand3
    (87) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (88) operand3 -> . monadic_operator operand4
    (89) operand3 -> . operand4
    (96) monadic_operator -> . MINUS
    (97) monadic_operator -> . NOT
    (90) operand4 -> . array_location
    (91) operand4 -> . referenced_location
    (92) operand4 -> . primitive_value
    (72) array_location -> . location
    (98) referenced_location -> . ARROW array_location
    (115) primitive_value -> . literal
    (116) primitive_value -> . value_array_element
    (117) primitive_value -> . value_array_slice
    (118) primitive_value -> . parenthesized_expression
    (56) location -> . identifier
    (57) location -> . dereferenced_reference
    (58) location -> . string_element
    (59) location -> . string_slice
    (60) location -> . array_element
    (61) location -> . array_slice
    (119) literal -> . integer_literal
    (120) literal -> . boolean_literal
    (121) literal -> . character_literal
    (122) literal -> . empty_literal
    (123) literal -> . character_string_literal
    (124) value_array_element -> . primitive_value LBRACKET expression_list RBRACKET
    (125) value_array_slice -> . primitive_value LBRACKET expression COLON expression RBRACKET
    (75) parenthesized_expression -> . LPAREN expression RPAREN
    (22) identifier -> . ID
    (62) dereferenced_reference -> . array_location ARROW
    (63) string_element -> . identifier LBRACKET start_element LBRACKET
    (65) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (68) array_element -> . array_location LBRACKET expression_list RBRACKET
    (71) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (126) integer_literal -> . ICONST
    (127) boolean_literal -> . TRUE
    (128) boolean_literal -> . FALSE
    (129) character_literal -> . CCONST
    (130) empty_literal -> . NULL
    (131) character_string_literal -> . SCONST

    IF              shift and go to state 31
    MINUS           shift and go to state 36
    NOT             shift and go to state 35
    ARROW           shift and go to state 45
    LPAREN          shift and go to state 44
    ID              shift and go to state 21
    ICONST          shift and go to state 40
    TRUE            shift and go to state 55
    FALSE           shift and go to state 53
    CCONST          shift and go to state 34
    NULL            shift and go to state 27
    SCONST          shift and go to state 52

    location                       shift and go to state 6
    monadic_operator               shift and go to state 47
    conditional_expression         shift and go to state 28
    value_array_element            shift and go to state 48
    operand1                       shift and go to state 25
    expression                     shift and go to state 210
    operand2                       shift and go to state 49
    referenced_location            shift and go to state 29
    parenthesized_expression       shift and go to state 30
    array_slice                    shift and go to state 15
    integer_literal                shift and go to state 32
    empty_literal                  shift and go to state 50
    array_element                  shift and go to state 7
    operand3                       shift and go to state 33
    string_slice                   shift and go to state 3
    string_element                 shift and go to state 1
    right_element                  shift and go to state 211
    boolean_literal                shift and go to state 51
    array_location                 shift and go to state 46
    literal                        shift and go to state 37
    operand0                       shift and go to state 38
    primitive_value                shift and go to state 39
    character_literal              shift and go to state 41
    value_array_slice              shift and go to state 42
    operand4                       shift and go to state 54
    character_string_literal       shift and go to state 43
    dereferenced_reference         shift and go to state 20
    identifier                     shift and go to state 56

state 179

    (63) string_element -> identifier LBRACKET start_element LBRACKET .

    ARROW           reduce using rule 63 (string_element -> identifier LBRACKET start_element LBRACKET .)
    LBRACKET        reduce using rule 63 (string_element -> identifier LBRACKET start_element LBRACKET .)
    TIMES           reduce using rule 63 (string_element -> identifier LBRACKET start_element LBRACKET .)
    DIVIDE          reduce using rule 63 (string_element -> identifier LBRACKET start_element LBRACKET .)
    MODULO          reduce using rule 63 (string_element -> identifier LBRACKET start_element LBRACKET .)
    PLUS            reduce using rule 63 (string_element -> identifier LBRACKET start_element LBRACKET .)
    MINUS           reduce using rule 63 (string_element -> identifier LBRACKET start_element LBRACKET .)
    CONCAT          reduce using rule 63 (string_element -> identifier LBRACKET start_element LBRACKET .)
    AND             reduce using rule 63 (string_element -> identifier LBRACKET start_element LBRACKET .)
    OR              reduce using rule 63 (string_element -> identifier LBRACKET start_element LBRACKET .)
    EQUAL           reduce using rule 63 (string_element -> identifier LBRACKET start_element LBRACKET .)
    NOTEQ           reduce using rule 63 (string_element -> identifier LBRACKET start_element LBRACKET .)
    GREATER         reduce using rule 63 (string_element -> identifier LBRACKET start_element LBRACKET .)
    GTEQUAL         reduce using rule 63 (string_element -> identifier LBRACKET start_element LBRACKET .)
    LESS            reduce using rule 63 (string_element -> identifier LBRACKET start_element LBRACKET .)
    LTEQUAL         reduce using rule 63 (string_element -> identifier LBRACKET start_element LBRACKET .)
    IN              reduce using rule 63 (string_element -> identifier LBRACKET start_element LBRACKET .)
    RBRACKET        reduce using rule 63 (string_element -> identifier LBRACKET start_element LBRACKET .)
    ASSIGN          reduce using rule 63 (string_element -> identifier LBRACKET start_element LBRACKET .)
    DCL             reduce using rule 63 (string_element -> identifier LBRACKET start_element LBRACKET .)
    SYN             reduce using rule 63 (string_element -> identifier LBRACKET start_element LBRACKET .)
    TYPE            reduce using rule 63 (string_element -> identifier LBRACKET start_element LBRACKET .)
    ID              reduce using rule 63 (string_element -> identifier LBRACKET start_element LBRACKET .)
    IF              reduce using rule 63 (string_element -> identifier LBRACKET start_element LBRACKET .)
    $end            reduce using rule 63 (string_element -> identifier LBRACKET start_element LBRACKET .)
    ELSE            reduce using rule 63 (string_element -> identifier LBRACKET start_element LBRACKET .)
    ELSIF           reduce using rule 63 (string_element -> identifier LBRACKET start_element LBRACKET .)
    FI              reduce using rule 63 (string_element -> identifier LBRACKET start_element LBRACKET .)
    THEN            reduce using rule 63 (string_element -> identifier LBRACKET start_element LBRACKET .)
    RPAREN          reduce using rule 63 (string_element -> identifier LBRACKET start_element LBRACKET .)
    COMMA           reduce using rule 63 (string_element -> identifier LBRACKET start_element LBRACKET .)
    COLON           reduce using rule 63 (string_element -> identifier LBRACKET start_element LBRACKET .)
    SEMI            reduce using rule 63 (string_element -> identifier LBRACKET start_element LBRACKET .)
=======
    (51) literal_range -> lower_bound COLON upper_bound .

    COMMA           reduce using rule 51 (literal_range -> lower_bound COLON upper_bound .)
    RBRACKET        reduce using rule 51 (literal_range -> lower_bound COLON upper_bound .)
    RPAREN          reduce using rule 51 (literal_range -> lower_bound COLON upper_bound .)


state 178

    (64) element_mode -> mode .

    ASSIGN          reduce using rule 64 (element_mode -> mode .)
    COMMA           reduce using rule 64 (element_mode -> mode .)
    SEMI            reduce using rule 64 (element_mode -> mode .)
    LOC             reduce using rule 64 (element_mode -> mode .)
    RPAREN          reduce using rule 64 (element_mode -> mode .)


state 179

    (59) array_mode -> ARRAY LBRACKET index_mode_list RBRACKET element_mode .

    ASSIGN          reduce using rule 59 (array_mode -> ARRAY LBRACKET index_mode_list RBRACKET element_mode .)
    COMMA           reduce using rule 59 (array_mode -> ARRAY LBRACKET index_mode_list RBRACKET element_mode .)
    SEMI            reduce using rule 59 (array_mode -> ARRAY LBRACKET index_mode_list RBRACKET element_mode .)
    LOC             reduce using rule 59 (array_mode -> ARRAY LBRACKET index_mode_list RBRACKET element_mode .)
    RPAREN          reduce using rule 59 (array_mode -> ARRAY LBRACKET index_mode_list RBRACKET element_mode .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 180

<<<<<<< HEAD
    (146) else_clause -> ELSE action_statement_list .

    FI              reduce using rule 146 (else_clause -> ELSE action_statement_list .)

=======
    (61) index_mode_list -> index_mode COMMA index_mode_list .
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

    RBRACKET        reduce using rule 61 (index_mode_list -> index_mode COMMA index_mode_list .)

<<<<<<< HEAD
    (143) if_action -> IF expression then_clause else_clause FI .

    ELSE            reduce using rule 143 (if_action -> IF expression then_clause else_clause FI .)
    ELSIF           reduce using rule 143 (if_action -> IF expression then_clause else_clause FI .)
    DCL             reduce using rule 143 (if_action -> IF expression then_clause else_clause FI .)
    SYN             reduce using rule 143 (if_action -> IF expression then_clause else_clause FI .)
    TYPE            reduce using rule 143 (if_action -> IF expression then_clause else_clause FI .)
    ID              reduce using rule 143 (if_action -> IF expression then_clause else_clause FI .)
    IF              reduce using rule 143 (if_action -> IF expression then_clause else_clause FI .)
    $end            reduce using rule 143 (if_action -> IF expression then_clause else_clause FI .)
    FI              reduce using rule 143 (if_action -> IF expression then_clause else_clause FI .)
=======

state 181
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

    (79) expression_list -> expression COMMA . expression_list
    (78) expression_list -> . expression
    (79) expression_list -> . expression COMMA expression_list
    (82) expression -> . operand0
    (83) expression -> . conditional_expression
    (90) operand0 -> . operand1
    (91) operand0 -> . operand0 operator1 operand1
    (84) conditional_expression -> . IF expression then_expression else_expression FI
    (85) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (92) operand1 -> . operand2
    (93) operand1 -> . operand1 operator2 operand2
    (94) operand2 -> . operand3
    (95) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (96) operand3 -> . monadic_operator operand4
    (97) operand3 -> . operand4
    (104) monadic_operator -> . MINUS
    (105) monadic_operator -> . NOT
    (98) operand4 -> . array_location
    (99) operand4 -> . referenced_location
    (100) operand4 -> . primitive_value
    (81) array_location -> . location
    (106) referenced_location -> . ARROW array_location
    (123) primitive_value -> . literal
    (65) location -> . identifier
    (66) location -> . dereferenced_reference
    (67) location -> . string_element
    (68) location -> . string_slice
    (69) location -> . array_element
    (70) location -> . array_slice
    (124) literal -> . integer_literal
    (125) literal -> . boolean_literal
    (126) literal -> . character_literal
    (127) literal -> . empty_literal
    (128) literal -> . character_string_literal
    (22) identifier -> . ID
    (71) dereferenced_reference -> . array_location ARROW
    (72) string_element -> . identifier LBRACKET start_element LBRACKET
    (74) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (77) array_element -> . array_location LBRACKET expression_list RBRACKET
    (80) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (129) integer_literal -> . ICONST
    (130) boolean_literal -> . TRUE
    (131) boolean_literal -> . FALSE
    (132) character_literal -> . CCONST
    (133) empty_literal -> . NULL
    (134) character_string_literal -> . SCONST

    IF              shift and go to state 99
    MINUS           shift and go to state 90
    NOT             shift and go to state 96
    ARROW           shift and go to state 72
    ID              shift and go to state 15
    ICONST          shift and go to state 89
    TRUE            shift and go to state 87
    FALSE           shift and go to state 80
    CCONST          shift and go to state 91
    NULL            shift and go to state 97
    SCONST          shift and go to state 95

    monadic_operator               shift and go to state 93
    character_literal              shift and go to state 85
    character_string_literal       shift and go to state 94
    identifier                     shift and go to state 84
    array_location                 shift and go to state 73
    literal                        shift and go to state 74
    dereferenced_reference         shift and go to state 75
    operand3                       shift and go to state 76
    integer_literal                shift and go to state 77
    array_slice                    shift and go to state 83
    primitive_value                shift and go to state 78
    referenced_location            shift and go to state 79
    string_slice                   shift and go to state 98
    string_element                 shift and go to state 81
    location                       shift and go to state 82
    expression_list                shift and go to state 195
    conditional_expression         shift and go to state 100
    operand2                       shift and go to state 103
    empty_literal                  shift and go to state 101
    operand1                       shift and go to state 86
    operand4                       shift and go to state 102
    expression                     shift and go to state 194
    boolean_literal                shift and go to state 104
    operand0                       shift and go to state 105
    array_element                  shift and go to state 92

state 182

<<<<<<< HEAD
    (147) else_clause -> ELSIF expression . then_clause else_clause
    (148) else_clause -> ELSIF expression . then_clause
    (145) then_clause -> . THEN action_statement_list

    THEN            shift and go to state 90

    then_clause                    shift and go to state 212

state 183

    (150) action_statement_nullable -> action_statement . action_statement_nullable
    (150) action_statement_nullable -> . action_statement action_statement_nullable
    (151) action_statement_nullable -> . empty
    (132) action_statement -> . identifier COLON action
    (133) action_statement -> . action
    (152) empty -> .
    (22) identifier -> . ID
    (134) action -> . bracketed_action
    (135) action -> . assignment_action
    (136) bracketed_action -> . if_action
    (137) assignment_action -> . array_location assigning_operator expression
    (143) if_action -> . IF expression then_clause else_clause FI
    (144) if_action -> . IF expression then_clause
    (72) array_location -> . location
    (56) location -> . identifier
    (57) location -> . dereferenced_reference
    (58) location -> . string_element
    (59) location -> . string_slice
    (60) location -> . array_element
    (61) location -> . array_slice
    (62) dereferenced_reference -> . array_location ARROW
    (63) string_element -> . identifier LBRACKET start_element LBRACKET
    (65) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (68) array_element -> . array_location LBRACKET expression_list RBRACKET
    (71) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
    ELSE            reduce using rule 152 (empty -> .)
    ELSIF           reduce using rule 152 (empty -> .)
    DCL             reduce using rule 152 (empty -> .)
    SYN             reduce using rule 152 (empty -> .)
    TYPE            reduce using rule 152 (empty -> .)
    $end            reduce using rule 152 (empty -> .)
    FI              reduce using rule 152 (empty -> .)
    ID              shift and go to state 21
    IF              shift and go to state 4

  ! ID              [ reduce using rule 152 (empty -> .) ]
  ! IF              [ reduce using rule 152 (empty -> .) ]

    location                       shift and go to state 6
    string_element                 shift and go to state 1
    string_slice                   shift and go to state 3
    array_slice                    shift and go to state 15
    assignment_action              shift and go to state 11
    if_action                      shift and go to state 17
    array_location                 shift and go to state 13
    array_element                  shift and go to state 7
    action                         shift and go to state 8
    bracketed_action               shift and go to state 22
    action_statement               shift and go to state 183
    action_statement_nullable      shift and go to state 213
    empty                          shift and go to state 184
    dereferenced_reference         shift and go to state 20
    identifier                     shift and go to state 24

state 184

    (151) action_statement_nullable -> empty .

    ELSE            reduce using rule 151 (action_statement_nullable -> empty .)
    ELSIF           reduce using rule 151 (action_statement_nullable -> empty .)
    DCL             reduce using rule 151 (action_statement_nullable -> empty .)
    SYN             reduce using rule 151 (action_statement_nullable -> empty .)
    TYPE            reduce using rule 151 (action_statement_nullable -> empty .)
    ID              reduce using rule 151 (action_statement_nullable -> empty .)
    IF              reduce using rule 151 (action_statement_nullable -> empty .)
    $end            reduce using rule 151 (action_statement_nullable -> empty .)
    FI              reduce using rule 151 (action_statement_nullable -> empty .)


state 185

    (149) action_statement_list -> action_statement action_statement_nullable .

    ELSE            reduce using rule 149 (action_statement_list -> action_statement action_statement_nullable .)
    ELSIF           reduce using rule 149 (action_statement_list -> action_statement action_statement_nullable .)
    DCL             reduce using rule 149 (action_statement_list -> action_statement action_statement_nullable .)
    SYN             reduce using rule 149 (action_statement_list -> action_statement action_statement_nullable .)
    TYPE            reduce using rule 149 (action_statement_list -> action_statement action_statement_nullable .)
    ID              reduce using rule 149 (action_statement_list -> action_statement action_statement_nullable .)
    IF              reduce using rule 149 (action_statement_list -> action_statement action_statement_nullable .)
    $end            reduce using rule 149 (action_statement_list -> action_statement action_statement_nullable .)
    FI              reduce using rule 149 (action_statement_list -> action_statement action_statement_nullable .)
=======
    (80) array_slice -> array_location LBRACKET lower_bound COLON . upper_bound RBRACKET
    (53) upper_bound -> . expression
    (82) expression -> . operand0
    (83) expression -> . conditional_expression
    (90) operand0 -> . operand1
    (91) operand0 -> . operand0 operator1 operand1
    (84) conditional_expression -> . IF expression then_expression else_expression FI
    (85) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (92) operand1 -> . operand2
    (93) operand1 -> . operand1 operator2 operand2
    (94) operand2 -> . operand3
    (95) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (96) operand3 -> . monadic_operator operand4
    (97) operand3 -> . operand4
    (104) monadic_operator -> . MINUS
    (105) monadic_operator -> . NOT
    (98) operand4 -> . array_location
    (99) operand4 -> . referenced_location
    (100) operand4 -> . primitive_value
    (81) array_location -> . location
    (106) referenced_location -> . ARROW array_location
    (123) primitive_value -> . literal
    (65) location -> . identifier
    (66) location -> . dereferenced_reference
    (67) location -> . string_element
    (68) location -> . string_slice
    (69) location -> . array_element
    (70) location -> . array_slice
    (124) literal -> . integer_literal
    (125) literal -> . boolean_literal
    (126) literal -> . character_literal
    (127) literal -> . empty_literal
    (128) literal -> . character_string_literal
    (22) identifier -> . ID
    (71) dereferenced_reference -> . array_location ARROW
    (72) string_element -> . identifier LBRACKET start_element LBRACKET
    (74) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (77) array_element -> . array_location LBRACKET expression_list RBRACKET
    (80) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (129) integer_literal -> . ICONST
    (130) boolean_literal -> . TRUE
    (131) boolean_literal -> . FALSE
    (132) character_literal -> . CCONST
    (133) empty_literal -> . NULL
    (134) character_string_literal -> . SCONST

    IF              shift and go to state 99
    MINUS           shift and go to state 90
    NOT             shift and go to state 96
    ARROW           shift and go to state 72
    ID              shift and go to state 15
    ICONST          shift and go to state 89
    TRUE            shift and go to state 87
    FALSE           shift and go to state 80
    CCONST          shift and go to state 91
    NULL            shift and go to state 97
    SCONST          shift and go to state 95

    monadic_operator               shift and go to state 93
    character_literal              shift and go to state 85
    character_string_literal       shift and go to state 94
    identifier                     shift and go to state 84
    array_location                 shift and go to state 73
    literal                        shift and go to state 74
    dereferenced_reference         shift and go to state 75
    operand3                       shift and go to state 76
    integer_literal                shift and go to state 77
    array_slice                    shift and go to state 83
    primitive_value                shift and go to state 78
    referenced_location            shift and go to state 79
    string_slice                   shift and go to state 98
    string_element                 shift and go to state 81
    location                       shift and go to state 82
    conditional_expression         shift and go to state 100
    operand2                       shift and go to state 103
    upper_bound                    shift and go to state 196
    empty_literal                  shift and go to state 101
    operand1                       shift and go to state 86
    operand4                       shift and go to state 102
    expression                     shift and go to state 176
    boolean_literal                shift and go to state 104
    operand0                       shift and go to state 105
    array_element                  shift and go to state 92

state 183

    (77) array_element -> array_location LBRACKET expression_list RBRACKET .

    ARROW           reduce using rule 77 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    LBRACKET        reduce using rule 77 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    TIMES           reduce using rule 77 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    DIVIDE          reduce using rule 77 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    MODULO          reduce using rule 77 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    PLUS            reduce using rule 77 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    MINUS           reduce using rule 77 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    CONCAT          reduce using rule 77 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    AND             reduce using rule 77 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    OR              reduce using rule 77 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    EQUAL           reduce using rule 77 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    NOTEQ           reduce using rule 77 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    GREATER         reduce using rule 77 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    GTEQUAL         reduce using rule 77 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    LESS            reduce using rule 77 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    LTEQUAL         reduce using rule 77 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    IN              reduce using rule 77 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    RPAREN          reduce using rule 77 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    COMMA           reduce using rule 77 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    RBRACKET        reduce using rule 77 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    SEMI            reduce using rule 77 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    COLON           reduce using rule 77 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    THEN            reduce using rule 77 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    ELSE            reduce using rule 77 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    ELSIF           reduce using rule 77 (array_element -> array_location LBRACKET expression_list RBRACKET .)
    FI              reduce using rule 77 (array_element -> array_location LBRACKET expression_list RBRACKET .)


state 184

    (74) string_slice -> identifier LBRACKET left_element COLON . right_element RBRACKET
    (76) right_element -> . expression
    (82) expression -> . operand0
    (83) expression -> . conditional_expression
    (90) operand0 -> . operand1
    (91) operand0 -> . operand0 operator1 operand1
    (84) conditional_expression -> . IF expression then_expression else_expression FI
    (85) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (92) operand1 -> . operand2
    (93) operand1 -> . operand1 operator2 operand2
    (94) operand2 -> . operand3
    (95) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (96) operand3 -> . monadic_operator operand4
    (97) operand3 -> . operand4
    (104) monadic_operator -> . MINUS
    (105) monadic_operator -> . NOT
    (98) operand4 -> . array_location
    (99) operand4 -> . referenced_location
    (100) operand4 -> . primitive_value
    (81) array_location -> . location
    (106) referenced_location -> . ARROW array_location
    (123) primitive_value -> . literal
    (65) location -> . identifier
    (66) location -> . dereferenced_reference
    (67) location -> . string_element
    (68) location -> . string_slice
    (69) location -> . array_element
    (70) location -> . array_slice
    (124) literal -> . integer_literal
    (125) literal -> . boolean_literal
    (126) literal -> . character_literal
    (127) literal -> . empty_literal
    (128) literal -> . character_string_literal
    (22) identifier -> . ID
    (71) dereferenced_reference -> . array_location ARROW
    (72) string_element -> . identifier LBRACKET start_element LBRACKET
    (74) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (77) array_element -> . array_location LBRACKET expression_list RBRACKET
    (80) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (129) integer_literal -> . ICONST
    (130) boolean_literal -> . TRUE
    (131) boolean_literal -> . FALSE
    (132) character_literal -> . CCONST
    (133) empty_literal -> . NULL
    (134) character_string_literal -> . SCONST

    IF              shift and go to state 99
    MINUS           shift and go to state 90
    NOT             shift and go to state 96
    ARROW           shift and go to state 72
    ID              shift and go to state 15
    ICONST          shift and go to state 89
    TRUE            shift and go to state 87
    FALSE           shift and go to state 80
    CCONST          shift and go to state 91
    NULL            shift and go to state 97
    SCONST          shift and go to state 95

    location                       shift and go to state 82
    character_literal              shift and go to state 85
    character_string_literal       shift and go to state 94
    identifier                     shift and go to state 84
    array_location                 shift and go to state 73
    literal                        shift and go to state 74
    dereferenced_reference         shift and go to state 75
    operand3                       shift and go to state 76
    monadic_operator               shift and go to state 93
    array_slice                    shift and go to state 83
    primitive_value                shift and go to state 78
    referenced_location            shift and go to state 79
    string_slice                   shift and go to state 98
    string_element                 shift and go to state 81
    right_element                  shift and go to state 198
    conditional_expression         shift and go to state 100
    operand2                       shift and go to state 103
    integer_literal                shift and go to state 77
    empty_literal                  shift and go to state 101
    operand1                       shift and go to state 86
    operand4                       shift and go to state 102
    expression                     shift and go to state 197
    boolean_literal                shift and go to state 104
    operand0                       shift and go to state 105
    array_element                  shift and go to state 92

state 185

    (72) string_element -> identifier LBRACKET start_element LBRACKET .

    ARROW           reduce using rule 72 (string_element -> identifier LBRACKET start_element LBRACKET .)
    LBRACKET        reduce using rule 72 (string_element -> identifier LBRACKET start_element LBRACKET .)
    TIMES           reduce using rule 72 (string_element -> identifier LBRACKET start_element LBRACKET .)
    DIVIDE          reduce using rule 72 (string_element -> identifier LBRACKET start_element LBRACKET .)
    MODULO          reduce using rule 72 (string_element -> identifier LBRACKET start_element LBRACKET .)
    PLUS            reduce using rule 72 (string_element -> identifier LBRACKET start_element LBRACKET .)
    MINUS           reduce using rule 72 (string_element -> identifier LBRACKET start_element LBRACKET .)
    CONCAT          reduce using rule 72 (string_element -> identifier LBRACKET start_element LBRACKET .)
    AND             reduce using rule 72 (string_element -> identifier LBRACKET start_element LBRACKET .)
    OR              reduce using rule 72 (string_element -> identifier LBRACKET start_element LBRACKET .)
    EQUAL           reduce using rule 72 (string_element -> identifier LBRACKET start_element LBRACKET .)
    NOTEQ           reduce using rule 72 (string_element -> identifier LBRACKET start_element LBRACKET .)
    GREATER         reduce using rule 72 (string_element -> identifier LBRACKET start_element LBRACKET .)
    GTEQUAL         reduce using rule 72 (string_element -> identifier LBRACKET start_element LBRACKET .)
    LESS            reduce using rule 72 (string_element -> identifier LBRACKET start_element LBRACKET .)
    LTEQUAL         reduce using rule 72 (string_element -> identifier LBRACKET start_element LBRACKET .)
    IN              reduce using rule 72 (string_element -> identifier LBRACKET start_element LBRACKET .)
    ELSE            reduce using rule 72 (string_element -> identifier LBRACKET start_element LBRACKET .)
    ELSIF           reduce using rule 72 (string_element -> identifier LBRACKET start_element LBRACKET .)
    COMMA           reduce using rule 72 (string_element -> identifier LBRACKET start_element LBRACKET .)
    RBRACKET        reduce using rule 72 (string_element -> identifier LBRACKET start_element LBRACKET .)
    COLON           reduce using rule 72 (string_element -> identifier LBRACKET start_element LBRACKET .)
    THEN            reduce using rule 72 (string_element -> identifier LBRACKET start_element LBRACKET .)
    FI              reduce using rule 72 (string_element -> identifier LBRACKET start_element LBRACKET .)
    RPAREN          reduce using rule 72 (string_element -> identifier LBRACKET start_element LBRACKET .)
    SEMI            reduce using rule 72 (string_element -> identifier LBRACKET start_element LBRACKET .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 186

<<<<<<< HEAD
    (78) then_expression -> THEN expression .

    ELSIF           reduce using rule 78 (then_expression -> THEN expression .)
    ELSE            reduce using rule 78 (then_expression -> THEN expression .)
=======
    (86) then_expression -> THEN expression .

    ELSIF           reduce using rule 86 (then_expression -> THEN expression .)
    ELSE            reduce using rule 86 (then_expression -> THEN expression .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 187

<<<<<<< HEAD
    (79) else_expression -> ELSE . expression
    (73) expression -> . operand0
    (74) expression -> . conditional_expression
    (82) operand0 -> . operand1
    (83) operand0 -> . operand0 operator1 operand1
    (76) conditional_expression -> . IF expression then_expression else_expression FI
    (77) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (84) operand1 -> . operand2
    (85) operand1 -> . operand1 operator2 operand2
    (86) operand2 -> . operand3
    (87) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (88) operand3 -> . monadic_operator operand4
    (89) operand3 -> . operand4
    (96) monadic_operator -> . MINUS
    (97) monadic_operator -> . NOT
    (90) operand4 -> . array_location
    (91) operand4 -> . referenced_location
    (92) operand4 -> . primitive_value
    (72) array_location -> . location
    (98) referenced_location -> . ARROW array_location
    (115) primitive_value -> . literal
    (116) primitive_value -> . value_array_element
    (117) primitive_value -> . value_array_slice
    (118) primitive_value -> . parenthesized_expression
    (56) location -> . identifier
    (57) location -> . dereferenced_reference
    (58) location -> . string_element
    (59) location -> . string_slice
    (60) location -> . array_element
    (61) location -> . array_slice
    (119) literal -> . integer_literal
    (120) literal -> . boolean_literal
    (121) literal -> . character_literal
    (122) literal -> . empty_literal
    (123) literal -> . character_string_literal
    (124) value_array_element -> . primitive_value LBRACKET expression_list RBRACKET
    (125) value_array_slice -> . primitive_value LBRACKET expression COLON expression RBRACKET
    (75) parenthesized_expression -> . LPAREN expression RPAREN
    (22) identifier -> . ID
    (62) dereferenced_reference -> . array_location ARROW
    (63) string_element -> . identifier LBRACKET start_element LBRACKET
    (65) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (68) array_element -> . array_location LBRACKET expression_list RBRACKET
    (71) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (126) integer_literal -> . ICONST
    (127) boolean_literal -> . TRUE
    (128) boolean_literal -> . FALSE
    (129) character_literal -> . CCONST
    (130) empty_literal -> . NULL
    (131) character_string_literal -> . SCONST

    IF              shift and go to state 31
    MINUS           shift and go to state 36
    NOT             shift and go to state 35
    ARROW           shift and go to state 45
    LPAREN          shift and go to state 44
    ID              shift and go to state 21
    ICONST          shift and go to state 40
    TRUE            shift and go to state 55
    FALSE           shift and go to state 53
    CCONST          shift and go to state 34
    NULL            shift and go to state 27
    SCONST          shift and go to state 52

    location                       shift and go to state 6
    monadic_operator               shift and go to state 47
    operand2                       shift and go to state 49
    value_array_element            shift and go to state 48
    operand1                       shift and go to state 25
    expression                     shift and go to state 214
    conditional_expression         shift and go to state 28
    referenced_location            shift and go to state 29
    parenthesized_expression       shift and go to state 30
    array_slice                    shift and go to state 15
    integer_literal                shift and go to state 32
    empty_literal                  shift and go to state 50
    array_element                  shift and go to state 7
    operand3                       shift and go to state 33
    string_slice                   shift and go to state 3
    string_element                 shift and go to state 1
    boolean_literal                shift and go to state 51
    array_location                 shift and go to state 46
    literal                        shift and go to state 37
    operand0                       shift and go to state 38
    primitive_value                shift and go to state 39
    character_literal              shift and go to state 41
    value_array_slice              shift and go to state 42
    operand4                       shift and go to state 54
    character_string_literal       shift and go to state 43
    dereferenced_reference         shift and go to state 20
    identifier                     shift and go to state 56

state 188

    (80) elsif_expression -> ELSIF . expression then_expression
    (73) expression -> . operand0
    (74) expression -> . conditional_expression
    (82) operand0 -> . operand1
    (83) operand0 -> . operand0 operator1 operand1
    (76) conditional_expression -> . IF expression then_expression else_expression FI
    (77) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (84) operand1 -> . operand2
    (85) operand1 -> . operand1 operator2 operand2
    (86) operand2 -> . operand3
    (87) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (88) operand3 -> . monadic_operator operand4
    (89) operand3 -> . operand4
    (96) monadic_operator -> . MINUS
    (97) monadic_operator -> . NOT
    (90) operand4 -> . array_location
    (91) operand4 -> . referenced_location
    (92) operand4 -> . primitive_value
    (72) array_location -> . location
    (98) referenced_location -> . ARROW array_location
    (115) primitive_value -> . literal
    (116) primitive_value -> . value_array_element
    (117) primitive_value -> . value_array_slice
    (118) primitive_value -> . parenthesized_expression
    (56) location -> . identifier
    (57) location -> . dereferenced_reference
    (58) location -> . string_element
    (59) location -> . string_slice
    (60) location -> . array_element
    (61) location -> . array_slice
    (119) literal -> . integer_literal
    (120) literal -> . boolean_literal
    (121) literal -> . character_literal
    (122) literal -> . empty_literal
    (123) literal -> . character_string_literal
    (124) value_array_element -> . primitive_value LBRACKET expression_list RBRACKET
    (125) value_array_slice -> . primitive_value LBRACKET expression COLON expression RBRACKET
    (75) parenthesized_expression -> . LPAREN expression RPAREN
    (22) identifier -> . ID
    (62) dereferenced_reference -> . array_location ARROW
    (63) string_element -> . identifier LBRACKET start_element LBRACKET
    (65) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (68) array_element -> . array_location LBRACKET expression_list RBRACKET
    (71) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (126) integer_literal -> . ICONST
    (127) boolean_literal -> . TRUE
    (128) boolean_literal -> . FALSE
    (129) character_literal -> . CCONST
    (130) empty_literal -> . NULL
    (131) character_string_literal -> . SCONST

    IF              shift and go to state 31
    MINUS           shift and go to state 36
    NOT             shift and go to state 35
    ARROW           shift and go to state 45
    LPAREN          shift and go to state 44
    ID              shift and go to state 21
    ICONST          shift and go to state 40
    TRUE            shift and go to state 55
    FALSE           shift and go to state 53
    CCONST          shift and go to state 34
    NULL            shift and go to state 27
    SCONST          shift and go to state 52

    location                       shift and go to state 6
    monadic_operator               shift and go to state 47
    operand2                       shift and go to state 49
    value_array_element            shift and go to state 48
    operand1                       shift and go to state 25
    expression                     shift and go to state 215
    conditional_expression         shift and go to state 28
    referenced_location            shift and go to state 29
    parenthesized_expression       shift and go to state 30
    array_slice                    shift and go to state 15
    integer_literal                shift and go to state 32
    empty_literal                  shift and go to state 50
    array_element                  shift and go to state 7
    operand3                       shift and go to state 33
    string_slice                   shift and go to state 3
    string_element                 shift and go to state 1
    boolean_literal                shift and go to state 51
    array_location                 shift and go to state 46
    literal                        shift and go to state 37
    operand0                       shift and go to state 38
    primitive_value                shift and go to state 39
    character_literal              shift and go to state 41
    value_array_slice              shift and go to state 42
    operand4                       shift and go to state 54
    character_string_literal       shift and go to state 43
    dereferenced_reference         shift and go to state 20
    identifier                     shift and go to state 56
=======
    (85) conditional_expression -> IF expression then_expression elsif_expression . else_expression FI
    (89) elsif_expression -> elsif_expression . ELSIF expression then_expression
    (87) else_expression -> . ELSE expression

    ELSIF           shift and go to state 200
    ELSE            shift and go to state 188

    else_expression                shift and go to state 199
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

state 189

<<<<<<< HEAD
    (77) conditional_expression -> IF expression then_expression elsif_expression . else_expression FI
    (81) elsif_expression -> elsif_expression . ELSIF expression then_expression
    (79) else_expression -> . ELSE expression

    ELSIF           shift and go to state 216
    ELSE            shift and go to state 187

    else_expression                shift and go to state 217

state 190

    (76) conditional_expression -> IF expression then_expression else_expression . FI

    FI              shift and go to state 218


state 191

    (125) value_array_slice -> primitive_value LBRACKET expression COLON . expression RBRACKET
    (73) expression -> . operand0
    (74) expression -> . conditional_expression
    (82) operand0 -> . operand1
    (83) operand0 -> . operand0 operator1 operand1
    (76) conditional_expression -> . IF expression then_expression else_expression FI
    (77) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (84) operand1 -> . operand2
    (85) operand1 -> . operand1 operator2 operand2
    (86) operand2 -> . operand3
    (87) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (88) operand3 -> . monadic_operator operand4
    (89) operand3 -> . operand4
    (96) monadic_operator -> . MINUS
    (97) monadic_operator -> . NOT
    (90) operand4 -> . array_location
    (91) operand4 -> . referenced_location
    (92) operand4 -> . primitive_value
    (72) array_location -> . location
    (98) referenced_location -> . ARROW array_location
    (115) primitive_value -> . literal
    (116) primitive_value -> . value_array_element
    (117) primitive_value -> . value_array_slice
    (118) primitive_value -> . parenthesized_expression
    (56) location -> . identifier
    (57) location -> . dereferenced_reference
    (58) location -> . string_element
    (59) location -> . string_slice
    (60) location -> . array_element
    (61) location -> . array_slice
    (119) literal -> . integer_literal
    (120) literal -> . boolean_literal
    (121) literal -> . character_literal
    (122) literal -> . empty_literal
    (123) literal -> . character_string_literal
    (124) value_array_element -> . primitive_value LBRACKET expression_list RBRACKET
    (125) value_array_slice -> . primitive_value LBRACKET expression COLON expression RBRACKET
    (75) parenthesized_expression -> . LPAREN expression RPAREN
    (22) identifier -> . ID
    (62) dereferenced_reference -> . array_location ARROW
    (63) string_element -> . identifier LBRACKET start_element LBRACKET
    (65) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (68) array_element -> . array_location LBRACKET expression_list RBRACKET
    (71) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (126) integer_literal -> . ICONST
    (127) boolean_literal -> . TRUE
    (128) boolean_literal -> . FALSE
    (129) character_literal -> . CCONST
    (130) empty_literal -> . NULL
    (131) character_string_literal -> . SCONST

    IF              shift and go to state 31
    MINUS           shift and go to state 36
    NOT             shift and go to state 35
    ARROW           shift and go to state 45
    LPAREN          shift and go to state 44
    ID              shift and go to state 21
    ICONST          shift and go to state 40
    TRUE            shift and go to state 55
    FALSE           shift and go to state 53
    CCONST          shift and go to state 34
    NULL            shift and go to state 27
    SCONST          shift and go to state 52

    location                       shift and go to state 6
    monadic_operator               shift and go to state 47
    operand2                       shift and go to state 49
    value_array_element            shift and go to state 48
    operand1                       shift and go to state 25
    expression                     shift and go to state 219
    conditional_expression         shift and go to state 28
    referenced_location            shift and go to state 29
    parenthesized_expression       shift and go to state 30
    array_slice                    shift and go to state 15
    integer_literal                shift and go to state 32
    empty_literal                  shift and go to state 50
    array_element                  shift and go to state 7
    operand3                       shift and go to state 33
    string_slice                   shift and go to state 3
    string_element                 shift and go to state 1
    boolean_literal                shift and go to state 51
    array_location                 shift and go to state 46
    literal                        shift and go to state 37
    operand0                       shift and go to state 38
    primitive_value                shift and go to state 39
    character_literal              shift and go to state 41
    value_array_slice              shift and go to state 42
    operand4                       shift and go to state 54
    character_string_literal       shift and go to state 43
    dereferenced_reference         shift and go to state 20
    identifier                     shift and go to state 56

state 192

    (124) value_array_element -> primitive_value LBRACKET expression_list RBRACKET .

    LBRACKET        reduce using rule 124 (value_array_element -> primitive_value LBRACKET expression_list RBRACKET .)
    TIMES           reduce using rule 124 (value_array_element -> primitive_value LBRACKET expression_list RBRACKET .)
    DIVIDE          reduce using rule 124 (value_array_element -> primitive_value LBRACKET expression_list RBRACKET .)
    MODULO          reduce using rule 124 (value_array_element -> primitive_value LBRACKET expression_list RBRACKET .)
    PLUS            reduce using rule 124 (value_array_element -> primitive_value LBRACKET expression_list RBRACKET .)
    MINUS           reduce using rule 124 (value_array_element -> primitive_value LBRACKET expression_list RBRACKET .)
    CONCAT          reduce using rule 124 (value_array_element -> primitive_value LBRACKET expression_list RBRACKET .)
    AND             reduce using rule 124 (value_array_element -> primitive_value LBRACKET expression_list RBRACKET .)
    OR              reduce using rule 124 (value_array_element -> primitive_value LBRACKET expression_list RBRACKET .)
    EQUAL           reduce using rule 124 (value_array_element -> primitive_value LBRACKET expression_list RBRACKET .)
    NOTEQ           reduce using rule 124 (value_array_element -> primitive_value LBRACKET expression_list RBRACKET .)
    GREATER         reduce using rule 124 (value_array_element -> primitive_value LBRACKET expression_list RBRACKET .)
    GTEQUAL         reduce using rule 124 (value_array_element -> primitive_value LBRACKET expression_list RBRACKET .)
    LESS            reduce using rule 124 (value_array_element -> primitive_value LBRACKET expression_list RBRACKET .)
    LTEQUAL         reduce using rule 124 (value_array_element -> primitive_value LBRACKET expression_list RBRACKET .)
    IN              reduce using rule 124 (value_array_element -> primitive_value LBRACKET expression_list RBRACKET .)
    DCL             reduce using rule 124 (value_array_element -> primitive_value LBRACKET expression_list RBRACKET .)
    SYN             reduce using rule 124 (value_array_element -> primitive_value LBRACKET expression_list RBRACKET .)
    TYPE            reduce using rule 124 (value_array_element -> primitive_value LBRACKET expression_list RBRACKET .)
    ID              reduce using rule 124 (value_array_element -> primitive_value LBRACKET expression_list RBRACKET .)
    IF              reduce using rule 124 (value_array_element -> primitive_value LBRACKET expression_list RBRACKET .)
    $end            reduce using rule 124 (value_array_element -> primitive_value LBRACKET expression_list RBRACKET .)
    ELSE            reduce using rule 124 (value_array_element -> primitive_value LBRACKET expression_list RBRACKET .)
    ELSIF           reduce using rule 124 (value_array_element -> primitive_value LBRACKET expression_list RBRACKET .)
    FI              reduce using rule 124 (value_array_element -> primitive_value LBRACKET expression_list RBRACKET .)
    THEN            reduce using rule 124 (value_array_element -> primitive_value LBRACKET expression_list RBRACKET .)
    RPAREN          reduce using rule 124 (value_array_element -> primitive_value LBRACKET expression_list RBRACKET .)
    COMMA           reduce using rule 124 (value_array_element -> primitive_value LBRACKET expression_list RBRACKET .)
    RBRACKET        reduce using rule 124 (value_array_element -> primitive_value LBRACKET expression_list RBRACKET .)
    COLON           reduce using rule 124 (value_array_element -> primitive_value LBRACKET expression_list RBRACKET .)
    SEMI            reduce using rule 124 (value_array_element -> primitive_value LBRACKET expression_list RBRACKET .)


state 193

    (12) synonym_definition -> identifier_list mode ASSIGN expression .

    COMMA           reduce using rule 12 (synonym_definition -> identifier_list mode ASSIGN expression .)
    SEMI            reduce using rule 12 (synonym_definition -> identifier_list mode ASSIGN expression .)
=======
    (87) else_expression -> ELSE . expression
    (82) expression -> . operand0
    (83) expression -> . conditional_expression
    (90) operand0 -> . operand1
    (91) operand0 -> . operand0 operator1 operand1
    (84) conditional_expression -> . IF expression then_expression else_expression FI
    (85) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (92) operand1 -> . operand2
    (93) operand1 -> . operand1 operator2 operand2
    (94) operand2 -> . operand3
    (95) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (96) operand3 -> . monadic_operator operand4
    (97) operand3 -> . operand4
    (104) monadic_operator -> . MINUS
    (105) monadic_operator -> . NOT
    (98) operand4 -> . array_location
    (99) operand4 -> . referenced_location
    (100) operand4 -> . primitive_value
    (81) array_location -> . location
    (106) referenced_location -> . ARROW array_location
    (123) primitive_value -> . literal
    (65) location -> . identifier
    (66) location -> . dereferenced_reference
    (67) location -> . string_element
    (68) location -> . string_slice
    (69) location -> . array_element
    (70) location -> . array_slice
    (124) literal -> . integer_literal
    (125) literal -> . boolean_literal
    (126) literal -> . character_literal
    (127) literal -> . empty_literal
    (128) literal -> . character_string_literal
    (22) identifier -> . ID
    (71) dereferenced_reference -> . array_location ARROW
    (72) string_element -> . identifier LBRACKET start_element LBRACKET
    (74) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (77) array_element -> . array_location LBRACKET expression_list RBRACKET
    (80) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (129) integer_literal -> . ICONST
    (130) boolean_literal -> . TRUE
    (131) boolean_literal -> . FALSE
    (132) character_literal -> . CCONST
    (133) empty_literal -> . NULL
    (134) character_string_literal -> . SCONST

    IF              shift and go to state 99
    MINUS           shift and go to state 90
    NOT             shift and go to state 96
    ARROW           shift and go to state 72
    ID              shift and go to state 15
    ICONST          shift and go to state 89
    TRUE            shift and go to state 87
    FALSE           shift and go to state 80
    CCONST          shift and go to state 91
    NULL            shift and go to state 97
    SCONST          shift and go to state 95

    monadic_operator               shift and go to state 93
    character_literal              shift and go to state 85
    character_string_literal       shift and go to state 94
    identifier                     shift and go to state 84
    array_location                 shift and go to state 73
    literal                        shift and go to state 74
    dereferenced_reference         shift and go to state 75
    operand3                       shift and go to state 76
    integer_literal                shift and go to state 77
    array_slice                    shift and go to state 83
    primitive_value                shift and go to state 78
    referenced_location            shift and go to state 79
    string_slice                   shift and go to state 98
    string_element                 shift and go to state 81
    location                       shift and go to state 82
    conditional_expression         shift and go to state 100
    operand2                       shift and go to state 103
    empty_literal                  shift and go to state 101
    operand1                       shift and go to state 86
    operand4                       shift and go to state 102
    expression                     shift and go to state 201
    boolean_literal                shift and go to state 104
    operand0                       shift and go to state 105
    array_element                  shift and go to state 92

state 189
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

    (84) conditional_expression -> IF expression then_expression else_expression . FI

    FI              shift and go to state 202


state 190

    (88) elsif_expression -> ELSIF . expression then_expression
    (82) expression -> . operand0
    (83) expression -> . conditional_expression
    (90) operand0 -> . operand1
    (91) operand0 -> . operand0 operator1 operand1
    (84) conditional_expression -> . IF expression then_expression else_expression FI
    (85) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (92) operand1 -> . operand2
    (93) operand1 -> . operand1 operator2 operand2
    (94) operand2 -> . operand3
    (95) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (96) operand3 -> . monadic_operator operand4
    (97) operand3 -> . operand4
    (104) monadic_operator -> . MINUS
    (105) monadic_operator -> . NOT
    (98) operand4 -> . array_location
    (99) operand4 -> . referenced_location
    (100) operand4 -> . primitive_value
    (81) array_location -> . location
    (106) referenced_location -> . ARROW array_location
    (123) primitive_value -> . literal
    (65) location -> . identifier
    (66) location -> . dereferenced_reference
    (67) location -> . string_element
    (68) location -> . string_slice
    (69) location -> . array_element
    (70) location -> . array_slice
    (124) literal -> . integer_literal
    (125) literal -> . boolean_literal
    (126) literal -> . character_literal
    (127) literal -> . empty_literal
    (128) literal -> . character_string_literal
    (22) identifier -> . ID
    (71) dereferenced_reference -> . array_location ARROW
    (72) string_element -> . identifier LBRACKET start_element LBRACKET
    (74) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (77) array_element -> . array_location LBRACKET expression_list RBRACKET
    (80) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (129) integer_literal -> . ICONST
    (130) boolean_literal -> . TRUE
    (131) boolean_literal -> . FALSE
    (132) character_literal -> . CCONST
    (133) empty_literal -> . NULL
    (134) character_string_literal -> . SCONST

    IF              shift and go to state 99
    MINUS           shift and go to state 90
    NOT             shift and go to state 96
    ARROW           shift and go to state 72
    ID              shift and go to state 15
    ICONST          shift and go to state 89
    TRUE            shift and go to state 87
    FALSE           shift and go to state 80
    CCONST          shift and go to state 91
    NULL            shift and go to state 97
    SCONST          shift and go to state 95

    monadic_operator               shift and go to state 93
    character_literal              shift and go to state 85
    character_string_literal       shift and go to state 94
    identifier                     shift and go to state 84
    literal                        shift and go to state 74
    dereferenced_reference         shift and go to state 75
    operand3                       shift and go to state 76
    integer_literal                shift and go to state 77
    array_slice                    shift and go to state 83
    primitive_value                shift and go to state 78
    referenced_location            shift and go to state 79
    string_slice                   shift and go to state 98
    string_element                 shift and go to state 81
    location                       shift and go to state 82
    conditional_expression         shift and go to state 100
    operand2                       shift and go to state 103
    array_location                 shift and go to state 73
    empty_literal                  shift and go to state 101
    operand1                       shift and go to state 86
    operand4                       shift and go to state 102
    expression                     shift and go to state 203
    boolean_literal                shift and go to state 104
    operand0                       shift and go to state 105
    array_element                  shift and go to state 92

state 191

    (34) result_spec -> RETURNS LPAREN . mode LOC RPAREN
    (35) result_spec -> RETURNS LPAREN . mode RPAREN
    (36) mode -> . mode_name
    (37) mode -> . discrete_mode
    (38) mode -> . reference_mode
    (39) mode -> . composite_mode
    (40) mode_name -> . identifier
    (41) discrete_mode -> . integer_mode
    (42) discrete_mode -> . boolean_mode
    (43) discrete_mode -> . character_mode
    (44) discrete_mode -> . discrete_range_mode
    (54) reference_mode -> . REF mode
    (55) composite_mode -> . string_mode
    (56) composite_mode -> . array_mode
    (22) identifier -> . ID
    (46) integer_mode -> . INT
    (47) boolean_mode -> . BOOL
    (48) character_mode -> . CHAR
    (49) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (50) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (57) string_mode -> . CHARS LBRACKET string_length RBRACKET
    (59) array_mode -> . ARRAY LBRACKET index_mode_list RBRACKET element_mode
    (45) discrete_mode_name -> . identifier

<<<<<<< HEAD
state 194

    (43) lower_bound -> expression .

    COLON           reduce using rule 43 (lower_bound -> expression .)
=======
    REF             shift and go to state 38
    ID              shift and go to state 15
    INT             shift and go to state 39
    BOOL            shift and go to state 53
    CHAR            shift and go to state 51
    CHARS           shift and go to state 43
    ARRAY           shift and go to state 52

    discrete_range_mode            shift and go to state 45
    identifier                     shift and go to state 36
    composite_mode                 shift and go to state 46
    discrete_mode                  shift and go to state 37
    discrete_mode_name             shift and go to state 48
    mode                           shift and go to state 204
    boolean_mode                   shift and go to state 50
    mode_name                      shift and go to state 41
    reference_mode                 shift and go to state 35
    array_mode                     shift and go to state 42
    integer_mode                   shift and go to state 40
    string_mode                    shift and go to state 44
    character_mode                 shift and go to state 47

state 192

    (28) procedure_definition -> PROC LPAREN formal_parameter_list RPAREN result_spec SEMI . statement_nullable END SEMI
    (3) statement_nullable -> . statement statement_nullable
    (4) statement_nullable -> . empty
    (5) statement -> . declaration_statement
    (6) statement -> . synonym_statement
    (7) statement -> . newmode_statement
    (8) statement -> . procedure_statement
    (135) empty -> .
    (14) declaration_statement -> . DCL declaration_list SEMI
    (9) synonym_statement -> . SYN synonym_list SEMI
    (23) newmode_statement -> . TYPE newmode_list SEMI
    (27) procedure_statement -> . ID COLON procedure_definition

    END             reduce using rule 135 (empty -> .)
    DCL             shift and go to state 7
    SYN             shift and go to state 11
    TYPE            shift and go to state 4
    ID              shift and go to state 2

    synonym_statement              shift and go to state 6
    procedure_statement            shift and go to state 5
    statement_nullable             shift and go to state 205
    newmode_statement              shift and go to state 8
    empty                          shift and go to state 21
    declaration_statement          shift and go to state 1
    statement                      shift and go to state 22

state 193

    (29) procedure_definition -> PROC LPAREN formal_parameter_list RPAREN SEMI statement_nullable . END SEMI

    END             shift and go to state 206


state 194

    (78) expression_list -> expression .
    (79) expression_list -> expression . COMMA expression_list

    RBRACKET        reduce using rule 78 (expression_list -> expression .)
    COMMA           shift and go to state 181
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 195

<<<<<<< HEAD
    (40) discrete_range_mode -> discrete_mode_name LPAREN literal_range . RPAREN

    RPAREN          shift and go to state 220
=======
    (79) expression_list -> expression COMMA expression_list .

    RBRACKET        reduce using rule 79 (expression_list -> expression COMMA expression_list .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 196

<<<<<<< HEAD
    (42) literal_range -> lower_bound . COLON upper_bound

    COLON           shift and go to state 221
=======
    (80) array_slice -> array_location LBRACKET lower_bound COLON upper_bound . RBRACKET

    RBRACKET        shift and go to state 207
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 197

<<<<<<< HEAD
    (51) index_mode_list -> index_mode .
    (52) index_mode_list -> index_mode . COMMA index_mode_list

    RBRACKET        reduce using rule 51 (index_mode_list -> index_mode .)
    COMMA           shift and go to state 222
=======
    (76) right_element -> expression .

    RBRACKET        reduce using rule 76 (right_element -> expression .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 198

<<<<<<< HEAD
    (53) index_mode -> discrete_mode .
    (41) discrete_range_mode -> discrete_mode . LPAREN literal_range RPAREN

    COMMA           reduce using rule 53 (index_mode -> discrete_mode .)
    RBRACKET        reduce using rule 53 (index_mode -> discrete_mode .)
    LPAREN          shift and go to state 169
=======
    (74) string_slice -> identifier LBRACKET left_element COLON right_element . RBRACKET

    RBRACKET        shift and go to state 208
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 199

<<<<<<< HEAD
    (50) array_mode -> ARRAY LBRACKET index_mode_list . RBRACKET element_mode

    RBRACKET        shift and go to state 223
=======
    (85) conditional_expression -> IF expression then_expression elsif_expression else_expression . FI

    FI              shift and go to state 209
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 200

<<<<<<< HEAD
    (54) index_mode -> literal_range .

    COMMA           reduce using rule 54 (index_mode -> literal_range .)
    RBRACKET        reduce using rule 54 (index_mode -> literal_range .)


state 201

    (36) discrete_mode_name -> identifier .
    (56) location -> identifier .
    (63) string_element -> identifier . LBRACKET start_element LBRACKET
    (65) string_slice -> identifier . LBRACKET left_element COLON right_element RBRACKET

  ! shift/reduce conflict for LBRACKET resolved as shift
    LPAREN          reduce using rule 36 (discrete_mode_name -> identifier .)
    ARROW           reduce using rule 56 (location -> identifier .)
    TIMES           reduce using rule 56 (location -> identifier .)
    DIVIDE          reduce using rule 56 (location -> identifier .)
    MODULO          reduce using rule 56 (location -> identifier .)
    PLUS            reduce using rule 56 (location -> identifier .)
    MINUS           reduce using rule 56 (location -> identifier .)
    CONCAT          reduce using rule 56 (location -> identifier .)
    AND             reduce using rule 56 (location -> identifier .)
    OR              reduce using rule 56 (location -> identifier .)
    EQUAL           reduce using rule 56 (location -> identifier .)
    NOTEQ           reduce using rule 56 (location -> identifier .)
    GREATER         reduce using rule 56 (location -> identifier .)
    GTEQUAL         reduce using rule 56 (location -> identifier .)
    LESS            reduce using rule 56 (location -> identifier .)
    LTEQUAL         reduce using rule 56 (location -> identifier .)
    IN              reduce using rule 56 (location -> identifier .)
    COLON           reduce using rule 56 (location -> identifier .)
    LBRACKET        shift and go to state 85

  ! LBRACKET        [ reduce using rule 56 (location -> identifier .) ]
=======
    (89) elsif_expression -> elsif_expression ELSIF . expression then_expression
    (82) expression -> . operand0
    (83) expression -> . conditional_expression
    (90) operand0 -> . operand1
    (91) operand0 -> . operand0 operator1 operand1
    (84) conditional_expression -> . IF expression then_expression else_expression FI
    (85) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (92) operand1 -> . operand2
    (93) operand1 -> . operand1 operator2 operand2
    (94) operand2 -> . operand3
    (95) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (96) operand3 -> . monadic_operator operand4
    (97) operand3 -> . operand4
    (104) monadic_operator -> . MINUS
    (105) monadic_operator -> . NOT
    (98) operand4 -> . array_location
    (99) operand4 -> . referenced_location
    (100) operand4 -> . primitive_value
    (81) array_location -> . location
    (106) referenced_location -> . ARROW array_location
    (123) primitive_value -> . literal
    (65) location -> . identifier
    (66) location -> . dereferenced_reference
    (67) location -> . string_element
    (68) location -> . string_slice
    (69) location -> . array_element
    (70) location -> . array_slice
    (124) literal -> . integer_literal
    (125) literal -> . boolean_literal
    (126) literal -> . character_literal
    (127) literal -> . empty_literal
    (128) literal -> . character_string_literal
    (22) identifier -> . ID
    (71) dereferenced_reference -> . array_location ARROW
    (72) string_element -> . identifier LBRACKET start_element LBRACKET
    (74) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (77) array_element -> . array_location LBRACKET expression_list RBRACKET
    (80) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (129) integer_literal -> . ICONST
    (130) boolean_literal -> . TRUE
    (131) boolean_literal -> . FALSE
    (132) character_literal -> . CCONST
    (133) empty_literal -> . NULL
    (134) character_string_literal -> . SCONST

    IF              shift and go to state 99
    MINUS           shift and go to state 90
    NOT             shift and go to state 96
    ARROW           shift and go to state 72
    ID              shift and go to state 15
    ICONST          shift and go to state 89
    TRUE            shift and go to state 87
    FALSE           shift and go to state 80
    CCONST          shift and go to state 91
    NULL            shift and go to state 97
    SCONST          shift and go to state 95

    monadic_operator               shift and go to state 93
    character_literal              shift and go to state 85
    character_string_literal       shift and go to state 94
    identifier                     shift and go to state 84
    array_location                 shift and go to state 73
    literal                        shift and go to state 74
    dereferenced_reference         shift and go to state 75
    operand3                       shift and go to state 76
    integer_literal                shift and go to state 77
    array_slice                    shift and go to state 83
    primitive_value                shift and go to state 78
    referenced_location            shift and go to state 79
    string_slice                   shift and go to state 98
    string_element                 shift and go to state 81
    location                       shift and go to state 82
    conditional_expression         shift and go to state 100
    operand2                       shift and go to state 103
    empty_literal                  shift and go to state 101
    operand1                       shift and go to state 86
    operand4                       shift and go to state 102
    expression                     shift and go to state 210
    boolean_literal                shift and go to state 104
    operand0                       shift and go to state 105
    array_element                  shift and go to state 92

state 201

    (87) else_expression -> ELSE expression .

    FI              reduce using rule 87 (else_expression -> ELSE expression .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 202

<<<<<<< HEAD
    (49) string_length -> integer_literal .

    RBRACKET        reduce using rule 49 (string_length -> integer_literal .)
=======
    (84) conditional_expression -> IF expression then_expression else_expression FI .

    COMMA           reduce using rule 84 (conditional_expression -> IF expression then_expression else_expression FI .)
    SEMI            reduce using rule 84 (conditional_expression -> IF expression then_expression else_expression FI .)
    COLON           reduce using rule 84 (conditional_expression -> IF expression then_expression else_expression FI .)
    RBRACKET        reduce using rule 84 (conditional_expression -> IF expression then_expression else_expression FI .)
    LBRACKET        reduce using rule 84 (conditional_expression -> IF expression then_expression else_expression FI .)
    THEN            reduce using rule 84 (conditional_expression -> IF expression then_expression else_expression FI .)
    FI              reduce using rule 84 (conditional_expression -> IF expression then_expression else_expression FI .)
    ELSE            reduce using rule 84 (conditional_expression -> IF expression then_expression else_expression FI .)
    ELSIF           reduce using rule 84 (conditional_expression -> IF expression then_expression else_expression FI .)
    RPAREN          reduce using rule 84 (conditional_expression -> IF expression then_expression else_expression FI .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 203

<<<<<<< HEAD
    (48) string_mode -> CHARS LBRACKET string_length . RBRACKET

    RBRACKET        shift and go to state 224


state 204

    (41) discrete_range_mode -> discrete_mode LPAREN literal_range . RPAREN

    RPAREN          shift and go to state 225
=======
    (88) elsif_expression -> ELSIF expression . then_expression
    (86) then_expression -> . THEN expression

    THEN            shift and go to state 167

    then_expression                shift and go to state 211

state 204

    (34) result_spec -> RETURNS LPAREN mode . LOC RPAREN
    (35) result_spec -> RETURNS LPAREN mode . RPAREN

    LOC             shift and go to state 212
    RPAREN          shift and go to state 213
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 205

<<<<<<< HEAD
    (69) expression_list -> expression .
    (70) expression_list -> expression . COMMA expression_list

    RBRACKET        reduce using rule 69 (expression_list -> expression .)
    COMMA           shift and go to state 170
=======
    (28) procedure_definition -> PROC LPAREN formal_parameter_list RPAREN result_spec SEMI statement_nullable . END SEMI

    END             shift and go to state 214
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 206

<<<<<<< HEAD
    (70) expression_list -> expression COMMA expression_list .

    RBRACKET        reduce using rule 70 (expression_list -> expression COMMA expression_list .)
=======
    (29) procedure_definition -> PROC LPAREN formal_parameter_list RPAREN SEMI statement_nullable END . SEMI

    SEMI            shift and go to state 215
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 207

<<<<<<< HEAD
    (44) upper_bound -> expression .

    RPAREN          reduce using rule 44 (upper_bound -> expression .)
    COMMA           reduce using rule 44 (upper_bound -> expression .)
    RBRACKET        reduce using rule 44 (upper_bound -> expression .)
=======
    (80) array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .

    ARROW           reduce using rule 80 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    LBRACKET        reduce using rule 80 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    TIMES           reduce using rule 80 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    DIVIDE          reduce using rule 80 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    MODULO          reduce using rule 80 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    PLUS            reduce using rule 80 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    MINUS           reduce using rule 80 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    CONCAT          reduce using rule 80 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    AND             reduce using rule 80 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    OR              reduce using rule 80 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    EQUAL           reduce using rule 80 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    NOTEQ           reduce using rule 80 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    GREATER         reduce using rule 80 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    GTEQUAL         reduce using rule 80 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    LESS            reduce using rule 80 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    LTEQUAL         reduce using rule 80 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    IN              reduce using rule 80 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    COMMA           reduce using rule 80 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    SEMI            reduce using rule 80 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    COLON           reduce using rule 80 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    THEN            reduce using rule 80 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    RBRACKET        reduce using rule 80 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    RPAREN          reduce using rule 80 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    ELSE            reduce using rule 80 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    ELSIF           reduce using rule 80 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    FI              reduce using rule 80 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 208

<<<<<<< HEAD
    (71) array_slice -> array_location LBRACKET lower_bound COLON upper_bound . RBRACKET

    RBRACKET        shift and go to state 226
=======
    (74) string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .

    ARROW           reduce using rule 74 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    LBRACKET        reduce using rule 74 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    TIMES           reduce using rule 74 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    DIVIDE          reduce using rule 74 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    MODULO          reduce using rule 74 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    PLUS            reduce using rule 74 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    MINUS           reduce using rule 74 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    CONCAT          reduce using rule 74 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    AND             reduce using rule 74 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    OR              reduce using rule 74 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    EQUAL           reduce using rule 74 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    NOTEQ           reduce using rule 74 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    GREATER         reduce using rule 74 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    GTEQUAL         reduce using rule 74 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    LESS            reduce using rule 74 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    LTEQUAL         reduce using rule 74 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    IN              reduce using rule 74 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    RBRACKET        reduce using rule 74 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    COMMA           reduce using rule 74 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    COLON           reduce using rule 74 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    SEMI            reduce using rule 74 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    THEN            reduce using rule 74 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    RPAREN          reduce using rule 74 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    ELSE            reduce using rule 74 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    ELSIF           reduce using rule 74 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    FI              reduce using rule 74 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 209

<<<<<<< HEAD
    (19) initialization -> ASSIGN expression .

    COMMA           reduce using rule 19 (initialization -> ASSIGN expression .)
    SEMI            reduce using rule 19 (initialization -> ASSIGN expression .)
=======
    (85) conditional_expression -> IF expression then_expression elsif_expression else_expression FI .

    COMMA           reduce using rule 85 (conditional_expression -> IF expression then_expression elsif_expression else_expression FI .)
    SEMI            reduce using rule 85 (conditional_expression -> IF expression then_expression elsif_expression else_expression FI .)
    COLON           reduce using rule 85 (conditional_expression -> IF expression then_expression elsif_expression else_expression FI .)
    RBRACKET        reduce using rule 85 (conditional_expression -> IF expression then_expression elsif_expression else_expression FI .)
    LBRACKET        reduce using rule 85 (conditional_expression -> IF expression then_expression elsif_expression else_expression FI .)
    THEN            reduce using rule 85 (conditional_expression -> IF expression then_expression elsif_expression else_expression FI .)
    FI              reduce using rule 85 (conditional_expression -> IF expression then_expression elsif_expression else_expression FI .)
    ELSE            reduce using rule 85 (conditional_expression -> IF expression then_expression elsif_expression else_expression FI .)
    ELSIF           reduce using rule 85 (conditional_expression -> IF expression then_expression elsif_expression else_expression FI .)
    RPAREN          reduce using rule 85 (conditional_expression -> IF expression then_expression elsif_expression else_expression FI .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 210

<<<<<<< HEAD
    (67) right_element -> expression .

    RBRACKET        reduce using rule 67 (right_element -> expression .)


state 211

    (65) string_slice -> identifier LBRACKET left_element COLON right_element . RBRACKET

    RBRACKET        shift and go to state 227
=======
    (89) elsif_expression -> elsif_expression ELSIF expression . then_expression
    (86) then_expression -> . THEN expression

    THEN            shift and go to state 167

    then_expression                shift and go to state 216

state 211

    (88) elsif_expression -> ELSIF expression then_expression .

    ELSIF           reduce using rule 88 (elsif_expression -> ELSIF expression then_expression .)
    ELSE            reduce using rule 88 (elsif_expression -> ELSIF expression then_expression .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 212

<<<<<<< HEAD
    (147) else_clause -> ELSIF expression then_clause . else_clause
    (148) else_clause -> ELSIF expression then_clause .
    (146) else_clause -> . ELSE action_statement_list
    (147) else_clause -> . ELSIF expression then_clause else_clause
    (148) else_clause -> . ELSIF expression then_clause

    FI              reduce using rule 148 (else_clause -> ELSIF expression then_clause .)
    ELSE            shift and go to state 149
    ELSIF           shift and go to state 151

    else_clause                    shift and go to state 228

state 213

    (150) action_statement_nullable -> action_statement action_statement_nullable .

    ELSE            reduce using rule 150 (action_statement_nullable -> action_statement action_statement_nullable .)
    ELSIF           reduce using rule 150 (action_statement_nullable -> action_statement action_statement_nullable .)
    DCL             reduce using rule 150 (action_statement_nullable -> action_statement action_statement_nullable .)
    SYN             reduce using rule 150 (action_statement_nullable -> action_statement action_statement_nullable .)
    TYPE            reduce using rule 150 (action_statement_nullable -> action_statement action_statement_nullable .)
    ID              reduce using rule 150 (action_statement_nullable -> action_statement action_statement_nullable .)
    IF              reduce using rule 150 (action_statement_nullable -> action_statement action_statement_nullable .)
    $end            reduce using rule 150 (action_statement_nullable -> action_statement action_statement_nullable .)
    FI              reduce using rule 150 (action_statement_nullable -> action_statement action_statement_nullable .)
=======
    (34) result_spec -> RETURNS LPAREN mode LOC . RPAREN

    RPAREN          shift and go to state 217


state 213

    (35) result_spec -> RETURNS LPAREN mode RPAREN .

    SEMI            reduce using rule 35 (result_spec -> RETURNS LPAREN mode RPAREN .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 214

<<<<<<< HEAD
    (79) else_expression -> ELSE expression .

    FI              reduce using rule 79 (else_expression -> ELSE expression .)
=======
    (28) procedure_definition -> PROC LPAREN formal_parameter_list RPAREN result_spec SEMI statement_nullable END . SEMI

    SEMI            shift and go to state 218
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559


state 215

<<<<<<< HEAD
    (80) elsif_expression -> ELSIF expression . then_expression
    (78) then_expression -> . THEN expression

    THEN            shift and go to state 154

    then_expression                shift and go to state 229

state 216

    (81) elsif_expression -> elsif_expression ELSIF . expression then_expression
    (73) expression -> . operand0
    (74) expression -> . conditional_expression
    (82) operand0 -> . operand1
    (83) operand0 -> . operand0 operator1 operand1
    (76) conditional_expression -> . IF expression then_expression else_expression FI
    (77) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (84) operand1 -> . operand2
    (85) operand1 -> . operand1 operator2 operand2
    (86) operand2 -> . operand3
    (87) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (88) operand3 -> . monadic_operator operand4
    (89) operand3 -> . operand4
    (96) monadic_operator -> . MINUS
    (97) monadic_operator -> . NOT
    (90) operand4 -> . array_location
    (91) operand4 -> . referenced_location
    (92) operand4 -> . primitive_value
    (72) array_location -> . location
    (98) referenced_location -> . ARROW array_location
    (115) primitive_value -> . literal
    (116) primitive_value -> . value_array_element
    (117) primitive_value -> . value_array_slice
    (118) primitive_value -> . parenthesized_expression
    (56) location -> . identifier
    (57) location -> . dereferenced_reference
    (58) location -> . string_element
    (59) location -> . string_slice
    (60) location -> . array_element
    (61) location -> . array_slice
    (119) literal -> . integer_literal
    (120) literal -> . boolean_literal
    (121) literal -> . character_literal
    (122) literal -> . empty_literal
    (123) literal -> . character_string_literal
    (124) value_array_element -> . primitive_value LBRACKET expression_list RBRACKET
    (125) value_array_slice -> . primitive_value LBRACKET expression COLON expression RBRACKET
    (75) parenthesized_expression -> . LPAREN expression RPAREN
    (22) identifier -> . ID
    (62) dereferenced_reference -> . array_location ARROW
    (63) string_element -> . identifier LBRACKET start_element LBRACKET
    (65) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (68) array_element -> . array_location LBRACKET expression_list RBRACKET
    (71) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (126) integer_literal -> . ICONST
    (127) boolean_literal -> . TRUE
    (128) boolean_literal -> . FALSE
    (129) character_literal -> . CCONST
    (130) empty_literal -> . NULL
    (131) character_string_literal -> . SCONST

    IF              shift and go to state 31
    MINUS           shift and go to state 36
    NOT             shift and go to state 35
    ARROW           shift and go to state 45
    LPAREN          shift and go to state 44
    ID              shift and go to state 21
    ICONST          shift and go to state 40
    TRUE            shift and go to state 55
    FALSE           shift and go to state 53
    CCONST          shift and go to state 34
    NULL            shift and go to state 27
    SCONST          shift and go to state 52

    location                       shift and go to state 6
    monadic_operator               shift and go to state 47
    operand2                       shift and go to state 49
    value_array_element            shift and go to state 48
    operand1                       shift and go to state 25
    expression                     shift and go to state 230
    conditional_expression         shift and go to state 28
    referenced_location            shift and go to state 29
    parenthesized_expression       shift and go to state 30
    array_slice                    shift and go to state 15
    integer_literal                shift and go to state 32
    empty_literal                  shift and go to state 50
    array_element                  shift and go to state 7
    operand3                       shift and go to state 33
    string_slice                   shift and go to state 3
    string_element                 shift and go to state 1
    boolean_literal                shift and go to state 51
    array_location                 shift and go to state 46
    literal                        shift and go to state 37
    operand0                       shift and go to state 38
    primitive_value                shift and go to state 39
    character_literal              shift and go to state 41
    value_array_slice              shift and go to state 42
    operand4                       shift and go to state 54
    character_string_literal       shift and go to state 43
    dereferenced_reference         shift and go to state 20
    identifier                     shift and go to state 56

state 217

    (77) conditional_expression -> IF expression then_expression elsif_expression else_expression . FI

    FI              shift and go to state 231


state 218

    (76) conditional_expression -> IF expression then_expression else_expression FI .

    DCL             reduce using rule 76 (conditional_expression -> IF expression then_expression else_expression FI .)
    SYN             reduce using rule 76 (conditional_expression -> IF expression then_expression else_expression FI .)
    TYPE            reduce using rule 76 (conditional_expression -> IF expression then_expression else_expression FI .)
    ID              reduce using rule 76 (conditional_expression -> IF expression then_expression else_expression FI .)
    IF              reduce using rule 76 (conditional_expression -> IF expression then_expression else_expression FI .)
    $end            reduce using rule 76 (conditional_expression -> IF expression then_expression else_expression FI .)
    ELSE            reduce using rule 76 (conditional_expression -> IF expression then_expression else_expression FI .)
    ELSIF           reduce using rule 76 (conditional_expression -> IF expression then_expression else_expression FI .)
    FI              reduce using rule 76 (conditional_expression -> IF expression then_expression else_expression FI .)
    COLON           reduce using rule 76 (conditional_expression -> IF expression then_expression else_expression FI .)
    COMMA           reduce using rule 76 (conditional_expression -> IF expression then_expression else_expression FI .)
    RBRACKET        reduce using rule 76 (conditional_expression -> IF expression then_expression else_expression FI .)
    THEN            reduce using rule 76 (conditional_expression -> IF expression then_expression else_expression FI .)
    RPAREN          reduce using rule 76 (conditional_expression -> IF expression then_expression else_expression FI .)
    SEMI            reduce using rule 76 (conditional_expression -> IF expression then_expression else_expression FI .)
    LBRACKET        reduce using rule 76 (conditional_expression -> IF expression then_expression else_expression FI .)


state 219

    (125) value_array_slice -> primitive_value LBRACKET expression COLON expression . RBRACKET

    RBRACKET        shift and go to state 232


state 220

    (40) discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .

    LPAREN          reduce using rule 40 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    ASSIGN          reduce using rule 40 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    COMMA           reduce using rule 40 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    SEMI            reduce using rule 40 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)
    RBRACKET        reduce using rule 40 (discrete_range_mode -> discrete_mode_name LPAREN literal_range RPAREN .)


state 221

    (42) literal_range -> lower_bound COLON . upper_bound
    (44) upper_bound -> . expression
    (73) expression -> . operand0
    (74) expression -> . conditional_expression
    (82) operand0 -> . operand1
    (83) operand0 -> . operand0 operator1 operand1
    (76) conditional_expression -> . IF expression then_expression else_expression FI
    (77) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (84) operand1 -> . operand2
    (85) operand1 -> . operand1 operator2 operand2
    (86) operand2 -> . operand3
    (87) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (88) operand3 -> . monadic_operator operand4
    (89) operand3 -> . operand4
    (96) monadic_operator -> . MINUS
    (97) monadic_operator -> . NOT
    (90) operand4 -> . array_location
    (91) operand4 -> . referenced_location
    (92) operand4 -> . primitive_value
    (72) array_location -> . location
    (98) referenced_location -> . ARROW array_location
    (115) primitive_value -> . literal
    (116) primitive_value -> . value_array_element
    (117) primitive_value -> . value_array_slice
    (118) primitive_value -> . parenthesized_expression
    (56) location -> . identifier
    (57) location -> . dereferenced_reference
    (58) location -> . string_element
    (59) location -> . string_slice
    (60) location -> . array_element
    (61) location -> . array_slice
    (119) literal -> . integer_literal
    (120) literal -> . boolean_literal
    (121) literal -> . character_literal
    (122) literal -> . empty_literal
    (123) literal -> . character_string_literal
    (124) value_array_element -> . primitive_value LBRACKET expression_list RBRACKET
    (125) value_array_slice -> . primitive_value LBRACKET expression COLON expression RBRACKET
    (75) parenthesized_expression -> . LPAREN expression RPAREN
    (22) identifier -> . ID
    (62) dereferenced_reference -> . array_location ARROW
    (63) string_element -> . identifier LBRACKET start_element LBRACKET
    (65) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (68) array_element -> . array_location LBRACKET expression_list RBRACKET
    (71) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (126) integer_literal -> . ICONST
    (127) boolean_literal -> . TRUE
    (128) boolean_literal -> . FALSE
    (129) character_literal -> . CCONST
    (130) empty_literal -> . NULL
    (131) character_string_literal -> . SCONST

    IF              shift and go to state 31
    MINUS           shift and go to state 36
    NOT             shift and go to state 35
    ARROW           shift and go to state 45
    LPAREN          shift and go to state 44
    ID              shift and go to state 21
    ICONST          shift and go to state 40
    TRUE            shift and go to state 55
    FALSE           shift and go to state 53
    CCONST          shift and go to state 34
    NULL            shift and go to state 27
    SCONST          shift and go to state 52

    location                       shift and go to state 6
    monadic_operator               shift and go to state 47
    operand2                       shift and go to state 49
    value_array_element            shift and go to state 48
    operand1                       shift and go to state 25
    expression                     shift and go to state 207
    conditional_expression         shift and go to state 28
    referenced_location            shift and go to state 29
    parenthesized_expression       shift and go to state 30
    array_slice                    shift and go to state 15
    integer_literal                shift and go to state 32
    empty_literal                  shift and go to state 50
    array_element                  shift and go to state 7
    operand3                       shift and go to state 33
    string_slice                   shift and go to state 3
    upper_bound                    shift and go to state 233
    boolean_literal                shift and go to state 51
    array_location                 shift and go to state 46
    literal                        shift and go to state 37
    operand0                       shift and go to state 38
    primitive_value                shift and go to state 39
    character_literal              shift and go to state 41
    value_array_slice              shift and go to state 42
    operand4                       shift and go to state 54
    string_element                 shift and go to state 1
    character_string_literal       shift and go to state 43
    dereferenced_reference         shift and go to state 20
    identifier                     shift and go to state 56

state 222

    (52) index_mode_list -> index_mode COMMA . index_mode_list
    (51) index_mode_list -> . index_mode
    (52) index_mode_list -> . index_mode COMMA index_mode_list
    (53) index_mode -> . discrete_mode
    (54) index_mode -> . literal_range
    (32) discrete_mode -> . integer_mode
    (33) discrete_mode -> . boolean_mode
    (34) discrete_mode -> . character_mode
    (35) discrete_mode -> . discrete_range_mode
    (42) literal_range -> . lower_bound COLON upper_bound
    (37) integer_mode -> . INT
    (38) boolean_mode -> . BOOL
    (39) character_mode -> . CHAR
    (40) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (41) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (43) lower_bound -> . expression
    (36) discrete_mode_name -> . identifier
    (73) expression -> . operand0
    (74) expression -> . conditional_expression
    (22) identifier -> . ID
    (82) operand0 -> . operand1
    (83) operand0 -> . operand0 operator1 operand1
    (76) conditional_expression -> . IF expression then_expression else_expression FI
    (77) conditional_expression -> . IF expression then_expression elsif_expression else_expression FI
    (84) operand1 -> . operand2
    (85) operand1 -> . operand1 operator2 operand2
    (86) operand2 -> . operand3
    (87) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (88) operand3 -> . monadic_operator operand4
    (89) operand3 -> . operand4
    (96) monadic_operator -> . MINUS
    (97) monadic_operator -> . NOT
    (90) operand4 -> . array_location
    (91) operand4 -> . referenced_location
    (92) operand4 -> . primitive_value
    (72) array_location -> . location
    (98) referenced_location -> . ARROW array_location
    (115) primitive_value -> . literal
    (116) primitive_value -> . value_array_element
    (117) primitive_value -> . value_array_slice
    (118) primitive_value -> . parenthesized_expression
    (56) location -> . identifier
    (57) location -> . dereferenced_reference
    (58) location -> . string_element
    (59) location -> . string_slice
    (60) location -> . array_element
    (61) location -> . array_slice
    (119) literal -> . integer_literal
    (120) literal -> . boolean_literal
    (121) literal -> . character_literal
    (122) literal -> . empty_literal
    (123) literal -> . character_string_literal
    (124) value_array_element -> . primitive_value LBRACKET expression_list RBRACKET
    (125) value_array_slice -> . primitive_value LBRACKET expression COLON expression RBRACKET
    (75) parenthesized_expression -> . LPAREN expression RPAREN
    (62) dereferenced_reference -> . array_location ARROW
    (63) string_element -> . identifier LBRACKET start_element LBRACKET
    (65) string_slice -> . identifier LBRACKET left_element COLON right_element RBRACKET
    (68) array_element -> . array_location LBRACKET expression_list RBRACKET
    (71) array_slice -> . array_location LBRACKET lower_bound COLON upper_bound RBRACKET
    (126) integer_literal -> . ICONST
    (127) boolean_literal -> . TRUE
    (128) boolean_literal -> . FALSE
    (129) character_literal -> . CCONST
    (130) empty_literal -> . NULL
    (131) character_string_literal -> . SCONST

    INT             shift and go to state 119
    BOOL            shift and go to state 130
    CHAR            shift and go to state 112
    ID              shift and go to state 21
    IF              shift and go to state 31
    MINUS           shift and go to state 36
    NOT             shift and go to state 35
    ARROW           shift and go to state 45
    LPAREN          shift and go to state 44
    ICONST          shift and go to state 40
    TRUE            shift and go to state 55
    FALSE           shift and go to state 53
    CCONST          shift and go to state 34
    NULL            shift and go to state 27
    SCONST          shift and go to state 52

    string_element                 shift and go to state 1
    operand1                       shift and go to state 25
    expression                     shift and go to state 194
    index_mode                     shift and go to state 197
    referenced_location            shift and go to state 29
    parenthesized_expression       shift and go to state 30
    integer_mode                   shift and go to state 117
    integer_literal                shift and go to state 32
    operand3                       shift and go to state 33
    string_slice                   shift and go to state 3
    location                       shift and go to state 6
    literal                        shift and go to state 37
    operand0                       shift and go to state 38
    boolean_mode                   shift and go to state 122
    character_literal              shift and go to state 41
    value_array_slice              shift and go to state 42
    character_mode                 shift and go to state 124
    discrete_range_mode            shift and go to state 127
    discrete_mode                  shift and go to state 198
    index_mode_list                shift and go to state 234
    array_location                 shift and go to state 46
    monadic_operator               shift and go to state 47
    conditional_expression         shift and go to state 28
    value_array_element            shift and go to state 48
    discrete_mode_name             shift and go to state 116
    operand2                       shift and go to state 49
    array_slice                    shift and go to state 15
    empty_literal                  shift and go to state 50
    literal_range                  shift and go to state 200
    character_string_literal       shift and go to state 43
    boolean_literal                shift and go to state 51
    array_element                  shift and go to state 7
    operand4                       shift and go to state 54
    primitive_value                shift and go to state 39
    lower_bound                    shift and go to state 196
    dereferenced_reference         shift and go to state 20
    identifier                     shift and go to state 201

state 223

    (50) array_mode -> ARRAY LBRACKET index_mode_list RBRACKET . element_mode
    (55) element_mode -> . mode
    (27) mode -> . mode_name
    (28) mode -> . discrete_mode
    (29) mode -> . reference_mode
    (30) mode -> . composite_mode
    (31) mode_name -> . identifier
    (32) discrete_mode -> . integer_mode
    (33) discrete_mode -> . boolean_mode
    (34) discrete_mode -> . character_mode
    (35) discrete_mode -> . discrete_range_mode
    (45) reference_mode -> . REF mode
    (46) composite_mode -> . string_mode
    (47) composite_mode -> . array_mode
    (22) identifier -> . ID
    (37) integer_mode -> . INT
    (38) boolean_mode -> . BOOL
    (39) character_mode -> . CHAR
    (40) discrete_range_mode -> . discrete_mode_name LPAREN literal_range RPAREN
    (41) discrete_range_mode -> . discrete_mode LPAREN literal_range RPAREN
    (48) string_mode -> . CHARS LBRACKET string_length RBRACKET
    (50) array_mode -> . ARRAY LBRACKET index_mode_list RBRACKET element_mode
    (36) discrete_mode_name -> . identifier

    REF             shift and go to state 118
    ID              shift and go to state 21
    INT             shift and go to state 119
    BOOL            shift and go to state 130
    CHAR            shift and go to state 112
    CHARS           shift and go to state 125
    ARRAY           shift and go to state 121

    string_mode                    shift and go to state 111
    mode                           shift and go to state 235
    reference_mode                 shift and go to state 114
    boolean_mode                   shift and go to state 122
    composite_mode                 shift and go to state 123
    integer_mode                   shift and go to state 117
    element_mode                   shift and go to state 236
    character_mode                 shift and go to state 124
    mode_name                      shift and go to state 120
    array_mode                     shift and go to state 115
    discrete_range_mode            shift and go to state 127
    discrete_mode                  shift and go to state 128
    discrete_mode_name             shift and go to state 116
    identifier                     shift and go to state 129

state 224

    (48) string_mode -> CHARS LBRACKET string_length RBRACKET .

    ASSIGN          reduce using rule 48 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    COMMA           reduce using rule 48 (string_mode -> CHARS LBRACKET string_length RBRACKET .)
    SEMI            reduce using rule 48 (string_mode -> CHARS LBRACKET string_length RBRACKET .)


state 225

    (41) discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .

    LPAREN          reduce using rule 41 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    ASSIGN          reduce using rule 41 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    COMMA           reduce using rule 41 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    SEMI            reduce using rule 41 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)
    RBRACKET        reduce using rule 41 (discrete_range_mode -> discrete_mode LPAREN literal_range RPAREN .)


state 226

    (71) array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .

    ARROW           reduce using rule 71 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    LBRACKET        reduce using rule 71 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    TIMES           reduce using rule 71 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    DIVIDE          reduce using rule 71 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    MODULO          reduce using rule 71 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    PLUS            reduce using rule 71 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    MINUS           reduce using rule 71 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    CONCAT          reduce using rule 71 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    AND             reduce using rule 71 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    OR              reduce using rule 71 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    EQUAL           reduce using rule 71 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    NOTEQ           reduce using rule 71 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    GREATER         reduce using rule 71 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    GTEQUAL         reduce using rule 71 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    LESS            reduce using rule 71 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    LTEQUAL         reduce using rule 71 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    IN              reduce using rule 71 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    RPAREN          reduce using rule 71 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    ELSE            reduce using rule 71 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    ELSIF           reduce using rule 71 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    COLON           reduce using rule 71 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    COMMA           reduce using rule 71 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    RBRACKET        reduce using rule 71 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    THEN            reduce using rule 71 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    DCL             reduce using rule 71 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    SYN             reduce using rule 71 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    TYPE            reduce using rule 71 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    ID              reduce using rule 71 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    IF              reduce using rule 71 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    $end            reduce using rule 71 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    FI              reduce using rule 71 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    SEMI            reduce using rule 71 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)
    ASSIGN          reduce using rule 71 (array_slice -> array_location LBRACKET lower_bound COLON upper_bound RBRACKET .)


state 227

    (65) string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .

    ARROW           reduce using rule 65 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    LBRACKET        reduce using rule 65 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    TIMES           reduce using rule 65 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    DIVIDE          reduce using rule 65 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    MODULO          reduce using rule 65 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    PLUS            reduce using rule 65 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    MINUS           reduce using rule 65 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    CONCAT          reduce using rule 65 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    AND             reduce using rule 65 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    OR              reduce using rule 65 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    EQUAL           reduce using rule 65 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    NOTEQ           reduce using rule 65 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    GREATER         reduce using rule 65 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    GTEQUAL         reduce using rule 65 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    LESS            reduce using rule 65 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    LTEQUAL         reduce using rule 65 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    IN              reduce using rule 65 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    COLON           reduce using rule 65 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    COMMA           reduce using rule 65 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    RBRACKET        reduce using rule 65 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    THEN            reduce using rule 65 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    RPAREN          reduce using rule 65 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    DCL             reduce using rule 65 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    SYN             reduce using rule 65 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    TYPE            reduce using rule 65 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    ID              reduce using rule 65 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    IF              reduce using rule 65 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    $end            reduce using rule 65 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    ELSE            reduce using rule 65 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    ELSIF           reduce using rule 65 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    FI              reduce using rule 65 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    SEMI            reduce using rule 65 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)
    ASSIGN          reduce using rule 65 (string_slice -> identifier LBRACKET left_element COLON right_element RBRACKET .)


state 228

    (147) else_clause -> ELSIF expression then_clause else_clause .

    FI              reduce using rule 147 (else_clause -> ELSIF expression then_clause else_clause .)


state 229

    (80) elsif_expression -> ELSIF expression then_expression .

    ELSIF           reduce using rule 80 (elsif_expression -> ELSIF expression then_expression .)
    ELSE            reduce using rule 80 (elsif_expression -> ELSIF expression then_expression .)


state 230

    (81) elsif_expression -> elsif_expression ELSIF expression . then_expression
    (78) then_expression -> . THEN expression

    THEN            shift and go to state 154

    then_expression                shift and go to state 237

state 231

    (77) conditional_expression -> IF expression then_expression elsif_expression else_expression FI .

    DCL             reduce using rule 77 (conditional_expression -> IF expression then_expression elsif_expression else_expression FI .)
    SYN             reduce using rule 77 (conditional_expression -> IF expression then_expression elsif_expression else_expression FI .)
    TYPE            reduce using rule 77 (conditional_expression -> IF expression then_expression elsif_expression else_expression FI .)
    ID              reduce using rule 77 (conditional_expression -> IF expression then_expression elsif_expression else_expression FI .)
    IF              reduce using rule 77 (conditional_expression -> IF expression then_expression elsif_expression else_expression FI .)
    $end            reduce using rule 77 (conditional_expression -> IF expression then_expression elsif_expression else_expression FI .)
    ELSE            reduce using rule 77 (conditional_expression -> IF expression then_expression elsif_expression else_expression FI .)
    ELSIF           reduce using rule 77 (conditional_expression -> IF expression then_expression elsif_expression else_expression FI .)
    FI              reduce using rule 77 (conditional_expression -> IF expression then_expression elsif_expression else_expression FI .)
    COLON           reduce using rule 77 (conditional_expression -> IF expression then_expression elsif_expression else_expression FI .)
    COMMA           reduce using rule 77 (conditional_expression -> IF expression then_expression elsif_expression else_expression FI .)
    RBRACKET        reduce using rule 77 (conditional_expression -> IF expression then_expression elsif_expression else_expression FI .)
    THEN            reduce using rule 77 (conditional_expression -> IF expression then_expression elsif_expression else_expression FI .)
    RPAREN          reduce using rule 77 (conditional_expression -> IF expression then_expression elsif_expression else_expression FI .)
    SEMI            reduce using rule 77 (conditional_expression -> IF expression then_expression elsif_expression else_expression FI .)
    LBRACKET        reduce using rule 77 (conditional_expression -> IF expression then_expression elsif_expression else_expression FI .)


state 232

    (125) value_array_slice -> primitive_value LBRACKET expression COLON expression RBRACKET .

    LBRACKET        reduce using rule 125 (value_array_slice -> primitive_value LBRACKET expression COLON expression RBRACKET .)
    TIMES           reduce using rule 125 (value_array_slice -> primitive_value LBRACKET expression COLON expression RBRACKET .)
    DIVIDE          reduce using rule 125 (value_array_slice -> primitive_value LBRACKET expression COLON expression RBRACKET .)
    MODULO          reduce using rule 125 (value_array_slice -> primitive_value LBRACKET expression COLON expression RBRACKET .)
    PLUS            reduce using rule 125 (value_array_slice -> primitive_value LBRACKET expression COLON expression RBRACKET .)
    MINUS           reduce using rule 125 (value_array_slice -> primitive_value LBRACKET expression COLON expression RBRACKET .)
    CONCAT          reduce using rule 125 (value_array_slice -> primitive_value LBRACKET expression COLON expression RBRACKET .)
    AND             reduce using rule 125 (value_array_slice -> primitive_value LBRACKET expression COLON expression RBRACKET .)
    OR              reduce using rule 125 (value_array_slice -> primitive_value LBRACKET expression COLON expression RBRACKET .)
    EQUAL           reduce using rule 125 (value_array_slice -> primitive_value LBRACKET expression COLON expression RBRACKET .)
    NOTEQ           reduce using rule 125 (value_array_slice -> primitive_value LBRACKET expression COLON expression RBRACKET .)
    GREATER         reduce using rule 125 (value_array_slice -> primitive_value LBRACKET expression COLON expression RBRACKET .)
    GTEQUAL         reduce using rule 125 (value_array_slice -> primitive_value LBRACKET expression COLON expression RBRACKET .)
    LESS            reduce using rule 125 (value_array_slice -> primitive_value LBRACKET expression COLON expression RBRACKET .)
    LTEQUAL         reduce using rule 125 (value_array_slice -> primitive_value LBRACKET expression COLON expression RBRACKET .)
    IN              reduce using rule 125 (value_array_slice -> primitive_value LBRACKET expression COLON expression RBRACKET .)
    COMMA           reduce using rule 125 (value_array_slice -> primitive_value LBRACKET expression COLON expression RBRACKET .)
    RBRACKET        reduce using rule 125 (value_array_slice -> primitive_value LBRACKET expression COLON expression RBRACKET .)
    COLON           reduce using rule 125 (value_array_slice -> primitive_value LBRACKET expression COLON expression RBRACKET .)
    FI              reduce using rule 125 (value_array_slice -> primitive_value LBRACKET expression COLON expression RBRACKET .)
    THEN            reduce using rule 125 (value_array_slice -> primitive_value LBRACKET expression COLON expression RBRACKET .)
    RPAREN          reduce using rule 125 (value_array_slice -> primitive_value LBRACKET expression COLON expression RBRACKET .)
    DCL             reduce using rule 125 (value_array_slice -> primitive_value LBRACKET expression COLON expression RBRACKET .)
    SYN             reduce using rule 125 (value_array_slice -> primitive_value LBRACKET expression COLON expression RBRACKET .)
    TYPE            reduce using rule 125 (value_array_slice -> primitive_value LBRACKET expression COLON expression RBRACKET .)
    ID              reduce using rule 125 (value_array_slice -> primitive_value LBRACKET expression COLON expression RBRACKET .)
    IF              reduce using rule 125 (value_array_slice -> primitive_value LBRACKET expression COLON expression RBRACKET .)
    $end            reduce using rule 125 (value_array_slice -> primitive_value LBRACKET expression COLON expression RBRACKET .)
    ELSE            reduce using rule 125 (value_array_slice -> primitive_value LBRACKET expression COLON expression RBRACKET .)
    ELSIF           reduce using rule 125 (value_array_slice -> primitive_value LBRACKET expression COLON expression RBRACKET .)
    SEMI            reduce using rule 125 (value_array_slice -> primitive_value LBRACKET expression COLON expression RBRACKET .)


state 233

    (42) literal_range -> lower_bound COLON upper_bound .

    RPAREN          reduce using rule 42 (literal_range -> lower_bound COLON upper_bound .)
    COMMA           reduce using rule 42 (literal_range -> lower_bound COLON upper_bound .)
    RBRACKET        reduce using rule 42 (literal_range -> lower_bound COLON upper_bound .)


state 234

    (52) index_mode_list -> index_mode COMMA index_mode_list .

    RBRACKET        reduce using rule 52 (index_mode_list -> index_mode COMMA index_mode_list .)


state 235

    (55) element_mode -> mode .

    ASSIGN          reduce using rule 55 (element_mode -> mode .)
    COMMA           reduce using rule 55 (element_mode -> mode .)
    SEMI            reduce using rule 55 (element_mode -> mode .)


state 236

    (50) array_mode -> ARRAY LBRACKET index_mode_list RBRACKET element_mode .

    ASSIGN          reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode_list RBRACKET element_mode .)
    COMMA           reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode_list RBRACKET element_mode .)
    SEMI            reduce using rule 50 (array_mode -> ARRAY LBRACKET index_mode_list RBRACKET element_mode .)


state 237

    (81) elsif_expression -> elsif_expression ELSIF expression then_expression .

    ELSIF           reduce using rule 81 (elsif_expression -> elsif_expression ELSIF expression then_expression .)
    ELSE            reduce using rule 81 (elsif_expression -> elsif_expression ELSIF expression then_expression .)
=======
    (29) procedure_definition -> PROC LPAREN formal_parameter_list RPAREN SEMI statement_nullable END SEMI .

    DCL             reduce using rule 29 (procedure_definition -> PROC LPAREN formal_parameter_list RPAREN SEMI statement_nullable END SEMI .)
    SYN             reduce using rule 29 (procedure_definition -> PROC LPAREN formal_parameter_list RPAREN SEMI statement_nullable END SEMI .)
    TYPE            reduce using rule 29 (procedure_definition -> PROC LPAREN formal_parameter_list RPAREN SEMI statement_nullable END SEMI .)
    ID              reduce using rule 29 (procedure_definition -> PROC LPAREN formal_parameter_list RPAREN SEMI statement_nullable END SEMI .)
    $end            reduce using rule 29 (procedure_definition -> PROC LPAREN formal_parameter_list RPAREN SEMI statement_nullable END SEMI .)
    END             reduce using rule 29 (procedure_definition -> PROC LPAREN formal_parameter_list RPAREN SEMI statement_nullable END SEMI .)


state 216

    (89) elsif_expression -> elsif_expression ELSIF expression then_expression .

    ELSIF           reduce using rule 89 (elsif_expression -> elsif_expression ELSIF expression then_expression .)
    ELSE            reduce using rule 89 (elsif_expression -> elsif_expression ELSIF expression then_expression .)


state 217

    (34) result_spec -> RETURNS LPAREN mode LOC RPAREN .

    SEMI            reduce using rule 34 (result_spec -> RETURNS LPAREN mode LOC RPAREN .)


state 218

    (28) procedure_definition -> PROC LPAREN formal_parameter_list RPAREN result_spec SEMI statement_nullable END SEMI .

    DCL             reduce using rule 28 (procedure_definition -> PROC LPAREN formal_parameter_list RPAREN result_spec SEMI statement_nullable END SEMI .)
    SYN             reduce using rule 28 (procedure_definition -> PROC LPAREN formal_parameter_list RPAREN result_spec SEMI statement_nullable END SEMI .)
    TYPE            reduce using rule 28 (procedure_definition -> PROC LPAREN formal_parameter_list RPAREN result_spec SEMI statement_nullable END SEMI .)
    ID              reduce using rule 28 (procedure_definition -> PROC LPAREN formal_parameter_list RPAREN result_spec SEMI statement_nullable END SEMI .)
    $end            reduce using rule 28 (procedure_definition -> PROC LPAREN formal_parameter_list RPAREN result_spec SEMI statement_nullable END SEMI .)
    END             reduce using rule 28 (procedure_definition -> PROC LPAREN formal_parameter_list RPAREN result_spec SEMI statement_nullable END SEMI .)
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559

WARNING: 
WARNING: Conflicts:
WARNING: 
<<<<<<< HEAD
WARNING: shift/reduce conflict for LBRACKET in state 24 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 39 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 46 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 56 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 89 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 89 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 106 resolved as shift
WARNING: shift/reduce conflict for ID in state 153 resolved as shift
WARNING: shift/reduce conflict for IF in state 153 resolved as shift
WARNING: shift/reduce conflict for ID in state 183 resolved as shift
WARNING: shift/reduce conflict for IF in state 183 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 201 resolved as shift
=======
WARNING: shift/reduce conflict for LBRACKET in state 73 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 84 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 117 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 122 resolved as shift
>>>>>>> 88849d3a870dbf73feac61d54ae8a198c1391559
